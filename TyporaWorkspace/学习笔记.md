# 1 JDK的安装与配置

# 2 Android Studio的安装与配置

# 3 创建首个简单的Android应用

# 4 Android架构与APK结构

## 4.1 Android架构层级

**定义：**

安卓操作系统的架构分为四个主要层次：

1. **Linux内核层：** 提供底层硬件管理和抽象。
  
2. **系统库和运行时环境：** 包括系统库和运行时环境，负责提供核心功能和运行应用程序。

3. **应用框架：** 提供开发者高级工具和接口，用于构建应用程序。

4. **应用层：** 包括用户直接使用的各种应用程序，如浏览器、社交媒体应用等。

**背景与意义：**

安卓操作系统的架构背后有以下重要特点和意义：

1. **开源性：** 安卓是开源操作系统，允许广泛的社区参与和定制，促进了创新和适应性。

2. **硬件多样性：** 安卓设计考虑到各种移动设备，支持不同尺寸、分辨率和处理能力的硬件，为制造商提供了灵活性。

3. **应用生态系统：** 安卓的架构有助于构建强大的应用生态系统，鼓励开发者创建各种各样的应用程序，提供丰富的用户体验。

4. **用户定制和品牌差异：** 制造商可以自定义用户界面和预装应用，创造独特的品牌差异，增强市场竞争力。

5. **全球普及：** 安卓成为全球移动设备市场主导操作系统，其设计有助于适应不同国家和地区的需求，推动了移动技术的全球普及。

**详细介绍：**

安卓（Android）操作系统的架构可以分为四个主要层次，从下到上依次是：

1. **Linux内核层（Linux Kernel）：** 安卓操作系统基于Linux内核，该层提供了底层硬件抽象、驱动程序支持、安全性和进程管理。Linux内核层负责处理底层硬件的交互，如处理器管理、内存管理、设备驱动、网络堆栈等。

2. **系统库和运行时环境（Libraries and Android Runtime）：** 该层包括一系列的系统库，提供了开发者在应用程序中使用的核心功能。这些库包括图形库、媒体库、数据库支持等。此外，Android Runtime 包括了 Dalvik 虚拟机（在较新版本中可能是ART，即Android Runtime），负责运行和管理Android应用程序的字节码。

3. **应用框架（Application Framework）：** 应用框架层提供了开发者用于构建应用程序的高级工具和接口。这包括各种API（应用程序接口）和系统服务，如Activity Manager、Content Providers、View System等。应用开发者使用这些框架来创建各种类型的应用，同时也可以访问设备的底层功能。

4. **应用层（Applications）：** 这是用户直接与之交互的层次，包括所有的应用程序，如浏览器、电话、联系人管理器、社交媒体应用等。这些应用程序是建立在前面三个层次提供的功能和服务之上的。

总体而言，安卓的架构层次清晰，通过这些层次的分层设计，不仅提供了开发者友好的接口，也使得安卓能够适配不同的硬件平台，同时保证了系统的稳定性和安全性。

Android系统架构分为五层，从上到下依次是应用层、应用架构层、系统库和运行时环境和Linux内核层，如图：

![Android系统架构](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png)

## 4.2 Android APK结构

**定义：**

Android APK（Android Package）是安卓应用程序的打包格式，它是一种用于在安卓设备上安装和分发应用的文件格式。APK文件包含了应用的所有必要组件，包括代码、资源、清单文件等。

**背景与意义：**

Android APK结构的背景与意义：

1. **标准化分发：** APK作为Android应用的标准打包格式，简化了应用的分发和安装过程。

2. **模块化设计：** APK支持组件化打包，提高了应用的灵活性和可维护性。

3. **版本管理和更新：** 提供清晰的版本标识，便于应用的版本管理和更新。

4. **资源管理和国际化：** 通过资源目录支持资源的管理和国际化，使应用更适应不同用户和地区。

5. **应用签名和安全性：** APK结构包含签名信息，确保应用的完整性和防止篡改。

6. **适用于不同开发方式：** 适用于原生和跨平台开发，保持了开发一致性。

7. **简化安卓生态系统：** 为Android生态系统提供了有序、可靠的应用打包和分发机制，促进了Android应用的发展。

**详细介绍：**

Android APK（Android Package）是Android应用程序的打包文件，它包含了应用程序的所有资源、代码、配置文件和清单文件。APK结构采用标准的ZIP文件格式，因此可以使用压缩工具打开查看其内部内容。以下是APK结构的主要组成部分：

1. **META-INF目录：**
   - 包含签名信息和证书，用于验证APK的完整性和来源合法性。其中，`MANIFEST.MF`文件包含APK的摘要信息，`CERT.SF`文件包含摘要信息的签名，`CERT.RSA`文件包含数字证书。
2. **assets目录：**
   - 用于存放应用程序的资源文件，如图片、音频、视频等。这些资源可以通过代码动态加载和使用。
3. **res目录：**
   - 包含了应用程序的所有资源文件，按照不同的密度和尺寸进行分类。主要包括布局文件、字符串、图标、颜色等资源。
4. **lib目录：**
   - 包含针对不同CPU架构的本地库（Native Libraries）。每个架构的库都放在对应的子目录下，例如armeabi、arm64-v8a、x86、x86_64等。
5. **META-INF目录：**
   - 包含了应用程序的清单文件（AndroidManifest.xml）。清单文件描述了应用的基本信息、权限、组件等。
6. **classes.dex文件：**
   - 包含了应用程序的Dalvik字节码，其中Dalvik是Android平台上的Java虚拟机。这个文件包含了所有应用程序的Java类文件。
7. **resources.arsc文件：**
   - 包含了资源表（Resources Table），其中包括所有资源的标识符、类型和值等信息。这有助于加速资源的查找和访问。
8. **AndroidManifest.xml文件：**
   - 位于APK的根目录，是应用程序的清单文件。它描述了应用的各种信息，包括应用的名称、图标、版本号、权限要求、组件等。
9. **其他可能的文件和目录：**
   - 除了上述主要组成部分外，APK中还可能包含其他的文件和目录，如ProGuard混淆配置文件（proguard-rules.pro）、资源文件的缓存（res/drawable/._icon.png）等。

下面以夸克浏览器APK为例查看Android APK的结构，如下图：

![笔记-APK结构](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-APK%E7%BB%93%E6%9E%84.png)

## 4.3 APK文件中resources下各文件夹介绍

**定义：**

在Android应用的`res`目录中，不同的子文件夹用于存放不同类型的资源文件：

1. **drawable：** 存放图形资源，如图标、图片。
2. **layout：** 存放界面布局文件，定义应用界面的结构和组件摆放。
3. **values：** 存放资源值，如字符串、颜色、尺寸等。
4. **mipmap：** 存放应用图标资源，包括启动图标。
5. **menu：** 存放菜单资源文件，用于创建应用菜单。
6. **raw：** 存放原始文件，如音频、视频，不会被编译成资源ID。
7. **anim：** 存放动画资源文件。
8. **xml：** 存放其他以XML格式定义的资源。
9. **drawable-v21：** 针对Android 5.0及以上版本的图形资源。

这种组织结构有助于开发者管理和区分不同种类的资源，以适应不同设备和屏幕尺寸。

**背景与意义：**

Android应用的`res`目录下的各文件夹具有不同的含义和作用，这种组织结构的背景和意义主要体现在以下几个方面：

1. **多设备适配：** Android生态系统包含了众多不同尺寸和密度的设备，例如手机、平板、电视等。不同的设备可能需要不同分辨率的图像和布局文件。通过在`drawable`、`layout`等文件夹中使用不同的后缀（例如`-hdpi`、`-xhdpi`），Android系统能够自动选择适应当前设备的资源，实现多设备适配。

2. **国际化和本地化：** `values`文件夹用于存放不同语言和地区的资源，如字符串、颜色等。这样的设计支持应用的国际化和本地化，使得应用能够以多语言提供服务，更好地满足全球用户的需求。

3. **图标管理：** `mipmap`文件夹用于存放应用图标资源，包括启动图标。通过在不同密度的`mipmap`文件夹中存放相应分辨率的图标，可以确保在不同设备上显示清晰、精美的图标。

4. **资源值的集中管理：** `values`文件夹用于集中管理资源值，包括字符串、颜色、尺寸等。这有助于代码的可维护性和一致性，使得修改应用的外观和行为更加方便。

5. **动画和菜单管理：** `anim`和`menu`文件夹分别用于存放动画和菜单资源，使得这些资源能够被方便地组织和管理。

6. **版本适配：** `drawable-v21`文件夹用于存放适用于Android 5.0及以上版本的图形资源，支持不同版本之间的兼容性。

总体而言，这种资源文件夹的组织结构为Android开发者提供了便利，使得他们能够更好地适应不同设备、语言和版本的要求，提升应用的用户体验。这也是Android生态系统能够广泛适应多样化需求的一个重要因素。

**详细介绍：**

在Android Studio中，Android项目的`res`（resources）目录是用于存放应用程序资源的地方。这个目录包含了多个子目录，每个子目录都有不同的用途。以下是`res`目录中主要子目录的含义：

1. **drawable：**
   - **drawable/：** 存放非常规尺寸的图像资源（例如启动图标、背景等）。
   - **drawable-h[dpi](##x2.1 res下中Drawable文件夹Dpi说明)/、drawable-mdpi/、drawable-xhdpi/、drawable-xxhdpi/、drawable-xxxhdpi/：** 存放根据设备密度不同而优化的图像资源。不同密度的设备会使用相应的目录中的资源。

2. **layout：**
   - **layout/：** 存放XML文件，用于定义应用程序的用户界面布局结构。

3. **mipmap：**
   - **mipmap/：** 存放应用程序图标，这些图标通常用于应用程序启动器和其他设备显示图标的地方。
   - **mipmap-hdpi/、mipmap-mdpi/、mipmap-xhdpi/、mipmap-xxhdpi/、mipmap-xxxhdpi/：** 存放不同密度下的应用程序图标。

4. **values：**
   - **values/：** 存放资源文件，如字符串、颜色、尺寸等的XML文件。
   - **values-hdpi/、values-mdpi/、values-xhdpi/、values-xxhdpi/、values-xxxhdpi/：** 存放根据设备密度不同而优化的资源文件。

5. **raw：**
   - **raw/：** 存放原始资源文件，例如音频或视频文件。

6. **anim：**
   - **anim/：** 存放动画资源文件。

7. **xml：**
   - **xml/：** 存放其他XML文件，例如配置文件等。

8. **menu：**
   - **menu/：** 存放应用程序的菜单资源文件。

9. **drawable-v21：**
   - **drawable-v21/：** 在Android 5.0及以上版本上使用的drawable资源。这个目录可以包含在低于Android 5.0的版本上不使用的资源。

这些资源目录的使用有助于优化应用程序，以便在不同的设备上提供最佳的用户体验。通过将资源放置在适当的目录中，Android系统可以根据设备的特征选择正确的资源。例如，不同密度的屏幕会选择相应密度的图像资源，以确保图像在各种设备上都有良好的显示效果。

下面还是以夸克浏览器为例，查看APK文件中res文件夹下面的文件如下图所示：

![笔记-res文件结构](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-res%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png)

# 5 AndroidMainfest.xml文件

**定义：**

`AndroidManifest.xml` 是Android应用的清单文件，用于在应用中声明和配置应用的各种组件、权限以及其他与应用相关的信息。

**背景与意义：**

`AndroidManifest.xml` 文件在Android开发中具有以下背景和意义：

1. **应用信息和标识：** 包含应用的基本信息，如包名、版本号、图标、应用名，用于应用的唯一标识和展示。

2. **组件声明：** 定义了应用中的各种组件，如活动、服务、广播接收器、内容提供器，告知系统应用的结构和功能。

3. **权限管理：** 通过声明需要的权限，确保应用在运行时能够访问系统或其他应用的敏感资源，并向用户说明应用的需求。

4. **应用入口活动：** 指定了应用的入口点，即启动时首先启动的活动，定义了应用的启动流程。

5. **意图过滤器：** 活动声明意图过滤器，定义能够响应的隐式意图，实现了组件之间的通信。

6. **应用生命周期管理：** 声明了应用的生命周期和行为，包括活动的启动模式、任务栈管理等，有助于开发者控制应用的行为。

7. **应用过滤和分类：** 提供了信息，帮助应用在应用分发平台中被正确过滤和分类，使用户更容易找到和识别应用。

总体而言，`AndroidManifest.xml` 是Android应用的核心配置文件，定义了应用的身份、结构、行为和与系统的交互方式，对于应用的正常运行、用户体验和发布非常关键。

**详细介绍见下面的部分。**

## 5.1 各个字段的理解

`AndroidManifest.xml` 文件中包含了多个字段，每个字段都用于描述应用的不同方面，如应用信息、组件声明、权限要求等。以下是`AndroidManifest.xml` 文件中的一些主要字段及其作用：

1. **`<manifest>` 元素：**`<manifest>` 元素是 Android 应用清单文件（`AndroidManifest.xml`）的根元素，用于定义应用的基本信息、版本信息、组件声明和权限声明。它是配置 Android 应用的入口，包含了应用的核心元数据，如包名、版本号、组件（活动、服务、广播接收器、内容提供器）的声明，以及应用所需的权限。清单文件是 Android 系统了解应用结构和要求的关键文件。

   - **`xmlns:android` 属性：** 该属性定义了 XML 命名空间，通常指向 Android 的命名空间。它是 XML 文件的一部分，用于标识 XML 中使用的命名空间。
   - **`xmlns:tools` 属性：** 是在 `<manifest>` 元素中引入的命名空间，用于提供一些在开发和构建阶段对 Android 应用进行辅助的工具属性。这些属性包括忽略 lint 检查、资源冲突处理以及资源转移等，使开发者能够更灵活地控制应用的开发和构建过程。这些属性通常不影响应用的运行，而是在开发环境中提供一些辅助信息，以提高开发效率和便捷性。
   - **`package` 属性：** 这个属性定义了应用的包名。包名在 Android 中必须是唯一的，它用于标识应用在设备上的唯一性。
   - **`android:versionCode` 属性：** 用于指定应用的版本号，是一个整数值。系统使用它来区分应用的不同版本，版本号越高表示越新的版本。
   - **`android:versionName` 属性:** 用于指定应用的版本名，是一个字符串值。版本名是面向用户的版本标识，可以是人类可读的字符串。

   ```xml
   <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:tools="http://schemas.android.com/tools
       package="com.example.myapp"
       android:versionCode="1"
       android:versionName="1.0">
       <!-- ... -->
   </manifest>
   ```

2. **`<application>` 元素：**`<application>` 元素是 Android 应用清单文件（`AndroidManifest.xml`）中的一个重要部分，它用于配置应用的整体设置和全局属性。

   - **`android:allowBackup 属性`：** 指定应用是否允许进行备份。
   - **`android:dataExtractionRules 属性`：** 指定数据提取规则的 XML 文件，定义了在分析应用数据时应用的规则。
   - **`android:fullBackupContent 属性`：** 指定完整备份时要包含哪些数据的 XML 文件，包含了备份规则，用于定义备份。
   - **`android:icon 属性`：** 指定应用的图标，引用一个 mipmap 中的图标资源。
   - **`android:label 属性`：** 指定应用的标签，即应用名称。它通常引用一个字符串资源，用于显示在设备屏幕上。
   - **`android:roundIcon 属性`：** 指定在支持圆形图标的情况下应用的图标。
   - **`android:supportsRtl 属性`：** 指定应用是否支持从右到左的布局方向。
   - **`android:theme 属性`：** 用于指定应用的主题，决定了应用的整体外观和样式。
   - **`tools:targetApi 属性`：** lint 工具的注释，指定 lint 检查时使用的目标 API 级别。有助于在代码中使用新的 API 特性而不触发 lint 错误。

   ```xml
   <application
       android:allowBackup="true"
       android:dataExtractionRules="@xml/data_extraction_rules"
       android:fullBackupContent="@xml/backup_rules"
       android:icon="@mipmap/ic_launcher"
       android:label="@string/app_name"
       android:roundIcon="@mipmap/ic_launcher_round"
       android:supportsRtl="true"
       android:theme="@style/AppTheme"
       tools:targetApi="31">
       <!-- ... -->
   </application>
   ```

3. **`<activity>` 元素：**`<activity>` 元素是 Android 应用清单文件（`AndroidManifest.xml`）中的一个关键元素，用于定义应用中的活动（Activity）。活动是 Android 应用的用户界面的一个组成部分，每个活动通常对应应用界面的一个屏幕或一个交互单元。

   - **`android:name` 属性:** 指定活动的类名。这个类是应用中定义的一个 Activity 类，用于展示用户界面。
   - **`android:label` 属性:** 指定活动的标签，即显示在屏幕上的标题。
   - **`android:theme` 属性:** 指定活动的主题，决定了该活动的外观和样式。
   - **`android:exported` 属性:** 指定活动是否可以被其他应用的组件调用或访问。如果设置为 `true`，表示该活动是公开的；如果设置为 `false`，表示该活动是私有的，只能被同一应用内的组件调用或访问。

   ```xml
   <activity
       android:name=".MainActivity"
       android:label="@string/app_name"
       android:theme="@style/AppTheme"
       android:exported="true">
       <!-- ... -->
   </activity>
   ```

4. **`<service>` 元素：**`<service>` 元素是 Android 应用清单文件（`AndroidManifest.xml`）中的一个重要元素，用于声明应用中的服务（Service）。服务是一种在后台执行长时间运行操作的组件，可以在没有用户界面的情况下运行，用于执行耗时任务、处理异步操作等。

   - **`android:name` 属性:** 指定服务的类名。这个类定义了一个后台运行的服务组件，用于执行长时间运行的操作。

   ```xml
   <service
       android:name=".MyService">
       <!-- ... -->
   </service>
   ```

5. **`<receiver>` 元素：**`<receiver>` 元素是 Android 应用清单文件（`AndroidManifest.xml`）中的一个关键元素，用于声明应用中的广播接收器（Broadcast Receiver）。广播接收器用于监听和响应系统或应用发送的广播消息，允许应用在特定事件发生时执行相应的操作。

   - **`android:name` 属性:** 指定广播接收器的类名。这个类定义了一个接收广播事件的组件，用于响应系统或应用发出的广播。

   ```xml
   <receiver
       android:name=".MyReceiver">
       <!-- ... -->
   </receiver>
   ```

6. **`<provider>` 元素：**`<provider>` 元素是 Android 应用清单文件（`AndroidManifest.xml`）中的一个重要元素，用于声明应用中的内容提供器（Content Provider）。内容提供器允许应用共享自己的数据，并且可以被其他应用访问。内容提供器通常用于实现数据共享和访问。

   - **`android:name` 属性:** 指定内容提供器的类名。内容提供器用于管理应用内部数据，并通过 URI 共享给其他应用。

   ```xml
   <provider
       android:name=".MyProvider"
       android:authorities="com.example.provider">
       <!-- ... -->
   </provider>
   ```

7. **`<uses-permission>` 元素：**`<uses-permission>` 元素是 Android 应用清单文件（`AndroidManifest.xml`）中的一个关键元素，用于声明应用需要使用的系统或其他应用的功能或资源的权限。这个元素告诉系统应用需要获得哪些权限，以便在运行时访问相关的资源或执行相关的操作。

   - **`android:name` 属性:** 指定应用需要的权限。这个元素用于声明应用需要使用的系统或其他应用的功能或资源。

   ```xml
   <uses-permission android:name="android.permission.INTERNET" />
   ```

这些是`AndroidManifest.xml`文件中一些关键元素和属性的详细解释。这个清单文件是 Android 应用的核心配置文件，其中的配置对于应用的正常运行和与系统的交互非常重要。

整体例子如下：

```xml
<!-- AndroidManifest.xml 文件的根元素 -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp">

    <!--
        应用的基本信息
        package: 应用的包名，必须是唯一的标识符
        android:versionCode: 应用的版本号，用于区分不同版本
        android:versionName: 应用的版本名，可读性更强的版本标识
    -->
    <application
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme">

        <!--
            应用中的活动声明
            android:name: 活动的类名
            android:label: 活动的标签，显示在应用界面上
            android:theme: 活动的主题
        -->
        <activity
            android:name=".MainActivity"
            android:label="@string/app_name"
            android:theme="@style/AppTheme">

            <!-- 活动的 Intent 过滤器，定义活动的启动方式 -->
            <intent-filter>
                <!--
                    <action> 元素指定活动愿意执行的动作，
                    "android.intent.action.MAIN" 表示活动是应用的主入口点。
                -->
                <action android:name="android.intent.action.MAIN" />

                <!--
                    <category> 元素指定有关正在执行的动作的其他信息。
                    "android.intent.category.LAUNCHER" 表示活动应该出现在应用启动器（主屏幕）中。
                -->
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!--
            应用中的服务声明
            android:name: 服务的类名
        -->
        <service
            android:name=".MyService">
            <!-- ... -->
        </service>

        <!--
            应用中的广播接收器声明
            android:name: 广播接收器的类名
        -->
        <receiver
            android:name=".MyReceiver">
            <!-- ... -->
        </receiver>

        <!--
            应用中的内容提供器声明
            android:name: 内容提供器的类名
            android:authorities: 内容提供器的权限标识，唯一标识该提供器
        -->
        <provider
            android:name=".MyProvider"
            android:authorities="com.example.provider">
            <!-- ... -->
        </provider>
    </application>

    <!--
        应用所需的权限声明
        android:name: 权限的名称，即权限标识
    -->
    <uses-permission android:name="android.permission.INTERNET" />

    <!-- ... 其他权限声明 ... -->
</manifest>
```

## 5.2 Android权限申明

**定义：**

在 Android 开发中，权限声明是指在应用的清单文件（`AndroidManifest.xml`）中声明应用需要使用的系统或其他应用的功能或资源的权限。

**背景与意义：**

权限声明是 Android 系统的一项重要的安全特性，确保应用只能在得到用户授权的情况下访问敏感资源和执行敏感操作。

**使用方法：**

1. **使用 `<uses-permission>` 元素：** 权限声明通过 `<uses-permission>` 元素实现。这个元素通常位于清单文件的顶层，直接在 `<manifest>` 元素内声明。

    ```xml
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
        package="com.example.myapp">

        <!-- 声明应用需要的权限 -->
        <uses-permission android:name="android.permission.INTERNET" />
        <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

        <!-- ... 其他元素和声明 ... -->

    </manifest>
    ```

2. **权限的名称：** `android:name` 属性指定权限的名称，即权限标识。这个标识用于描述应用需要获取的权限。例如，`android.permission.INTERNET` 表示应用需要互联网访问权限。

3. **请求不同权限：** 应用可以声明各种不同的权限，根据应用的需求。一些常见的权限包括网络访问、相机使用、位置信息访问等。

4. **动态权限和静态权限：** 权限可以分为静态权限和动态权限。静态权限在应用安装时确定，而动态权限需要在应用运行时向用户请求授权。

5. **Android 权限模型：** Android 6.0（API 级别 23）及以上引入了动态权限模型，通过运行时权限系统来提高用户对应用权限的控制。动态权限需要在应用运行时向用户请求授权，而不是在安装时授予。

6. **权限的检查和请求：** 应用可以使用 `ContextCompat.checkSelfPermission()` 方法来检查权限是否已经被授予。如果权限未被授予，应用可以使用 `ActivityCompat.requestPermissions()` 方法来请求权限。

    ```java
    // 检查权限是否已授予
    if (ContextCompat.checkSelfPermission(this, Manifest.permission.INTERNET)
            != PackageManager.PERMISSION_GRANTED) {
        // 请求权限
        ActivityCompat.requestPermissions(this,
                new String[]{Manifest.permission.INTERNET},
                MY_PERMISSIONS_REQUEST_INTERNET);
    }
    ```

总体而言，权限声明是 Android 应用开发中一项关键的安全特性，它确保应用在访问系统或其他应用的敏感功能和资源时，获得用户的明示授权。开发者应该仔细选择和声明权限，并在需要时进行动态权限请求。

## 5.3 清单注册

**定义：**

清单注册是指在 Android 应用的清单文件（`AndroidManifest.xml`）中注册（声明）应用的各种组件、权限和配置信息的过程。清单文件是 Android 应用的入口，用于描述应用的整体结构、行为和元数据。

**背景与意义：**

- **系统识别应用：** 清单文件告诉 Android 系统应用的基本信息、组件以及需要的权限，使系统能够正确加载和管理应用。
  
- **权限管理：** 清单文件中声明的权限用于指示应用需要哪些系统或其他应用的功能或资源的权限。这是 Android 安全模型的一部分，确保应用只能在得到用户授权的情况下访问敏感资源。

- **组件声明：** 通过清单文件，开发者可以声明应用中的各种组件，如活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、内容提供器（Content Provider）。这些声明告诉系统应用中有哪些可用的功能和模块。

**使用方法：**

清单注册的使用方法涉及以下几个方面：

- **应用信息声明：** 在清单文件中使用 `<manifest>` 元素，声明应用的基本信息，如包名、版本号等。

    ```xml
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
        package="com.example.myapp"
        android:versionCode="1"
        android:versionName="1.0">
        <!-- ... 组件声明和权限声明 ... -->
    </manifest>
    ```

- **组件声明：** 使用 `<activity>`、`<service>`、`<receiver>`、`<provider>` 元素分别声明应用的活动、服务、广播接收器、内容提供器。

    ```xml
    <application>
        <!-- 活动声明 -->
        <activity
            android:name=".MainActivity"
            android:label="@string/app_name">
            <!-- ... -->
        </activity>

        <!-- 服务声明 -->
        <service
            android:name=".MyService">
            <!-- ... -->
        </service>

        <!-- 广播接收器声明 -->
        <receiver
            android:name=".MyReceiver">
            <!-- ... -->
        </receiver>

        <!-- 内容提供器声明 -->
        <provider
            android:name=".MyProvider"
            android:authorities="com.example.provider">
            <!-- ... -->
        </provider>
    </application>
    ```

- **权限声明：** 使用 `<uses-permission>` 元素声明应用需要的权限。

    ```xml
    <uses-permission android:name="android.permission.INTERNET" />
    ```

- **其他配置：** 在清单文件中进行其他配置，如应用主题、启动图标等。

    ```xml
    <application
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme">
        <!-- ... 组件声明 ... -->
    </application>
    ```

清单注册是 Android 应用开发中重要的一环，它为应用的正确运行和与系统的良好交互提供了基础。在开发中，开发者需要仔细编写清单文件，确保所有的组件和配置都得到正确的注册和配置。

# 6 Activity

**定义：**

在Android中，Activity是一种表示用户界面的组件，通常对应于应用程序中的一个屏幕或一个交互单元。每个Activity都是一个独立的界面单元，负责处理用户的交互、展示UI和处理业务逻辑。Android应用通常由多个Activity组成，它们之间可以通过Intent进行通信和切换。

**背景与意义：**

1. **用户界面表示：** Activity负责展示用户界面，用户在应用中的每个界面通常对应一个Activity。这种分离使得应用的各个界面可以模块化开发和维护。
2. **生命周期管理：** Android系统通过Activity的生命周期管理来提供对应用状态的控制。从Activity的创建到销毁，系统会在不同的阶段调用相应的生命周期方法，开发者可以在这些方法中执行适当的操作，例如初始化资源、保存和恢复状态等。
3. **交互和导航：** Activity之间的切换通过Intent进行，这种机制支持了应用内的导航和交互。一个Activity可以启动另一个Activity，并且可以从启动的Activity获取返回结果。
4. **多任务处理：** Android系统支持多任务处理，一个应用中可以包含多个Activity，它们可以在同一应用内或者不同应用之间进行切换，提供了丰富的用户体验。
5. **状态保存与恢复：** Activity可以保存其状态，并在需要时恢复。这对于应对设备旋转、暂停和恢复等情况非常重要，保证用户在切换屏幕方向或者暂时离开应用后能够继续之前的操作。

总的来说，Activity作为Android应用的基本构建块之一，承担着用户界面展示、生命周期管理、交互导航等重要角色，为开发者提供了灵活而强大的工具来创建丰富、交互性强的移动应用。

**使用方法见下面的内容。**

## 6.1 Activity生命周期

**定义：**

在Android中，Activity生命周期指的是一个Activity从被创建到被销毁的整个过程。这个过程中，系统会调用不同的生命周期方法，开发者可以在这些方法中执行必要的操作，以便适应不同的状态和场景。

**背景与意义：**

Activity生命周期的设计背景是为了让开发者能够更好地管理和控制应用的行为，同时适应不同的应用场景和系统状态。生命周期的合理管理可以确保应用的稳定性、性能优化以及提供更好的用户体验。

**详细介绍：**

当介绍Android中Activity的生命周期方法时，我们可以更详细地描述每个方法的调用时机和在应用开发中的具体应用。以下是对每个方法的更详细介绍：

1. **onCreate()：**
   - **定义：** 当Activity首次创建时调用。
   - **调用时机：** 在Activity第一次创建时，通常是在应用启动或通过Intent启动新Activity时。
   - **应用场景：** 在此阶段进行一些重要的初始化工作，如设置布局、绑定数据、初始化变量等。

2. **onStart()：**
   - **定义：** 在Activity可见但并未出现在前台时调用。
   - **调用时机：** 在Activity即将变为可见状态时，但用户尚未开始与其交互。
   - **应用场景：** 在此阶段执行一些轻量级的准备工作，如注册广播接收器、初始化UI元素等。

3. **onResume()：**
   - **定义：** 当Activity出现在前台时调用。
   - **调用时机：** 在Activity成为用户焦点并可与用户进行交互时。
   - **应用场景：** 在此阶段执行与用户直接交互相关的操作，如启动动画、开始传感器监听、启动定时器等。

4. **onPause()：**
   - **定义：** 当Activity即将失去焦点但仍然可见时调用。
   - **调用时机：** 在Activity即将被其他Activity覆盖，但仍然可见时。
   - **应用场景：** 在此阶段执行一些可能影响性能的操作，如保存用户输入、持久化数据或释放轻量级的资源。

5. **onStop()：**
   - **定义：** 当Activity不再可见时调用。
   - **调用时机：** 在Activity完全被其他Activity遮挡或被用户导航到其他应用时。
   - **应用场景：** 在此阶段执行一些较重的资源释放工作，如停止动画、关闭网络连接等。

6. **onDestroy()：**
   - **定义：** 在Activity即将被销毁时调用。
   - **调用时机：** 在Activity即将从内存中移除时，通常是因为用户退出应用或系统回收资源。
   - **应用场景：** 在此阶段进行最终的资源清理，如取消注册广播接收器、释放大内存占用的对象等。

详细了解每个生命周期方法的时机和应用场景，有助于开发者更精确地控制应用的行为，确保在不同的状态下提供出色的用户体验。

## 6.2 Activity启动模式

**定义：**

Activity启动模式是Android应用程序中一个重要的概念，它定义了一个Activity如何启动以及如何与任务栈中的其他Activity交互。每个Activity都可以通过指定启动模式来定义自己的启动和任务管理行为。

**背景与意义：**

Android系统中存在多个任务栈，每个任务栈包含了一系列Activity，而Activity启动模式则决定了新的Activity如何加入或创建任务栈，以及与其他Activity的关系。这种灵活性使得开发者能够更好地控制应用的导航和任务栈的行为，适应不同的用户体验需求。

**详细介绍：**

**1. Standard（标准模式）：**

- **定义：** 默认的启动模式，每次启动都会创建一个新的Activity实例。
- **背景与意义：** 适用于大多数场景，每次启动都是全新的Activity实例，不共享状态。
- **应用场景：** 常用于应用中的通用页面，每次启动都需要独立的实例，不受其他实例的影响。

**2. SingleTop（单顶模式）：**

- **定义：** 如果Activity已经位于任务栈的顶部，不会创建新的实例，而是调用已存在实例的onNewIntent方法。
- **背景与意义：** 适用于需要保持单一实例，并在顶部接收新的Intent的情况，例如处理推送通知。
- **应用场景：** 用于处理需要及时展示在用户面前的通知，确保只有一个实例存在且在顶部。

**3. SingleTask（单任务模式）：**

- **定义：** 如果Activity已经存在于任务栈中，将会使其上的所有Activity出栈，使自身成为栈顶，且不创建新的实例。
- **背景与意义：** 适用于需要确保整个应用中只有一个实例存在的情况，例如应用的主界面。
- **应用场景：** 常用于应用的主界面，确保用户返回主界面时不会重新创建实例，而是直接回到已存在的实例。

**4. SingleInstance（单实例模式）：**

- **定义：** Activity独占一个任务栈，系统不会在该任务栈中启动其他Activity。
- **背景与意义：** 适用于需要在一个独立的任务栈中运行的Activity，常用于独立的、不与其他应用互通的组件。
- **应用场景：** 常用于需要隔离运行的独立组件，确保其在独立的任务栈中运行，不受其他Activity的影响。

了解这些启动模式，开发者可以根据应用场景选择合适的模式，以提高应用的性能、用户体验，并更灵活地管理Activity在任务栈中的交互。

## 6.3 Activity的使用

在 Android 应用程序中，使用 `Activity` 是构建用户界面和处理用户交互的关键组件之一。以下是使用 `Activity` 的基本步骤：

1. **创建 Activity 类：**

首先，创建一个继承自 `Activity` 的 Java 类。在该类中，你可以定义与用户交互的界面元素、处理用户输入等。例如：

```java
// 步骤 1: 创建Activity类
import android.app.Activity;
import android.os.Bundle;

public class MyActivity extends Activity {

    // 在活动创建时调用
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // 设置活动的布局，指定使用 res/layout 目录下的 activity_my.xml 文件
        setContentView(R.layout.activity_my); // 设置布局文件
    }
    
    // TODO: 此处可以添加其他需要的方法和逻辑
}
```

2. **在 AndroidManifest.xml 中声明 Activity：**

在 `AndroidManifest.xml` 文件中声明 `Activity`。这告诉系统应用中的哪个类是一个 `Activity`，并定义了 `Activity` 的一些属性，如启动模式、主题等。示例：

```xml
<!-- 步骤 2: 在AndroidManifest.xml文件中声明Activity -->
<activity android:name=".MyActivity"
          android:label="@string/app_name">

    <!-- 
        定义Activity的启动配置，例如应用启动时的入口。
        在这个例子中，使用 intent-filter 来指定 MAIN 操作和 LAUNCHER 类别，表示这是应用程序的主入口活动。
    -->
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
```

3. **创建布局文件：**

为 `Activity` 创建用户界面，可以使用 XML 布局文件。在 `res/layout` 目录下创建一个 XML 文件，例如 `activity_my.xml`，并定义界面布局：

```xml
<!-- 步骤 3: 创建布局文件 -->
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- 在这里添加用户界面元素，如TextView、Button等 -->

</RelativeLayout>
```

4. **处理用户交互：**

在 `Activity` 中可以处理用户的输入事件，例如点击按钮、输入文本等。通过在 `Activity` 中重写相应的方法来实现。例如，处理按钮点击事件：

```java
// 步骤 4: 处理用户交互
public class MyActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_my);

        // 获取按钮实例
        Button myButton = findViewById(R.id.myButton);

        // 设置按钮点击事件监听器
        myButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                // 在按钮点击时执行的逻辑
                Toast.makeText(MyActivity.this, "Button Clicked", Toast.LENGTH_SHORT).show();
            }
        });
    }
}
```

5. **启动 Activity：**

在其他地方（如另一个 `Activity`、`Service`、`BroadcastReceiver` 等）启动你的 `Activity`。使用 `Intent` 来描述要启动的 `Activity`。例如：

```java
// 步骤 5: 启动Activity
// 在其他地方（如另一个Activity、Service、BroadcastReceiver等）启动你的Activity
Intent intent = new Intent(this, MyActivity.class);
startActivity(intent);
```

通过以上步骤，你可以构建具有用户界面和交互的 Android 应用。在 `Activity` 中处理用户交互，启动其他 `Activity`，并在 `AndroidManifest.xml` 中声明 `Activity`，是 Android 应用开发的基础。下面我们通过一个具体的例子来尝试Activity的创建（上面的步骤是为了便于我们理解`Activity`，根据文件之间的依赖关系，可以按照以下步骤来创建一个`Activity`）：

1. **在 `res/layout` 目录下创建布局文件：**

   activity_main.xml：

   ```xml
   <!-- activity_main.xml -->
   <?xml version="1.0" encoding="utf-8"?>
   <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
       android:layout_width="match_parent"
       android:layout_height="match_parent">
   
       <!-- 创建一个按钮 -->
       <Button
           android:id="@+id/goToSecondButton"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:text="Go to SecondActivity"
           android:layout_centerInParent="true" />
   </RelativeLayout>
   ```

   activity_second.xml：

   ```xml
   <!-- activity_second.xml -->
   <?xml version="1.0" encoding="utf-8"?>
   <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
       android:layout_width="match_parent"
       android:layout_height="match_parent">
   
       <!-- 创建一个 TextView -->
       <TextView
           android:id="@+id/textView"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:text="Welcome to SecondActivity!"
           android:layout_centerInParent="true" />
   </RelativeLayout>
   ```

2. **创建两个`Activity`类：**

   MainActivity：

   ```java
   // MainActivity.java
   import android.app.Activity;
   import android.content.Intent;
   import android.os.Bundle;
   import android.view.View;
   import android.widget.Button;
   
   public class MainActivity extends Activity {
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           // 设置当前活动的布局
           setContentView(R.layout.activity_main);
   
           // 找到布局中的按钮
           Button goToSecondButton = findViewById(R.id.goToSecondButton);
   
           // 设置按钮点击监听器
           goToSecondButton.setOnClickListener(new View.OnClickListener() {
               @Override
               public void onClick(View view) {
                   // 在按钮点击时启动 SecondActivity
                   startSecondActivity();
               }
           });
       }
   
       // 启动 SecondActivity 的方法
       private void startSecondActivity() {
           // 创建一个 Intent 对象，指定从当前活动到 SecondActivity
           Intent intent = new Intent(this, SecondActivity.class);
           // 启动新的 Activity
           startActivity(intent);
       }
   }
   ```

   SecondActivity：

   ```java
   // SecondActivity.java
   import android.app.Activity;
   import android.os.Bundle;
   import android.widget.TextView;
   
   public class SecondActivity extends Activity {
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           // 设置当前活动的布局
           setContentView(R.layout.activity_second);
   
           // 找到布局中的 TextView
           TextView textView = findViewById(R.id.textView);
   
           // 在 SecondActivity 中显示文本
           textView.setText("Welcome to SecondActivity!");
       }
   }
   ```

3. **在 `AndroidManifest.xml` 中声明 `Activity`**：

   ```xml
   <!-- AndroidManifest.xml -->
   <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="com.example.myapp">
   
       <application>
           <!-- 声明主 Activity -->
           <activity android:name=".MainActivity">
               <intent-filter>
                   <action android:name="android.intent.action.MAIN" />
                   <category android:name="android.intent.category.LAUNCHER" />
               </intent-filter>
           </activity>
   
           <!-- 声明第二个 Activity -->
           <activity android:name=".SecondActivity" />
       </application>
   </manifest>
   ```

4. **运行测试：**

   这个例子创建了一个简单的 Android 应用，包含两个活动。用户在主活动（`MainActivity`）中点击按钮，将跳转到第二个活动（`SecondActivity`），并在第二个活动中显示欢迎文本。下面是运行后的结果：

   ![笔记-Activity的使用运行结果](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-Activity%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

# 7 Service

**定义：**

在Android中，Service是一种应用组件，用于执行长时间运行的任务或处理后台操作，而无需直接与用户界面进行交互。它有两种主要类型：Started Service（启动型服务）和Bound Service（绑定型服务）。

**背景与意义：**

Service的使用在Android中有以下的背景与意义：

1. **后台任务执行：** 允许应用在后台执行任务，如下载、数据处理等。
2. **异步操作和多线程：** 可在自己的线程中执行任务，保持应用的响应性。
3. **全局数据共享：** 通过绑定服务，实现应用组件之间的数据共享和操作调用。
4. **与Activity解耦：** 在后台运行，不受Activity生命周期的限制，实现业务逻辑与用户界面的解耦。
5. **定时任务和周期性任务：** 可执行定时或周期性的任务，提高灵活性。

总体来说，Service为开发者提供了在后台执行任务的机制，增强了应用的功能和性能。

**其它介绍以及使用方法见下面的内容。**

## 7.1 Service生命周期

**定义：**

Service是Android应用的一种组件，用于执行长时间运行的任务，不需要与用户界面直接交互。其生命周期包括创建（onCreate）、运行（onStartCommand或onBind）、销毁（onDestroy）三个阶段。这设计有助于资源管理、后台任务执行和系统交互，提高应用性能、稳定性，同时确保用户体验的连贯性。

**背景与意义：**

在Android应用开发中，Service是一种组件，用于执行长时间运行的任务，而不需要直接与用户界面进行交互。以下是Service的背景与意义：

1. **后台任务执行：** Service允许应用在后台执行任务，即使用户切换到其他应用或锁屏，仍能持续运行。这对于执行需要较长时间的操作，如下载、数据同步、音乐播放等，非常有用。
2. **解耦业务逻辑：** 将耗时的任务放在Service中，可以帮助解耦应用的业务逻辑。Activity可以专注于用户交互，而不必处理复杂的后台逻辑。
3. **资源管理：** Service生命周期的设计允许进行资源的初始化和清理，有助于有效管理系统资源，防止内存泄漏，提高应用的稳定性。
4. **跨组件通信：** Service提供了一种跨组件通信的方式，不同组件（如Activity）可以通过Service进行数据交换，实现模块之间的解耦和协同工作。
5. **定时任务和长连接：** Service适用于执行定时任务或保持长连接，例如在后台定期检查更新，监听网络状态变化等。

总体而言，Service在Android应用中的背景与意义在于提供一种机制，使应用能够执行复杂的后台任务，同时确保用户界面的流畅性和响应性。这有助于提升应用的用户体验、性能和功能拓展性。

**详细介绍：**

当我们在Android应用中使用Service时，它会经历以下生命周期阶段：

1. **创建阶段（Created）：**
   - **触发方法：** 当通过`startService()`或`bindService()`方法启动Service时，系统会调用`onCreate()`方法。
   - **形象比喻：** 这就像是Service的“出生时刻”。`onCreate()`方法是Service的出生派对，你可以在这里进行一些初始化工作，比如注册广播接收器或获取系统服务。

2. **运行阶段（Running）：**
   - **触发方法：** 如果Service是通过`startService()`方法启动的，系统会调用`onStartCommand()`方法；如果是通过`bindService()`方法启动的，系统会调用`onBind()`方法。
   - **形象比喻：** 这时候Service就像是一位辛勤工作的员工，默默地为你执行任务。`onStartCommand()`方法提供了传递任务的入口，而`onBind()`方法则用于与Activity或其他组件进行交互。

3. **销毁阶段（Destroyed）：**
   - **触发方法：** 当Service不再需要或者由于系统资源不足而被终止时，系统会调用`onDestroy()`方法。
   - **形象比喻：** 这就像是Service的告别时刻，`onDestroy()`方法是它的告别演说。在这里你可以进行一些清理工作，释放资源，为Service的离开做一些准备工作。

此外，还有一些其他情况需要考虑：
- **绑定与解绑：** 如果Service是通过`bindService()`方法启动的，那么它会与调用方（通常是Activity）绑定。当所有绑定都解除时，系统会调用`onUnbind()`方法。
- **重新启动：** 如果Service是通过`startService()`方法启动的，并且在执行期间被系统终止，系统会尝试重新启动Service，并调用`onStartCommand()`方法，同时传递之前未完成的任务。

这些生命周期方法的合理实现可以确保Service在系统运行时得到有效管理，从而提高应用的性能和稳定性。

## 7.2 startService和bindService的区别

在Android中，`bindService()`和`startService()`都是用于启动Service的方法，但它们在使用方式和生命周期管理上有一些区别，可以通过以下形象的比喻来理解：

**`startService()`方法**：

1. **启动方式：**
   - **比喻：** 就像是开启一台独立的洗衣机。
   - **解释：** 通过`startService()`方法启动Service就像启动了一台洗衣机，它会一直运行直到任务完成，而且Activity与Service之间没有直接的交互，就像你启动了洗衣机后无需一直盯着它，可以自己去做其他事情。

2. **生命周期关系：**
   - **比喻：** 就像是启动了洗衣机，然后你可以离开去做其他事情，洗衣机会一直运行直到任务结束。
   - **解释：** 调用`startService()`后，Service会在后台独立运行，Activity无需等待它完成任务，可以继续自己的工作。

**`bindService()`方法：**

1. **启动方式：**
   - **比喻：** 就像是连接到一台共享的打印机。
   - **解释：** 通过`bindService()`方法启动Service就像连接到了一台共享的打印机，Activity和Service建立了一种绑定关系，它们可以共享信息和相互通信。

2. **生命周期关系：**
   - **比喻：** 就像是连接到打印机后，需要等打印任务完成后才能解除连接。
   - **解释：** 使用`bindService()`方法建立了一种绑定关系，Activity需要等到完成任务后主动解除绑定，否则Service会继续运行。

## 7.3 Service的使用

- **使用`startService`启动模式：**

  在Android中，Service是一种可以在后台执行长时间运行操作而没有用户界面的组件。Service通常用于执行一些异步任务、处理网络请求、播放音乐等需要在后台持续运行的操作。`startService`是其中一种启动Service的方式，下面详细介绍Service的使用过程，包括通信过程。

  **1. 创建Service类**

  首先，你需要创建一个继承自`Service`的类。这个类应该实现`onCreate()`、`onStartCommand()`、`onBind()`和`onDestroy()`等方法，具体取决于你的需求。例如：

  ```java
  public class MyService extends Service {
      
      @Override
      public void onCreate() {
          // 在Service创建时调用，进行初始化工作
      }
  
      @Override
      public int onStartCommand(Intent intent, int flags, int startId) {
          // 当通过startService启动Service时调用，执行耗时任务等操作
          return START_STICKY; // 定义Service的启动模式
      }
  
      @Override
      public IBinder onBind(Intent intent) {
          // 如果Service支持绑定，通过bindService启动时调用
          return null;
      }
  
      @Override
      public void onDestroy() {
          // 在Service销毁时调用，进行资源释放等工作
      }
  }
  ```

  **2. 启动Service**

  使用`startService`方法启动Service。这将触发Service的`onStartCommand`方法。

  ```java
  // 创建一个新的Intent，用于启动服务
  Intent serviceIntent = new Intent(context, MyService.class);
  
  // 使用Intent指定了服务的上下文（context）和目标服务的类（MyService.class）
  
  // 启动服务，这将触发服务的生命周期方法，包括onCreate()和onStartCommand()等
  startService(serviceIntent);
  ```

  **3. Service的启动模式**

  `onStartCommand`方法返回一个整数，表示Service的启动模式。常用的启动模式有：

  - `START_STICKY`: Service被杀死后，系统会尝试重新创建Service，并重新调用`onStartCommand`，但不会恢复Intent。
  - `START_NOT_STICKY`: Service被杀死后，不会尝试重新创建Service。
  - `START_REDELIVER_INTENT`: Service被杀死后，系统会尝试重新创建Service，并重新调用`onStartCommand`，同时会恢复最后一个Intent。

  ```java
  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
      // 该方法在服务被启动时调用，用于执行服务的主要逻辑
  
      // 参数解释：
      // - intent: 由startService()传递的Intent，可用于携带启动服务时传递的信息。
      // - flags: 启动服务的标志，如START_FLAG_REDELIVERY或START_FLAG_RETRY等，通常不直接使用。
      // - startId: 表示此次服务启动的唯一标识符，每次启动服务时都会有不同的startId。
  
      // 执行耗时任务等操作，例如执行网络请求、数据处理等
  
      // 返回值：
      // - START_STICKY: 表示当服务因某些原因终止后，系统会尝试重新创建服务，并重新调用onStartCommand()。
      //   适用于希望服务在被杀死后能够尽快恢复运行的情况。
      //   注意：如果服务因内存不足而被系统销毁，不会重新启动。
      //   START_NOT_STICKY表示服务被杀死后不会自动重新启动。
      //   START_REDELIVER_INTENT表示服务被杀死后，系统会重新传递最后一个Intent，并重新调用onStartCommand()。
  
      return START_STICKY;
  }
  ```

  **4. 与Service通信**

  你可以使用`Intent`来向Service传递数据，例如：

  ```java
  // 创建一个新的Intent，用于启动服务
  Intent serviceIntent = new Intent(context, MyService.class);
  
  // 使用Intent指定了服务的上下文（context）和目标服务的类（MyService.class）
  
  // 通过putExtra()方法向Intent中添加额外的数据，键值对的形式
  serviceIntent.putExtra("key", "value");
  
  // 启动服务，同时将包含额外数据的Intent传递给服务
  startService(serviceIntent);
  ```

  在Service的`onStartCommand`方法中获取数据：

  ```java
  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
      // 检查接收到的Intent是否为空，以及是否包含额外的数据
      if (intent != null && intent.getExtras() != null) {
          
          // 从Intent中获取通过putExtra()方法添加的额外数据，键为"key"
          String data = intent.getStringExtra("key");
          
          // 在这里处理接收到的数据，可以根据实际需求进行相应的业务逻辑
          // 例如，可以在这里执行网络请求、更新UI等操作
          
          // 注意：如果"key"对应的数据类型不是String，需要使用对应的方法进行获取
          // 例如，如果是int类型，则使用 getIntExtra("key", defaultValue)
          // 如果是其他数据类型，类似的方法可以通过不同的数据类型进行获取
          
          // 示例：处理接收到的String类型数据
          if (data != null) {
              // 在这里对接收到的数据进行处理
              // 可以将数据传递给其他方法或模块进行进一步操作
          }
      }
      
      // 返回值：START_STICKY表示当服务因某些原因终止后，系统会尝试重新创建服务，并重新调用onStartCommand()
      return START_STICKY;
  }
  ```

  **5. 停止Service**

  通过`stopService`方法停止Service：

  ```java
  // 创建一个新的Intent，用于停止服务
  Intent serviceIntent = new Intent(context, MyService.class);
  
  // 使用Intent指定了服务的上下文（context）和目标服务的类（MyService.class）
  
  // 停止服务，这将触发服务的 onDestroy() 方法
  stopService(serviceIntent);
  ```

  ### 注意事项
  - Service在后台执行，不应该执行耗时操作，否则可能导致ANR（Application Not Responding）错误。
  - 如果Service需要与Activity等组件进行通信，可以考虑使用`Messenger`、`BroadcastReceiver`等机制。

  这是一个简单的Service使用过程，具体的实现可能会根据你的需求而有所不同。下面以一个下载文件的例子来说明在`bindService`启动模式下Service的使用：

  假设你有一个简单的Service，用于下载文件，并且你希望能够通过`startService`启动Service，并通过`Intent`传递下载链接。以下是一个详细的例子：

  **1. 创建`DownloadService`类：**

  ```java
  package com.cfk.servicestudy.service;
  
  import android.app.Service;
  import android.content.Intent;
  import android.os.AsyncTask;
  import android.os.IBinder;
  import android.util.Log;
  
  import androidx.annotation.Nullable;
  
  /**
   * DownloadService是一个后台服务，用于执行下载任务
   * 通过Intent传递下载任务的URL
   */
  public class DownloadService extends Service {
      private static final String TAG = "DownloadService";
  
      @Override
      public void onCreate() {
          super.onCreate();
          // 当服务被创建时调用，可以在这里进行一些初始化操作
          Log.d(TAG, "Service created");
      }
  
      @Override
      public int onStartCommand(Intent intent, int flags, int startId) {
          // 当服务被启动时调用，接收通过Intent传递的下载任务URL
          if (intent != null && intent.hasExtra("url")) {
              String downloadUrl = intent.getStringExtra("url");
              
              // 创建并执行异步下载任务
              new DownloadTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, downloadUrl);
          }
  
          // 返回START_STICKY，表示当服务因某些原因终止后，系统会尝试重新创建服务，并重新调用onStartCommand()
          return START_STICKY;
      }
  
      @Nullable
      @Override
      public IBinder onBind(Intent intent) {
          // onBind()方法用于绑定服务，此处返回null表示该服务不支持绑定
          return null;
      }
  
      @Override
      public void onDestroy() {
          super.onDestroy();
          // 当服务被销毁时调用，可以在这里进行一些资源释放和清理操作
          Log.d(TAG, "Service destroyed");
      }
  
      /**
       * DownloadTask是一个异步任务，用于执行后台下载操作
       */
      private class DownloadTask extends AsyncTask<String, Void, Boolean> {
          @Override
          protected Boolean doInBackground(String... strings) {
              if (strings.length > 0) {
                  String downloadUrl = strings[0];
                  
                  // 在后台执行下载任务，这里简单模拟下载
                  try {
                      Thread.sleep(5000); // 模拟下载耗时
                      Log.d(TAG, "Download completed: " + downloadUrl);
                      return true;
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                      return false;
                  }
              }
              return false;
          }
  
          @Override
          protected void onPostExecute(Boolean aBoolean) {
              super.onPostExecute(aBoolean);
              
              // 下载任务完成后停止服务
              stopSelf();
          }
      }
  }
  ```

  **2. 在`AndroidManifest.xml`中注册Service：**

  ```xml
  <!-- 
      在AndroidManifest.xml文件中注册DownloadService服务
      Service元素用于声明一个服务，指定服务的类名
      android:name=".service.DownloadService" 表示服务的类是当前应用程序包中的service包下的DownloadService
  -->
  <service android:name=".service.DownloadService"/>
  ```

  **3. 在`res/layout`目录下创建`activity_main.xml`布局文件：**

  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <!-- 
      activity_main.xml布局文件定义了MainActivity的用户界面
      使用ConstraintLayout作为根布局，提供灵活的控件排列和定位
      布局中包含一个Button用于触发下载操作
  -->
  <androidx.constraintlayout.widget.ConstraintLayout
      xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:app="http://schemas.android.com/apk/res-auto"
      xmlns:tools="http://schemas.android.com/tools"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      tools:context=".MainActivity">
  
      <!-- 下载按钮 -->
      <Button
          android:id="@+id/downloadFileButton"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="下载文件"
          app:layout_constraintTop_toTopOf="parent"
          app:layout_constraintBottom_toBottomOf="parent"
          app:layout_constraintStart_toStartOf="parent"
          app:layout_constraintEnd_toEndOf="parent"/>
  </androidx.constraintlayout.widget.ConstraintLayout>
  ```

  **4.创建MainActivity并在MainActivity中启动Service：**

  ```java
  package com.cfk.servicestudy;
  
  import androidx.appcompat.app.AppCompatActivity;
  
  import android.content.Intent;
  import android.os.Bundle;
  import android.view.View;
  import android.widget.Button;
  
  import com.cfk.servicestudy.service.DownloadService;
  
  public class MainActivity extends AppCompatActivity {
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          
          // 设置Activity的布局
          setContentView(R.layout.activity_main);
          
          // 找到布局中的按钮
          Button downloadFileButton = findViewById(R.id.downloadFileButton);
  
          // 设置按钮点击监听器
          downloadFileButton.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View view) {
                  // 在按钮点击时启动DownloadService
                  startDownloadService();
              }
          });
      }
  
      /**
       * 启动DownloadService服务，传递下载链接
       */
      private void startDownloadService() {
          // 定义下载链接
          String downloadUrl = "https://example.com/file.zip";
          
          // 创建Intent对象，指定启动DownloadService的上下文和目标服务的类
          Intent serviceIntent = new Intent(this, DownloadService.class);
          
          // 通过putExtra()方法向Intent中添加额外的数据，键为"url"，值为下载链接
          serviceIntent.putExtra("url", downloadUrl);
  
          // 启动服务，将包含额外数据的Intent传递给服务
          startService(serviceIntent);
      }
  
  }
  ```

  在这个例子中，当`MainActivity`启动时，它会启动`DownloadService`，并通过`Intent`传递下载链接。`DownloadService`中的`DownloadTask`使用`AsyncTask`在后台执行模拟的下载任务，下载完成后通过`stopSelf()`停止Service。

  **5.运行测试：**

  我们启动服务，并点击下载文件按钮，运行结果如下：

  ![笔记-startService()启动模式下Service使用运行结果](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-startService()%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8BService%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

  由上图可知，当点击下载文件按钮后，控制台依次输出了Service created、Download completed: `https://example.com/file.zip`和Service destroyed三行内容。

  请注意，这只是一个简单的例子，实际的下载任务可能涉及到更复杂的操作，如网络请求、文件保存等。此外，对于实际应用程序，你可能需要考虑使用更健壮的下载库或服务。

- **使用`bindService`启动模式：**

  在Android中，Service是一种可以在后台执行长时间运行操作而不提供用户界面的组件。Service可以通过`bindService`方法进行启动，并且这种方式的启动通常用于实现客户端-服务端的通信。下面是按照`bindService`启动模式讲解Service的使用过程，包含通信过程的详细步骤：

  1. **创建Service类：**
     首先，创建一个继承自`Service`的类，该类将包含你要在后台执行的逻辑。在这个类中，你需要重写`onCreate()`、`onBind()`等方法。

     ```java
     public class MyService extends Service {
         // 服务逻辑实现
         @Override
         public void onCreate() {
             // 在服务创建时执行初始化操作
             super.onCreate();
         }
     
         @Override
         public IBinder onBind(Intent intent) {
             // 返回一个IBinder实例，用于客户端与服务通信
             return null;
         }
     }
     ```

  2. **在Manifest中注册Service：**
     在AndroidManifest.xml文件中注册你的Service。

     ```xml
     <service android:name=".MyService" />
     ```

  3. **启动Service：**
     在你的Activity或其他组件中，使用`bindService`方法启动Service。

     ```java
     Intent intent = new Intent(this, MyService.class);
     bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
     ```

  4. **创建ServiceConnection：**
     创建一个`ServiceConnection`实例，该实例用于在服务连接和断开时接收通知。

     ```java
     private ServiceConnection serviceConnection = new ServiceConnection() {
         @Override
         public void onServiceConnected(ComponentName name, IBinder service) {
             // 服务连接成功时调用
         }
     
         @Override
         public void onServiceDisconnected(ComponentName name) {
             // 服务断开连接时调用
         }
     };
     ```

  5. **在Service中实现通信：**
     通过`onBind`方法返回一个`IBinder`实例，该实例用于客户端与服务进行通信。

     ```java
     public class MyService extends Service {
         private final IBinder binder = new MyBinder();
     
         @Override
         public IBinder onBind(Intent intent) {
             return binder;
         }
     
         // 内部类实现Binder
         public class MyBinder extends Binder {
             public MyService getService() {
                 return MyService.this;
             }
         }
     }
     ```

  6. **在客户端中使用服务：**
     在`onServiceConnected`方法中，你可以获取到`IBinder`实例，从而获取到Service的实例。

     ```java
     @Override
     public void onServiceConnected(ComponentName name, IBinder service) {
         MyService.MyBinder binder = (MyService.MyBinder) service;
         MyService myService = binder.getService();
         // 在这里可以调用Service中的方法
     }
     ```

  7. **与Service通信：**
     现在，你可以在客户端通过获取到的`myService`实例调用Service中的方法，实现双方之间的通信。

     ```java
     public class MyService extends Service {
         public void doSomething() {
             // 在Service中执行某些操作
         }
     }
     ```

     在客户端：

     ```java
     myService.doSomething(); // 调用Service中的方法
     ```

  总体而言，使用`bindService`方式启动Service允许你实现更为灵活的双向通信，客户端可以调用Service中的方法，而Service也可以通过Binder将自身的引用传递给客户端，使得客户端可以直接与Service交互。下面以一个下载文件的例子来说明在`bindService`启动模式下Service的使用：
  
  1. **设置布局**
  
     在`res/layout`文件夹中，创建一个`activity_main.xml`文件，定义一个按钮和一个TextView，用于显示计数器的值。
  
     **activity_main.xml:**
  
     ```xml
     <?xml version="1.0" encoding="utf-8"?>
     <androidx.constraintlayout.widget.ConstraintLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:app="http://schemas.android.com/apk/res-auto"
         xmlns:tools="http://schemas.android.com/tools"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
         tools:context=".activity.MainActivity">
     
         <!-- 递增按钮 -->
         <Button
             android:id="@+id/incrementButton"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
             android:text="递增计数"
             app:layout_constraintTop_toTopOf="parent"
             app:layout_constraintBottom_toTopOf="@+id/countTextView"
             app:layout_constraintStart_toStartOf="parent"
             app:layout_constraintEnd_toEndOf="parent"
             app:layout_constraintVertical_bias="0.5"/>
         <!-- 按钮被约束到父容器的顶部，位于TextView的上方，并水平居中。 -->
     
         <!-- 计数 TextView -->
         <TextView
             android:id="@+id/countTextView"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
             android:text="计数：0"
             app:layout_constraintTop_toBottomOf="@+id/incrementButton"
             app:layout_constraintBottom_toBottomOf="parent"
             app:layout_constraintStart_toStartOf="parent"
             app:layout_constraintEnd_toEndOf="parent"
             app:layout_constraintVertical_bias="0.5"
             android:layout_marginTop="16dp"/>
         <!-- TextView被约束到递增按钮的下方，位于父容器的底部，并水平居中。
              同时在顶部添加了一些间距。 -->
     
     </androidx.constraintlayout.widget.ConstraintLayout>
     ```
  
  2. **创建服务类**
  
     在`com/xxx/xxx`文件夹下创建一个`service`软件包，再在该软件包下面创建一个后台服务类`CounterService.java`，用于管理计数器的逻辑。
  
     **CounterService.java:**
  
     ```java
     package com.cfk.servicestudy2.service;
     
     import android.app.Service;
     import android.content.Intent;
     import android.os.Binder;
     import android.os.IBinder;
     
     import androidx.annotation.Nullable;
     
     public class CounterService extends Service {
         private int count = 0;
         private final IBinder iBinder = new CounterBinder();
     
         @Nullable
         @Override
         public IBinder onBind(Intent intent) {
             // 当Activity通过bindService()方法绑定到服务时，会调用该方法，返回一个IBinder实例供Activity调用
             return iBinder;
         }
     
         public class CounterBinder extends Binder {
             // 自定义Binder类，用于返回CounterService实例给Activity
             public CounterService getService() {
                 return CounterService.this;
             }
         }
     
         // 获取计数器的当前值
         public int getCount() {
             return count;
         }
     
         // 递增计数器的值
         public void incrementCount() {
             count++;
         }
     }
     ```
  
  3. **创建主活动类**
  
     在`com/xxx/xxx`文件夹下创建一个`activity`软件包，再在该软件包下面创建一个后台服务类`MainActivity.java`，该类包含按钮的点击事件和与服务的通信。
  
     **MainActivity.java:**
  
     ```java
     package com.cfk.servicestudy2.activity;
     
     import android.content.ComponentName;
     import android.content.Context;
     import android.content.Intent;
     import android.content.ServiceConnection;
     import android.os.Bundle;
     import android.os.IBinder;
     import android.util.Log;
     import android.view.View;
     import android.widget.Button;
     import android.widget.TextView;
     
     import androidx.annotation.Nullable;
     import androidx.appcompat.app.AppCompatActivity;
     
     import com.cfk.servicestudy2.R;
     import com.cfk.servicestudy2.service.CounterService;
     
     /**
      * 主Activity，用于演示与CounterService的绑定和通信
      */
     public class MainActivity extends AppCompatActivity {
         private CounterService counterService;
         private boolean isBound = false;
     
         // ServiceConnection 用于处理与服务的连接和断开连接
         private ServiceConnection serviceConnection = new ServiceConnection() {
             @Override
             public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
                 // 当服务连接成功时调用
                 CounterService.CounterBinder counterBinder = (CounterService.CounterBinder) iBinder;
                 counterService = counterBinder.getService();
     
                 Log.d("ServiceStudy2", "Service connected, isBound: " + isBound);
     
                 isBound = true;
             }
     
             @Override
             public void onServiceDisconnected(ComponentName componentName) {
                 // 当服务断开连接时调用
                 isBound = false;
             }
         };
     
         @Override
         protected void onCreate(@Nullable Bundle savedInstanceState) {
             super.onCreate(savedInstanceState);
             setContentView(R.layout.activity_main);
     
             // 启动并绑定服务
             Intent intent = new Intent(this, CounterService.class);
             bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
     
             // 设置按钮点击事件
             Button incrementButton = findViewById(R.id.incrementButton);
             incrementButton.setOnClickListener(new View.OnClickListener() {
                 @Override
                 public void onClick(View view) {
                     if (isBound) {
                         // 通过服务递增计数
                         counterService.incrementCount();
     
                         Log.d("ServiceStudy2", "Count after increment: " + counterService.getCount());
     
                         // 更新UI显示
                         updateCountText();
                     } else {
                         Log.d("ServiceStudy2", "Service not bound");
                     }
                 }
             });
         }
     
         /**
          * 更新UI中的计数文本
          */
         private void updateCountText() {
             TextView countTextView = findViewById(R.id.countTextView);
             countTextView.setText("Count：" + counterService.getCount());
         }
     
         @Override
         protected void onDestroy() {
             super.onDestroy();
     
             // 解绑服务，避免内存泄漏
             if (isBound) {
                 unbindService(serviceConnection);
                 isBound = false;
             }
         }
     }
     ```
  
  4. **注册活动与服务**
  
     在`AndroidManifest.xml`文件中注册活动与服务。
  
     **AndroidManifest.xml:**
  
     ```xml
     <?xml version="1.0" encoding="utf-8"?>
     <manifest xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:tools="http://schemas.android.com/tools">
     
         <application
             android:allowBackup="true"
             android:dataExtractionRules="@xml/data_extraction_rules"
             android:fullBackupContent="@xml/backup_rules"
             android:icon="@mipmap/ic_launcher"
             android:label="@string/app_name"
             android:roundIcon="@mipmap/ic_launcher_round"
             android:supportsRtl="true"
             android:theme="@style/Theme.ServiceStudy2"
             tools:targetApi="31">
     
             <!-- 主Activity -->
             <activity
                 android:name=".activity.MainActivity"
                 android:exported="true">
                 <!-- 包含启动应用程序的主要意图过滤器 -->
                 <intent-filter>
                     <action android:name="android.intent.action.MAIN"/>
                     <category android:name="android.intent.category.LAUNCHER"/>
                 </intent-filter>
             </activity>
     
             <!-- 计数服务 -->
             <service
                 android:name=".service.CounterService"/>
                 <!-- 用于处理计数逻辑的服务 -->
     
         </application>
     
     </manifest>
     ```
  
  5. **运行测试应用**
  
     通过Android Studio运行应用程序，点击按钮时计数器的值将递增，显示在TextView中。
  
     运行结果如下图所示：
  
     ![笔记-bindService()启动模式下Service使用运行结果](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-bindService()%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8BService%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)
  
     日志输出结果如下图所示：
  
     ![笔记-bindService()启动模式下Service使用日志输出](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-bindService()%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%B8%8BService%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA.png)
  
     这个例子演示了如何创建一个简单的Android应用，使用后台服务来管理计数器，并通过`bindService`方法实现与服务的通信。这种通信模式使得Activity可以调用服务中的方法，实现双向交互。

# 8 Broadcast

**定义：**

Broadcast（广播）是Android开发中的一种消息传递机制，用于在应用程序组件之间进行通信。通过广播，一个组件可以向其他组件发送事件或消息，而不需要直接调用它们的方法。这种通信方式基于发布-订阅模式，使用 Intent 对象进行消息的封装和传递。

**背景与意义：**

1. **松散耦合：** 提供了一种松散耦合的通信方式，使得应用程序的各个组件之间不直接依赖于彼此，提高了代码的灵活性和可维护性。
2. **系统事件通知：** Android系统内部产生的各种事件，如屏幕解锁、网络状态变化、电池状态变化等，通过广播进行通知。应用程序可以监听这些系统事件，以便在事件发生时采取相应的操作，增强应用的交互性和实时性。
3. **自定义事件传递：** 应用程序可以定义自己的广播事件，用于在应用内不同组件之间传递消息。这使得组件之间可以进行灵活的协同工作，例如在后台 Service 中完成某项任务后通知 Activity 更新UI。
4. **动态注册与静态注册：** BroadcastReceiver 可以通过动态注册（在代码中注册）或静态注册（在AndroidManifest.xml文件中注册）两种方式实现，提供了灵活性，使开发者可以根据需要选择注册方式。

总体而言，Broadcast是Android开发中用于实现组件间松散耦合通信的重要机制，为应用程序提供了一种灵活的事件传递方式，促使组件之间更好地协同工作。

**详细介绍以及使用方式如下。**

## 8.1 Broadcast的注册方式

在Android中，Broadcast的注册方式有两种：动态注册和静态注册。这两种注册方式允许组件（通常是`BroadcastReceiver`）接收特定的广播消息。下面将详细介绍这两种注册方式的特点和步骤。

**1. 动态注册：**

动态注册是通过在代码中动态注册`BroadcastReceiver`来实现的，这意味着你可以在运行时根据需要注册或注销广播接收器。这种注册方式常用于需要在特定情况下才接收广播的场景。

**步骤：**

1. **创建 BroadcastReceiver：** 创建一个继承自`BroadcastReceiver`的类，并实现`onReceive`方法，处理接收到的广播消息。

    ```java
    public class MyReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            // 处理接收到的广播消息
        }
    }
    ```

2. **在代码中注册：** 在需要接收广播的地方，通过`registerReceiver`方法进行动态注册。

    ```java
    MyReceiver myReceiver = new MyReceiver();
    IntentFilter filter = new IntentFilter("com.example.MY_ACTION");
    registerReceiver(myReceiver, filter);
    ```

3. **注意事项：** 在合适的生命周期中（通常在`onCreate`中注册，在`onDestroy`中注销），确保注册和注销成对出现，防止内存泄漏。

**2. 静态注册：**

静态注册是通过在AndroidManifest.xml文件中声明`<receiver>`元素来实现的，这种方式会在应用安装时就注册广播接收器，使得应用程序在未运行的情况下也能接收广播。

**步骤：**

1. **创建 BroadcastReceiver：** 仍然需要创建一个继承自`BroadcastReceiver`的类，实现`onReceive`方法。

    ```java
    public class MyReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            // 处理接收到的广播消息
        }
    }
    ```

2. **在AndroidManifest.xml中声明：** 在`<application>`标签内声明`<receiver>`元素，指定接收的广播和广播接收器。

    ```xml
    <receiver android:name=".MyReceiver">
        <intent-filter>
            <action android:name="com.example.MY_ACTION" />
        </intent-filter>
    </receiver>
    ```

3. **注意事项：** 静态注册的广播接收器会在应用程序安装时生效，因此要确保广播接收器的代码逻辑不会导致应用程序无法正常启动。

总的来说，动态注册适用于需要根据运行时条件决定是否接收广播的场景，而静态注册适用于希望应用在未运行时也能接收广播的场景。在选择注册方式时，需要根据具体的需求来决定使用哪种方式。

## 8.2 外部Broadcast和内部Broadcast的使用

在Android开发中，Broadcast（广播）是一种类似于无线电波的通信机制，它允许应用程序的不同组件之间进行消息传递，就像在空气中发送信号一样。这种通信方式有两个主要类型：外部广播和内部广播。下面将详细介绍它们的运作方式。

### 8.2.1 外部Broadcast

**1. 定义广播接收器：** 就像准备一台接收无线电信号的设备一样，我们创建了一个专门的接收器，即`MyReceiver`类，它继承自`BroadcastReceiver`，用于处理接收到的广播消息。

```java
public class MyReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 处理接收到的广播消息
        String message = intent.getStringExtra("key");
        // 执行相应的操作
    }
}
```

**2. 注册广播接收器：** 在Manifest文件中注册广播接收器，就像在无线电上调谐到正确的频道一样，指定要接收的广播类型。

```xml
<receiver
    android:name=".MyReceiver"
    android:enabled="true"
    android:exported="true">
    <intent-filter>
        <action android:name="com.example.MY_ACTION" />
    </intent-filter>
</receiver>
```

**3. 发送广播：** 当需要发送广播时，创建一个`Intent`，设置相应的动作（Action），然后通过`sendBroadcast()`方法发送广播，就像向空气中发送一条无线电消息一样。

```java
Intent intent = new Intent("com.example.MY_ACTION");
intent.putExtra("key", "Hello, World!");
sendBroadcast(intent);
```

下面我们通过一个具体的例子来介绍外部广播，如下：

**1. 发送广播的发起方（发送方）：**

**（1）创建布局文件activity_main.xml：**

在`res/layout`目录下创建布局文件`activity_main.xml`，如下：

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- ConstraintLayout 用于创建约束布局，将视图元素放置在相对于父布局和其他元素的位置 -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".activity.MainActivity">

    <!-- Button 元素表示一个可点击的按钮 -->
    <Button
        android:id="@+id/broadcastButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="发送广播" <!-- 设置按钮上显示的文本 -->
        app:layout_constraintTop_toTopOf="parent" <!-- 将按钮的顶部约束到父布局的顶部 -->
        app:layout_constraintBottom_toBottomOf="parent" <!-- 将按钮的底部约束到父布局的底部 -->
        app:layout_constraintStart_toStartOf="parent" <!-- 将按钮的开始位置约束到父布局的开始位置 -->
        app:layout_constraintEnd_toEndOf="parent" <!-- 将按钮的结束位置约束到父布局的结束位置 -->
        android:onClick="sendCustomBroadcast" /> <!-- 设置按钮点击时触发的方法为 sendCustomBroadcast -->

</androidx.constraintlayout.widget.ConstraintLayout>
```

**说明：**

- `ConstraintLayout` 是一种灵活的布局，通过设置元素之间的约束关系，可以实现相对位置的定义。
- `Button` 元素表示一个可点击的按钮，这里用于触发发送广播的操作。
- `layout_constraintTop_toTopOf` 将按钮的顶部约束到父布局的顶部，使其垂直居中。
- `layout_constraintBottom_toBottomOf` 将按钮的底部约束到父布局的底部，确保按钮的高度不会溢出。
- `layout_constraintStart_toStartOf` 将按钮的开始位置约束到父布局的开始位置，确保按钮在水平方向上居中。
- `layout_constraintEnd_toEndOf` 将按钮的结束位置约束到父布局的结束位置，保证按钮在水平方向上不会偏移。
- `android:onClick="sendCustomBroadcast"` 设置按钮点击时触发的方法为 `sendCustomBroadcast`，这是在 `MainActivity` 类中定义的一个方法，用于发送广播。

这些注释和说明旨在帮助理解布局文件中各个元素的作用和约束关系。希望对你有帮助。

**（2）创建MainActivity.java文件：**

在主包下床架`activity`软件包，并在其下面创建`MainActivity.java`文件，如下：

```java
package com.cfk.externalbroadcastlearning.activity;

//MainActivity 用于演示发送外部广播的示例
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import androidx.appcompat.app.AppCompatActivity;

import com.cfk.externalbroadcastlearning.R;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    /**
     * 按钮点击时触发，用于发送自定义广播
     *
     * @param view 按钮视图
     */
    public void sendCustomBroadcast(View view) {
        // 创建一个Intent对象，指定广播的动作（Action）
        Intent intent = new Intent("com.cfk.CUSTOM_BROADCAST");

        // 在Android 8.0 以上要求静态注册的BroadcastReceiver所接收的消息必须是显式的，
        // 我们通过设置包名的方式来告诉系统这个Intent是要发给哪个应用来接收。不设置的话就会接收不到消息
        intent.setPackage("com.cfk.externalbroadcastlearning");

        // 可以添加额外的数据到广播中
        intent.putExtra("message", "Hello from the broadcast!");

        // 发送广播
        sendBroadcast(intent);
    }
}
```

**说明：**

- `MainActivity` 是用于演示发送外部广播的活动。
- `sendCustomBroadcast` 方法是在按钮点击时触发的方法，用于发送自定义广播。
- 创建一个 `Intent` 对象，指定广播的动作（Action），这里的动作是 "com.cfk.CUSTOM_BROADCAST"。
- 由于在 Android 8.0 以上要求静态注册的 `BroadcastReceiver` 所接收的消息必须是显式的，我们通过设置包名的方式来告诉系统这个 `Intent` 是要发给哪个应用来接收。不设置的话就会接收不到消息。
- 使用 `putExtra` 可以添加额外的数据到广播中，这里添加了一个字符串消息。
- 最后，通过 `sendBroadcast` 方法将广播发送出去。

这些注释和说明旨在帮助理解代码的功能和每个方法的作用。希望对你有帮助。

**（3）创建广播接收者类：**

在主包下床架`receiver`软件包，并在其下面创建`CustomBroadcastReceiver.java`文件，如下：

```java
package com.cfk.externalbroadcastlearning.receiver;

//CustomBroadcastReceiver 是一个用于接收自定义广播的广播接收者类
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.widget.Toast;

public class CustomBroadcastReceiver extends BroadcastReceiver {

    /**
     * 当接收到广播时，系统将调用此方法
     * 
     * @param context 广播接收者的上下文
     * @param intent  包含广播信息的Intent
     */
    @Override
    public void onReceive(Context context, Intent intent) {
        // 从Intent中获取额外的数据
        String message = intent.getStringExtra("message");

        // 在屏幕上显示Toast消息
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show();
    }
}
```

**说明：**

- `CustomBroadcastReceiver` 是一个广播接收者类，用于接收自定义广播。
- `onReceive` 方法是在接收到广播时系统将调用的方法。
- `context` 参数是广播接收者的上下文，通过它可以访问应用的资源和服务。
- `intent` 参数包含了广播的信息，通过它可以获取传递的额外数据。
- 在本例中，从 `intent` 中获取了名为 "message" 的额外字符串数据。
- 使用 `Toast.makeText` 在屏幕上显示收到的消息。

这些注释和说明旨在帮助理解广播接收者类的作用和处理接收到广播的方法。希望对你有帮助。

**（4）在清单文件（AndroidManifest.xml）中注册活动和广播接收者：**

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- AndroidManifest.xml 文件，用于描述应用的基本信息和组件配置 -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:allowBackup="true" <!-- 允许备份应用数据 -->
        android:dataExtractionRules="@xml/data_extraction_rules" <!-- 指定数据提取规则 -->
        android:fullBackupContent="@xml/backup_rules" <!-- 指定完整备份规则 -->
        android:icon="@mipmap/ic_launcher" <!-- 应用图标 -->
        android:label="@string/app_name" <!-- 应用名称 -->
        android:roundIcon="@mipmap/ic_launcher_round" <!-- 圆形图标 -->
        android:supportsRtl="true" <!-- 支持从右到左的布局 -->
        android:theme="@style/Theme.ExternalBroadcastLearning" <!-- 应用主题 -->
        tools:targetApi="31"> <!-- 使用的目标API级别 -->

        <!-- MainActivity 是应用的主活动 -->
        <activity android:name=".activity.MainActivity"
            android:exported="true"> <!-- 允许其他应用启动此活动 -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN" /> <!-- 主活动的动作 -->
                <category android:name="android.intent.category.LAUNCHER" /> <!-- 设置为启动器 -->
            </intent-filter>
        </activity>

        <!-- CustomBroadcastReceiver 是自定义广播接收者 -->
        <receiver
            android:name=".receiver.CustomBroadcastReceiver"
            android:exported="false"> <!-- 不允许其他应用直接启动此接收者 -->
            <intent-filter>
                <action android:name="com.cfk.CUSTOM_BROADCAST" /> <!-- 自定义广播的动作 -->
            </intent-filter>
        </receiver>
    </application>

</manifest>
```

**说明：**

- `allowBackup`：允许备份应用数据，设置为 `true`。
- `dataExtractionRules`：指定数据提取规则的 XML 文件。
- `fullBackupContent`：指定完整备份规则的 XML 文件。
- `icon`：应用图标，指向 `@mipmap/ic_launcher`。
- `label`：应用名称，引用了字符串资源 `@string/app_name`。
- `roundIcon`：圆形图标，指向 `@mipmap/ic_launcher_round`。
- `supportsRtl`：支持从右到左的布局，设置为 `true`。
- `theme`：应用主题，使用了 `@style/Theme.ExternalBroadcastLearning`。
- `targetApi`：指定使用的目标 API 级别，设置为 31。

对于 `MainActivity`：
- `exported`：允许其他应用启动此活动，设置为 `true`。
- `<intent-filter>`：指定主活动的动作为 `MAIN`，并将其设置为启动器。

对于 `CustomBroadcastReceiver`：
- `exported`：不允许其他应用直接启动此接收者，设置为 `false`。
- `<intent-filter>`：指定自定义广播的动作为 `com.cfk.CUSTOM_BROADCAST`。

**（5）运行测试：**

运行结果截图如下：

![笔记-外部广播运行结果截图.png)](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E5%A4%96%E9%83%A8%E5%B9%BF%E6%92%AD%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%88%AA%E5%9B%BE.png)

由运行结果可知，点击“发送广播”按钮，成功在屏幕显示了Toast消息。

### 8.2.2 内部Broadcast

**1. 定义广播接收器：** 类似于建立一个应用内部的通信频道，我们创建了`MyInternalReceiver`类，同样继承自`BroadcastReceiver`，用于处理接收到的内部广播消息。

```java
public class MyInternalReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 处理接收到的内部广播消息
        String message = intent.getStringExtra("key");
        // 执行相应的操作
    }
}
```

**2. 注册广播接收器：** 使用`LocalBroadcastManager`类注册广播接收器，这就像在应用内部创建了一条专属的通信频道。

```java
MyInternalReceiver receiver = new MyInternalReceiver();
LocalBroadcastManager.getInstance(context).registerReceiver(receiver, new IntentFilter("com.example.INTERNAL_ACTION"));
```

**3. 发送内部广播：** 在需要发送内部广播的地方，创建一个`Intent`并设置相应的动作，然后通过`sendBroadcast()`方法发送内部广播，这就像在应用内部通过专用频道发送消息一样。

```java
Intent intent = new Intent("com.example.INTERNAL_ACTION");
intent.putExtra("key", "Hello, Internal World!");
LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
```

内部广播的优势在于它的隔离性，就像应用内部有一条私密的通信频道，其他应用无法窥探。在需要确保通信安全性和独立性的情况下，内部广播是一个理想的选择。下面结合一个具体的例子来说明内部广播的使用：

**1. `activity_main.xml`**

在`res/layout`目录下创建`activity_main.xml`文件，代码如下：

```xml
<!-- activity_main.xml -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    tools:context=".activity.MainActivity">

    <!-- 发送内部广播的按钮 -->
    <Button
        android:id="@+id/sendButton"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="发送内部广播"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>
</androidx.constraintlayout.widget.ConstraintLayout>
```

此 XML 文件定义了应用的主页面布局。包含一个按钮，用户点击该按钮将触发发送内部广播的操作。

**2. `activity_message.xml`**

在`res/layout`目录下创建`activity_message.xml`文件，代码如下：

```xml
<!-- activity_message.xml -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    tools:context=".activity.MessageActivity">

    <!-- 用于显示接收到的消息的 TextView -->
    <TextView
        android:id="@+id/messageTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="消息占位符"
        android:textSize="24sp" <!-- 设置字体大小为24sp -->
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintVertical_bias="0.5"
        app:layout_constraintHorizontal_bias="0.5"/>
</androidx.constraintlayout.widget.ConstraintLayout>
```

该 XML 文件用于定义显示接收到的消息的页面布局。包含一个 `TextView` 用于显示消息内容，并设置了字体大小为 24sp。

**3. `MessageActivity`**

在主软件包下创建`activity`软件包，并在其下面创建`MessageActivity.java`文件，代码如下：

```java
package com.cfk.internalbroadcastinglearning.activity;

import android.content.Intent;
import android.os.Bundle;
import android.widget.TextView;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

import com.cfk.internalbroadcastinglearning.R;

/**
 * 消息显示页面，用于显示接收到的内部广播消息
 */
public class MessageActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_message);

        // 从Intent中获取消息并显示在TextView上
        Intent intent = getIntent();
        String message = intent.getStringExtra("message");

        TextView messageTextView = findViewById(R.id.messageTextView);
        messageTextView.setText(message);
    }
}
```

`MessageActivity` 是一个 `AppCompatActivity`，用于显示接收到的内部广播消息。在 `onCreate` 方法中，从 `Intent` 中获取消息，并将其显示在 `TextView` 中。

**4. `MyInternalReceiver`**

在主软件包下创建`receiver`软件包，并在其下面创建`MyInternalReceiver.java`文件，代码如下：

```java
package com.cfk.internalbroadcastinglearning.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

import com.cfk.internalbroadcastinglearning.activity.MessageActivity;

/**
 * 广播接收器，用于处理接收到的内部广播消息
 */
public class MyInternalReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 处理接收到的内部广播消息
        String message = intent.getStringExtra("key");
        Log.d("InternalReceiver", "Received message: " + message);

        // 启动显示消息的页面
        Intent displayIntent = new Intent(context, MessageActivity.class);
        displayIntent.putExtra("message", message);
        displayIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(displayIntent);
    }
}
```

`MyInternalReceiver` 是一个广播接收器，用于处理接收到的内部广播消息。在 `onReceive` 方法中，提取消息内容并通过 `Log` 打印，然后启动 `MessageActivity` 以显示消息。

**5. `MainActivity`**

在`activity`软件包下面创建`MainActivity.java`文件，代码如下：

```java
package com.cfk.internalbroadcastinglearning.activity;

import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.cfk.internalbroadcastinglearning.R;
import com.cfk.internalbroadcastinglearning.receiver.MyInternalReceiver;

/**
 * 主页面，负责发送内部广播的Activity
 */
public class MainActivity extends AppCompatActivity {
    private MyInternalReceiver myInternalReceiver;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 创建广播接收器实例
        myInternalReceiver = new MyInternalReceiver();

        // 注册广播接收器，监听 "com.cfk.INTERNAL_ACTION"
        LocalBroadcastManager.getInstance(this).registerReceiver(myInternalReceiver,
                new IntentFilter("com.cfk.INTERNAL_ACTION"));

        // 设置按钮点击事件，发送内部广播
        Button sendButton = findViewById(R.id.sendButton);
        sendButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                sendInternalBroadcast();
            }
        });
    }

    @Override
    protected void onDestroy() {
        // 在Activity销毁时注销广播接收器，防止内存泄漏
        LocalBroadcastManager.getInstance(this).unregisterReceiver(myInternalReceiver);
        super.onDestroy();
    }

    // 发送内部广播的方法
    private void sendInternalBroadcast() {
        Intent intent = new Intent("com.cfk.INTERNAL_ACTION");
        intent.putExtra("key", "Hello，Internal World!");
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    }
}
```

`MainActivity` 是应用的主页面，负责发送内部广播。在 `onCreate` 方法中，注册了 `MyInternalReceiver` 用于接收内部广播，同时设置了按钮的点击事件，点击按钮将触发发送内部广播的操作。

**6. `AndroidManifest.xml`**

在`AndroidManifest.xml`文件下面注册活动和广播接收器，代码如下：

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"


        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.InternalBroadcastingLearning"
        tools:targetApi="31">
        <!-- 注册 MyInternalReceiver 广播接收器 -->
        <receiver
            android:name=".receiver.MyInternalReceiver"
            android:enabled="true"
            android:exported="false">
            <intent-filter>
                <action android:name="com.cfk.INTERNAL_ACTION"/>
            </intent-filter>
        </receiver>

        <!-- 定义主页面 MainActivity -->
        <activity
            android:name=".activity.MainActivity"
            android:label="@string/app_name"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>

        <!-- 定义消息页面 MessageActivity -->
        <activity
            android:name=".activity.MessageActivity"
            android:label="@string/app_name"
            android:parentActivityName=".activity.MainActivity">
            <meta-data
                android:name="android.support.PARENT_ACTIVITY"
                android:value=".activity.MainActivity"/>
        </activity>
    </application>

</manifest>
```

Android 清单文件中注册了 `MyInternalReceiver` 广播接收器，并声明了 `MainActivity` 为应用的主要入口。还定义了 `MessageActivity` 为 `MainActivity` 的子页面。

**7.运行测试**

运行以上的程序，运行结果如下图所示：

![笔记-内部广播使用示例.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E5%86%85%E9%83%A8%E5%B9%BF%E6%92%AD%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.png)

由运行结果可知，点击“发送内部广播按钮”后，成功跳转到消息显示的页面，且成功在日志输出窗口输出相应的消息内容。

这些组件协同工作，实现了在主页面点击按钮发送内部广播，然后通过广播接收器处理并启动消息显示页面的功能。整个流程通过清晰的注释和说明使得代码易于理解。

## 8.3 Broadcast使用的注意事项

在Android开发中，广播（Broadcast）是一种用于在应用内或应用之间传递消息的机制。以下是一些在使用广播时需要注意的事项：

1. **敏感权限：** 广播是一种系统级别的通信方式，某些广播可能包含敏感信息。确保只有有权限的应用可以接收到你发送的广播，以防止信息泄露和安全问题。

2. **显式和隐式广播：** 显式广播是直接指定接收者的，而隐式广播是通过Intent的Action进行匹配。尽量使用显式广播，因为隐式广播可能会被其他应用误接收，导致安全问题或不确定的行为。

3. **有序广播：** Android中的广播可以是有序的，即按照优先级顺序一个接一个地传递给接收器。在有序广播中，确保广播接收器的顺序和优先级是按照需求设计的，以保证正确的处理顺序。

4. **不要滥用广播：** 避免频繁发送广播，因为它可能对系统性能产生影响。特别是对于全局性广播，要慎重使用，确保只有在必要的情况下才发送。

5. **耗时操作：** 不要在广播接收器中执行长时间运行的操作，因为广播接收器是在主线程中运行的，可能导致ANR（Application Not Responding）错误。如果有需要执行耗时操作，考虑使用服务或异步任务。

6. **注册和注销：** 在适当的生命周期中注册和注销广播接收器，以避免内存泄漏。通常，在`onCreate`中注册广播接收器，在`onDestroy`中注销。

7. **本地广播 vs 全局广播：** 对于应用内部的通信，使用本地广播（LocalBroadcastManager）而不是全局广播。本地广播只在应用内传递，更加安全高效。

8. **兼容性考虑：** 考虑Android版本的兼容性，因为某些广播的行为可能在不同的Android版本中有所不同。

总体而言，使用广播时需要注意安全性、性能和可维护性等方面的问题，确保广播的使用符合最佳实践和Android平台的设计原则。

# 9 SharedPreferences

**定义：**

SharedPreferences（共享偏好设置）是Android开发中用于存储小量数据的一种机制。它提供了一个简单的键值对存储系统，用于保存应用程序的配置信息、用户偏好设置等。SharedPreferences是基于XML文件存储的，每个文件都包含一组键值对，可以轻松地读取和写入。

**背景与意义：**

在Android应用开发中，为了有效管理应用程序的配置信息、用户偏好设置等轻量级数据，开发者常常使用SharedPreferences机制。SharedPreferences提供了一种简单的键值对存储系统，基于XML文件，用于存储小量数据。这种机制的背景在于满足应用程序对于快速访问、轻量级数据存储的需求，同时提供了一种易于使用的方式。

其意义在于：

1. **轻量级数据存储：** SharedPreferences适用于存储小量的键值对数据，为应用程序提供了一种不需要引入复杂数据库或文件系统的轻量级数据存储方案。
2. **简便易用：** 使用SharedPreferences非常简单，开发者只需调用少量API来读取或写入数据，无需处理繁琐的数据库查询或文件读写操作。
3. **快速访问：** 基于XML文件的存储方式使得对小量数据的读取和写入操作速度较快，适用于需要迅速访问配置信息的场景。
4. **数据共享：** SharedPreferences是在应用内部的不同组件之间共享数据的一种方式。例如，一个Activity可以将用户设置存储在SharedPreferences中，然后其他组件，如Service或BroadcastReceiver，可以轻松地检索并使用这些设置。

综合而言，SharedPreferences在Android开发中扮演着满足轻量级数据存储需求、简化数据管理的角色，为开发者提供了一种方便而高效的方式来处理应用程序的配置信息和用户偏好设置。

**其它介绍与使用方法如下。**

## 9.1 SharedPreferences的使用

在安卓开发中，SharedPreferences是一种用于存储轻量级键值对数据的工具，通常用于保存应用程序的配置信息、用户首选项等。下面是一个详细的说明，演示了如何在Android应用中使用SharedPreferences： 

**步骤1：获取SharedPreferences实例**

首先，确保你理解了`SharedPreferences`的概念。`SharedPreferences`是Android平台上的一个轻量级存储机制，用于保存简单的键值对数据，常用于存储应用程序的配置信息和用户首选项。

```java
// 获取SharedPreferences实例，参数分别是文件名和操作模式
SharedPreferences sharedPreferences = context.getSharedPreferences("MyPrefs", Context.MODE_PRIVATE);
```

- **文件名：** `"MyPrefs"` 是用于标识SharedPreferences文件的名称。这个文件将存储你的应用程序的相关数据。确保为不同的用途使用不同的文件名。
  
- **操作模式：** `Context.MODE_PRIVATE` 表示这个SharedPreferences文件只能被当前应用程序访问。这意味着其他应用无法直接读取或修改这个文件。

**步骤2：写入数据到SharedPreferences**

使用`SharedPreferences.Editor`来存储数据，确保在应用更改之前使用`apply()`方法。

```java
// 获取SharedPreferences.Editor实例
SharedPreferences.Editor editor = sharedPreferences.edit();

// 存储数据
editor.putString("username", "JohnDoe");
editor.putInt("score", 100);
editor.putBoolean("loggedIn", true);

// 应用更改
editor.apply();
```

- **Editor对象：** `SharedPreferences.Editor`对象用于进行数据修改操作。注意，它是用于批量修改数据的，而不是实际的数据存储。

- **键值对：** 使用不同的方法根据数据类型存储键值对。在上述例子中，我们存储了一个字符串、一个整数和一个布尔值。

**步骤3：从SharedPreferences中读取数据**

通过使用相应的方法，你可以从SharedPreferences中读取保存的数据。

```java
// 从SharedPreferences中读取数据
String username = sharedPreferences.getString("username", "");
int score = sharedPreferences.getInt("score", 0);
boolean loggedIn = sharedPreferences.getBoolean("loggedIn", false);

// 打印读取到的数据
Log.d("SharedPreferences", "Username: " + username);
Log.d("SharedPreferences", "Score: " + score);
Log.d("SharedPreferences", "Logged In: " + loggedIn);
```

- **默认值：** 在读取数据时，提供默认值是一个好习惯，以防止找不到对应键的情况。

- **Log输出：** 使用`Log`类输出读取到的数据，以便在调试时能够轻松查看这些值。

**最佳实践和注意事项**

1. **线程安全：** `apply()`方法是异步的，如果你需要同步的写入操作，可以使用`commit()`方法，但要注意可能的性能影响。
2. **清理数据：** 及时清理不再需要的数据，以防SharedPreferences文件变得庞大。
3. **监听变化：** 如果你需要在数据发生变化时得到通知，可以考虑使用`SharedPreferences.OnSharedPreferenceChangeListener`。
4. **不适用场景：** 对于大量或复杂的数据，以及需要复杂查询的情况，考虑使用数据库或其他更适合的持久化方案。
5. **数据加密：** 对于敏感数据，考虑使用加密算法进行存储，以提高安全性。

下面我们通过一个具体的例子来讲解SharedPrefence的使用，如下：

好的，我将以步骤的形式详细展示这个例子，包括文字说明和详细的注释。

**步骤1：创建布局文件**

在 `res/layout/activity_main.xml` 中创建用户界面的布局文件，代码如下：

```xml
<!-- 布局文件: activity_main.xml -->

<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".activity.MainActivity">

    <!-- 输入用户名的 EditText -->
    <EditText
        android:id="@+id/editTextUsername"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="32dp"
        android:hint="Enter username"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <!-- 保存按钮 -->
    <Button
        android:id="@+id/buttonSave"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:text="Save"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/editTextUsername" />

    <!-- 显示保存结果的 TextView -->
    <TextView
        android:id="@+id/textViewResult"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:text=""
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/buttonSave" />

</androidx.constraintlayout.widget.ConstraintLayout>
```

这个布局文件使用 `ConstraintLayout`，包含一个 `EditText` 用于输入用户名，一个 `Button` 用于保存，以及一个 `TextView` 用于显示保存的结果。

**步骤2：创建主活动**

在 `src/com/cfk/sharedpreferencesstudy/activity/MainActivity.java` 中创建主活动，代码如下：

```java
package com.cfk.sharedpreferencesstudy.activity;

import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

import com.cfk.sharedpreferencesstudy.R;

/**
 * 主活动：用于演示SharedPreferences的使用
 */
public class MainActivity extends AppCompatActivity {
    // 声明控件
    private EditText editTextUsername;
    private Button buttonSave;
    private TextView textViewResult;
    private SharedPreferences sharedPreferences;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 设置活动的布局文件
        setContentView(R.layout.activity_main);

        // 初始化控件
        editTextUsername = findViewById(R.id.editTextUsername);
        buttonSave = findViewById(R.id.buttonSave);
        textViewResult = findViewById(R.id.textViewResult);

        // 获取SharedPreferences实例（使用默认的MODE_PRIVATE模式）
        sharedPreferences = getPreferences(MODE_PRIVATE);

        // 从SharedPreferences中读取数据并显示在textViewResult中
        String savedUsername = sharedPreferences.getString("username", "");
        textViewResult.setText("Saved Username: " + savedUsername);

        // 设置保存按钮的点击事件
        buttonSave.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                // 获取输入的用户名
                String username = editTextUsername.getText().toString();

                // 保存用户名到SharedPreferences
                SharedPreferences.Editor editor = sharedPreferences.edit();
                editor.putString("username", username);
                editor.apply();

                // 显示保存成功的消息
                textViewResult.setText("Username saved: " + username);
            }
        });
    }
}
```

这个活动包含了初始化控件、获取SharedPreferences实例、从SharedPreferences中读取数据并显示、设置保存按钮点击事件等步骤。

**步骤3：配置 AndroidManifest.xml**

在 `AndroidManifest.xml` 中配置主活动，代码如下：

```xml
<!-- AndroidManifest.xml 文件 -->

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:allowBackup="true" <!-- 允许备份应用数据 -->
        android:dataExtractionRules="@xml/data_extraction_rules" <!-- 指定数据提取规则 -->
        android:fullBackupContent="@xml/backup_rules" <!-- 指定完整备份规则 -->
        android:icon="@mipmap/ic_launcher" <!-- 应用图标 -->
        android:label="@string/app_name" <!-- 应用标签 -->
        android:roundIcon="@mipmap/ic_launcher_round" <!-- 圆形应用图标 -->
        android:supportsRtl="true" <!-- 支持RTL（Right-To-Left）布局 -->
        android:theme="@style/Theme.SharedPreferencesStudy" <!-- 应用主题 -->
        tools:targetApi="31"> <!-- 指定目标API版本 -->

        <!-- 活动配置 -->
        <activity android:name=".activity.MainActivity" <!-- 主活动的类名 -->
            android:exported="true"> <!-- 允许其他应用调用此活动 -->
            
            <!-- 意图过滤器，定义了应用程序入口 -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/> <!-- 主入口动作 -->
                <category android:name="android.intent.category.LAUNCHER"/> <!-- 主入口类别 -->
            </intent-filter>
        </activity>
    </application>

</manifest>
```

这个步骤配置了主活动，使应用程序在启动时打开 `MainActivity`。

**步骤4：运行测试**

启动该应用程序，运行结果截图如下：

![笔记-SharedPreferences的使用示例运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-SharedPreferences%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

由运行结果可以看出当点击SAVE按钮后成功在按钮下面显示了相应的应户名

## 9.2 SharedPreferences数据共享

在Android开发中，`SharedPreferences`是一种用于在应用程序中存储小量键值对数据的轻量级机制。它通常用于保存应用程序的配置信息、用户首选项等。以下讲解如何进行SharedPreferences数据共享的步骤：

1. **创建一个工具类**：

   首先，创建一个专门用于处理`SharedPreferences`的工具类，例如`PreferenceManager`或`SharedPreferencesUtil`：

   ```java
   import android.content.Context;
   import android.content.SharedPreferences;

   public class PreferenceManager {
       private static final String PREFERENCE_NAME = "my_preferences";

       private static SharedPreferences getSharedPreferences(Context context) {
           return context.getSharedPreferences(PREFERENCE_NAME, Context.MODE_PRIVATE);
       }

       public static void saveUsername(Context context, String username) {
           SharedPreferences.Editor editor = getSharedPreferences(context).edit();
           editor.putString("username", username);
           editor.apply();
       }

       public static String getUsername(Context context) {
           return getSharedPreferences(context).getString("username", "");
       }

       // 添加其他需要保存和读取的数据方法...
   }
   ```

2. **在不同组件中使用**：

   在不同的`Activity`或其他组件中，通过调用`PreferenceManager`的方法来共享和获取数据：

   ```java
   // 在某个Activity中保存用户名
   PreferenceManager.saveUsername(this, "JohnDoe");
   
   // 在另一个Activity中获取用户名
   String username = PreferenceManager.getUsername(this);
   ```

   这样，你就可以在应用的不同组件中共享相同的`SharedPreferences`数据了。这是一种比直接使用`getSharedPreferences`更模块化和可维护的方式。

下面我们还是结合上面用户名的例子，来介绍如何使用SharedPreferences进行数据共享，如下：

1. **SharedPreferencesUtil.java**

   在 `src/com/cfk/sharedpreferencesdatasharingstudy/util/SharedPreferencesUtil.java` 中创建专门用于处理`SharedPreferences`的工具类`SharedPreferencesUtil`，代码如下：

```java
/**
 * SharedPreferencesUtil.java
 *
 * 该实用工具类提供了与 SharedPreferences 交互以保存和检索用户名的方法。
 * SharedPreferences 是 Android 中存储轻量级数据的一种机制，以键值对的形式存储。
 * 该类定义了两个方法：saveUsername(Context, String) 用于保存用户名，getUsername(Context) 用于检索保存的用户名。
 */
package com.cfk.sharedpreferencesdatasharingstudy.util;

import android.content.Context;
import android.content.SharedPreferences;

public class SharedPreferencesUtil {
    // SharedPreferences 文件名和保存用户名的键
    private static final String PREFERENCES_NAME = "MyPrefs";
    private static final String KEY_USERNAME = "username";

    /**
     * 将给定的用户名保存到 SharedPreferences。
     *
     * @param context 用于获取 SharedPreferences 实例的上下文。
     * @param username 要保存的用户名。
     */
    public static void saveUsername(Context context, String username) {
        // 获取 SharedPreferences 实例
        SharedPreferences preferences = context.getSharedPreferences(PREFERENCES_NAME, Context.MODE_PRIVATE);

        // 获取 SharedPreferences 编辑器
        SharedPreferences.Editor editor = preferences.edit();

        // 存储用户名
        editor.putString(KEY_USERNAME, username);

        // 应用修改
        editor.apply();
    }

    /**
     * 从 SharedPreferences 中检索保存的用户名。
     *
     * @param context 用于获取 SharedPreferences 实例的上下文。
     * @return 保存的用户名。如果没有可用的用户名，则返回空字符串。
     */
    public static String getUsername(Context context) {
        // 获取 SharedPreferences 实例
        SharedPreferences preferences = context.getSharedPreferences(PREFERENCES_NAME, Context.MODE_PRIVATE);

        // 读取用户名，默认值为空字符串
        return preferences.getString(KEY_USERNAME, "");
    }
}
```

这个工具类负责与 `SharedPreferences` 打交道，提供了保存和获取用户名的方法。其中，`saveUsername` 方法用于将用户名保存到 `SharedPreferences` 中，而 `getUsername` 方法用于从 `SharedPreferences` 中获取保存的用户名。

2. **activity_main.xml**

   在 `res/layout/activity_main.xml` 中创建用户界面的布局文件，代码如下：

```xml
<!-- activity_main.xml -->
<!--
    布局文件：activity_main.xml
    
    这个布局文件定义了应用主界面的外观，包含了一个用于输入用户名的 EditText、一个保存按钮 Button，
    以及用于显示结果的 TextView。这个布局使用了 ConstraintLayout，一种强大的布局方式。
-->

<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- 用于输入用户名的 EditText -->
    <EditText
        android:id="@+id/editTextUsername"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="32dp"
        android:hint="Enter username"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <!-- 保存按钮 Button -->
    <Button
        android:id="@+id/buttonSave"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:text="Save"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/editTextUsername" />

    <!-- 用于显示结果的 TextView -->
    <TextView
        android:id="@+id/textViewResult"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:text=""
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/buttonSave" />

</androidx.constraintlayout.widget.ConstraintLayout>
```

这个布局文件定义了应用主界面的外观，包含一个用于输入用户名的 `EditText`、一个保存按钮 `Button`，以及用于显示结果的 `TextView`。

3. **DisplayDataActivity.java**

   在 `src/com/cfk/sharedpreferencesdatasharingstudy/activity/DisplayDataActivity.java` 中创建主活动，代码如下：

```java
// DisplayDataActivity.java
package com.cfk.sharedpreferencesdatasharingstudy.activity;

import android.os.Bundle;
import android.widget.Button;
import android.widget.TextView;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

import com.cfk.sharedpreferencesdatasharingstudy.R;
import com.cfk.sharedpreferencesdatasharingstudy.util.SharedPreferencesUtil;

/**
 * DisplayDataActivity是一个用于显示数据的Activity。
 * 它从SharedPreferences中读取用户名并在界面上显示。
 */
public class DisplayDataActivity extends AppCompatActivity {
    private TextView textViewResult;
    private Button buttonSave;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_display_data);

        // 获取界面上的TextView和Button
        textViewResult = findViewById(R.id.textViewResult);
        buttonSave = findViewById(R.id.buttonSave);

        // 禁用Save按钮
        buttonSave.setEnabled(false);

        // 在每次显示时从SharedPreferences中读取用户名
        String savedUsername = SharedPreferencesUtil.getUsername(this);

        // 显示读取的用户名
        textViewResult.setText("Saved Username: " + savedUsername);
    }
}
```

`DisplayDataActivity` 是一个用于显示数据的 `Activity`。它从 `SharedPreferences` 中读取用户名并在界面上显示。

4. **MainActivity.java**

   在 `src/com/cfk/sharedpreferencesdatasharingstudy/activity/MainActivity.java` 中创建主活动，代码如下：

```java
// MainActivity.java
/*
    MainActivity 是应用的主 Activity，负责处理用户输入并保存到 SharedPreferences 中。
    该类包含了初始化界面控件、设置保存按钮点击事件等功能。
*/

package com.cfk.sharedpreferencesdatasharingstudy.activity;

import android.content.Intent;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

import com.cfk.sharedpreferencesdatasharingstudy.R;
import com.cfk.sharedpreferencesdatasharingstudy.util.SharedPreferencesUtil;

public class MainActivity extends AppCompatActivity {
    // 声明界面上的 EditText 和 Button
    private EditText editTextUsername;
    private Button buttonSave;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 设置活动的布局文件
        setContentView(R.layout.activity_main);

        // 初始化界面上的 EditText 和 Button
        editTextUsername = findViewById(R.id.editTextUsername);
        buttonSave = findViewById(R.id.buttonSave);

        // 设置保存按钮的点击事件
        buttonSave.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                // 获取用户输入的用户名
                String username = editTextUsername.getText().toString();

                // 检查用户名是否为空
                if (!TextUtils.isEmpty(username)) {
                    // 保存用户名到 SharedPreferences
                    SharedPreferencesUtil.saveUsername(MainActivity.this, username);

                    // 启动显示数据的 Activity
                    startActivity(new Intent(MainActivity.this, DisplayDataActivity.class));
                } else {
                    // 提示用户输入有效的用户名
                    Toast.makeText(MainActivity.this, "Please enter a valid username", Toast.LENGTH_SHORT).show();
                }
            }
        });
    }
}
```

`MainActivity` 是应用的主 `Activity`，包含一个用于输入用户名的 `EditText`、保存按钮 `Button`。

5. **AndroidManifest.xml**

   5. 在 `AndroidManifest.xml` 中配置两个活动，代码如下：

   ```xml
   <!-- AndroidManifest.xml -->
   <!-- AndroidManifest.xml定义了应用的清单文件，包含了MainActivity和DisplayDataActivity的声明。 -->
   <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:tools="http://schemas.android.com/tools">
   
       <application
           android:allowBackup="true"
           android:dataExtractionRules="@xml/data_extraction_rules"
           android:fullBackupContent="@xml/backup_rules"
           android:icon="@mipmap/ic_launcher"
           android:label="@string/app_name"
           android:roundIcon="@mipmap/ic_launcher_round"
           android:supportsRtl="true"
           android:theme="@style/Theme.SharedPreferencesDataSharingStudy"
           tools:targetApi="31">
   
           <!-- 声明MainActivity为应用的主Activity -->
           <activity
               android:name=".activity.MainActivity"
               android:exported="true">
               <intent-filter>
                   <action android:name="android.intent.action.MAIN" />
                   <category android:name="android.intent.category.LAUNCHER" />
               </intent-filter>
           </activity>
   
           <!-- 声明DisplayDataActivity -->
           <activity
               android:name=".activity.DisplayDataActivity"
               android:exported="true">
               <intent-filter>
                   <action android:name="android.intent.action.MAIN" />
                   <category android:name="android.intent.category.LAUNCHER" />
               </intent-filter>
           </activity>
   
       </application>
   
   </manifest>
   ```

   `AndroidManifest.xml` 定义了应用的清单文件，包含了 `MainActivity` 和 `DisplayDataActivity` 的声明。在 `application` 元素下，声明了两个活动，其中 `MainActivity` 被设置为主活动。这确保应用在启动时会打开 `MainActivity`。

6. **运行测试**

   运行以上程序，运行结果截图如下：

   ![笔记-SharedPreferences数据共享示例运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-SharedPreferences%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

# 10 ContentProvider

**定义**：

- ContentProvider是Android平台上的一个组件，用于提供标准化的接口，以管理和共享应用程序的数据。
- 通过ContentProvider，应用程序可以以统一的方式访问和操作数据，而无需了解底层数据的存储和结构。

**背景与意义**：

在分布式的Android应用程序体系结构中，不同应用程序可能需要访问和共享数据。由于每个应用程序运行在独立的进程中，直接访问其他应用程序的数据存在安全性和隐私问题。ContentProvider的引入解决了这些挑战，具有以下背景和意义：

1. **数据共享与访问标准化**：ContentProvider提供了一种标准的、统一的数据访问接口。通过URI标识数据，不同应用程序可以以相同的方式查询、插入、更新和删除数据。这种标准化促进了应用程序之间的数据共享。
2. **抽象数据访问细节**：ContentProvider将数据访问的细节进行了抽象，使得开发者能够通过ContentResolver类访问数据，而无需关心底层数据存储的实现细节。这种抽象提高了代码的可维护性和可扩展性。
3. **权限控制**：通过ContentProvider，应用程序可以选择性地对外提供访问权限。只有被授予相应权限的应用程序才能访问数据，确保了数据的安全性和隐私保护。
4. **数据安全与隔离**：ContentProvider帮助确保数据在应用程序之间的安全共享。每个应用程序都有其自己的数据存储空间，通过ContentProvider提供的接口，其他应用程序只能通过授权的方式访问这些数据，从而保持了数据的隔离性和安全性。

综合而言，ContentProvider在Android开发中的背景是为了解决应用程序之间的数据共享和访问标准化的问题。其意义在于提供了一种安全、统一、抽象的数据访问方式，同时允许开发者控制数据的访问权限，确保了系统的安全性和可维护性。

详细介绍以及使用方式如下所示。

## 10.1 ContentProvider进程之间的通信

ContentProvider主要用于在Android应用程序的不同进程之间共享和访问数据。其通信过程涉及到URI（Uniform Resource Identifier）、ContentResolver、Binder机制以及权限控制等关键概念。

以下是ContentProvider进程之间通信的详细过程：

1. **ContentProvider的暴露**：
   - 一个应用程序的ContentProvider首先需要在清单文件中注册，并在`AndroidManifest.xml`中声明相应的权限（如果需要限制访问）。
   - ContentProvider类会被实现，并定义一系列标准的URI，用于标识不同的数据集合和操作。

2. **URI的使用**：
   - 在客户端应用程序中，通过ContentResolver获取ContentProvider的引用。ContentResolver是一个系统级服务，负责管理不同应用程序之间的数据访问。
   - 客户端通过URI标识要访问的数据，例如 `content://com.example.provider/data_table`。

3. **Binder机制**：
   - 通信过程利用Android中的Binder机制。ContentProvider运行在自己的进程中，而客户端应用程序运行在另一个进程中。
   - Binder是一种IPC（Inter-Process Communication）机制，用于在不同进程之间传递数据和调用方法。

4. **查询操作**：
   - 客户端通过ContentResolver的`query`方法发起查询请求，传递URI和其他查询参数。
   - ContentResolver通过Binder将请求传递给ContentProvider。

5. **ContentProvider的处理**：
   - ContentProvider接收到查询请求后，根据URI和参数执行相应的数据查询操作。
   - 查询结果被封装成Cursor对象，并通过Binder机制传递给客户端。

6. **返回结果**：
   - 客户端通过ContentResolver获取到Cursor对象，从中读取数据。

7. **更新、插入和删除操作**：
   - 类似于查询操作，客户端可以通过ContentResolver的`insert`、`update`和`delete`方法发起数据更新、插入和删除操作。

8. **权限控制**：
   - ContentProvider可以在其`onCreate`方法中进行权限验证，确保只有授权的应用程序能够访问特定的数据。
   - 如果权限验证失败，ContentProvider可以拒绝服务并抛出SecurityException。

总体而言，ContentProvider的通信过程涉及URI标识数据、ContentResolver作为中介、Binder机制进行跨进程通信，以及权限控制确保数据的安全性。这种机制使得不同应用程序之间可以安全、可靠地共享和访问数据。

## 10.2 ContentProvider的使用

使用ContentProvider在Android应用程序中共享和访问数据涉及到以下几个关键步骤。在这里，我们以一个简单的例子为基础，说明如何创建和使用ContentProvider。假设我们有一个简单的应用，用于管理联系人信息。

1. **定义ContentProvider**：
   
   - 创建一个类，继承自`ContentProvider`。
   - 实现`onCreate`、`query`、`insert`、`update`和`delete`等方法，以处理对数据的不同操作。
   - 在清单文件中注册ContentProvider，并声明相应的权限。
   
   ```java
   public class MyContentProvider extends ContentProvider {
       // 实现必要的方法
       // ...
   }
   ```
   
2. **定义数据模型**：
   - 定义数据表结构，包括表名、列名等信息。
   - 创建SQLite数据库帮助类，用于管理数据库的创建和版本更新。

   ```java
   public class DBHelper extends SQLiteOpenHelper {
       // 定义数据表结构
       // ...
   }
   ```

3. **在ContentProvider中实现数据操作方法**：
   - 在`MyContentProvider`中实现`onCreate`、`query`、`insert`、`update`和`delete`等方法，以提供对数据的操作接口。

   ```java
   public class MyContentProvider extends ContentProvider {
       // 实现数据操作方法
       // ...
   }
   ```

4. **在清单文件中注册ContentProvider**：
   - 在`AndroidManifest.xml`中注册ContentProvider，并指定相应的权限。

   ```xml
   <provider
       android:name=".MyContentProvider"
       android:authorities="com.example.myapp.provider"
       android:exported="true" />
   ```

5. **使用ContentResolver访问ContentProvider**：
   - 在应用程序中使用`ContentResolver`来访问ContentProvider提供的数据操作接口。
   - 构建URI来标识要操作的数据，调用相应的方法执行操作。

   ```java
   // 构建URI
   Uri uri = Uri.parse("content://com.example.myapp.provider/contact");
   
   // 使用ContentResolver进行查询
   Cursor cursor = getContentResolver().query(uri, null, null, null, null);
   
   // 处理查询结果
   // ...
   ```

6. **处理查询结果**：
   - 通过`Cursor`对象处理从ContentProvider返回的查询结果，获取需要的数据。

   ```java
   // 处理查询结果
   if (cursor != null && cursor.moveToFirst()) {
       do {
           // 从Cursor中获取数据
           // ...
       } while (cursor.moveToNext());
       cursor.close();
   }
   ```

7. **进行其他操作**：
   - 类似地，使用`ContentResolver`执行插入、更新和删除等操作。

   ```java
   // 构建URI
   Uri uri = Uri.parse("content://com.example.myapp.provider/contact");
   
   // 设置数据
   ContentValues values = new ContentValues();
   
   // 插入数据
   getContentResolver().insert(uri, values);
   
   // 更新数据
   getContentResolver().update(uri, values, "id=?", new String[]{"1"});
   
   // 删除数据
   getContentResolver().delete(uri, "id=?", new String[]{"1"});
   ```

通过以上步骤，你就能够在Android应用程序中使用ContentProvider来管理和共享数据。这个例子是一个简化版本，实际应用中可能需要更复杂的数据模型和操作。 ContentProvider的强大之处在于它提供了一种标准化的数据访问接口，允许多个应用程序以一种安全、统一的方式访问和共享数据。

下面通过一个例子来说明ContentProvider的使用，如下：

**步骤1：创建 ContactContract 类**

- **路径：** `com.cfk.contentproviderstudy.data`
- **文件名：** `ContactContract.java`

```java
package com.cfk.contentproviderstudy.data;

import android.net.Uri;
import android.provider.BaseColumns;

/**
 * 契约类，定义 ContentProvider 使用的 URI 和数据表结构
 * 
 * 包含联系人相关的信息，如授权信息、基本 URI、路径、表名以及列名等。
 * 通过在 ContactEntry 类中实现 BaseColumns 接口，定义了数据表的基本元素，
 * 如 _ID、表名、列名，并构建了联系人的具体 URI。
 * 
 * @author B_T_D-btd_
 * @version 0.0.1
 * @Date 2023/12/27 11:16
 * @E-Mail cui.fk@neusoft.com
 */
public final class ContactContract {
    
    // 防止被实例化
    private ContactContract(){}

    // ContentProvider 的授权信息
    public static final String AUTHORITY = "com.cfk.contentproviderstudy.provider";
    
    // 构建 ContentProvider 使用的基本 URI
    public static final Uri BASE_CONTENT_URI = Uri.parse("content://" + AUTHORITY);

    // 在基本 URI 后追加路径形成具体的数据集合 URI
    public static final String PATH_CONTACTS = "contacts";

    // 定义联系人数据表的列名和 ContactProvider 使用的 URI
    public static final class ContactEntry implements BaseColumns {

        // 构建具体的联系人 URI
        public static final Uri CONTENT_URI = Uri.withAppendedPath(BASE_CONTENT_URI, PATH_CONTACTS);

        // 数据表的名称
        public static final String TABLE_NAME = "contacts";

        // 联系人姓名列
        public static final String COLUMN_NAME = "name";

        // 联系人电话列
        public static final String COLUMN_PHONE = "phone";
    }
}
```

**说明：**

- `ContactContract` 类是一个契约类，用于定义 ContentProvider 使用的 URI 和数据表结构。
- `AUTHORITY` 定义了 ContentProvider 的授权信息，通常是包名 + ".provider"。
- `BASE_CONTENT_URI` 是 ContentProvider 使用的基本 URI，用于构建具体的数据集合 URI。
- `PATH_CONTACTS` 是在基本 URI 后追加的路径，形成具体的数据集合 URI。
- `ContactEntry` 类实现了 `BaseColumns` 接口，包含了数据表的基本元素，如 `_ID`、表名、列名。
- `CONTENT_URI` 是具体的联系人 URI，通过追加路径形成，指向整个联系人集合。
- 定义了联系人数据表的表名 `TABLE_NAME`，以及联系人姓名和电话的列名。

**步骤2：创建 ContactDBHelper 类**

- **路径：** `com.cfk.contentproviderstudy.data`
- **文件名：** `ContactDBHelper.java`

```java
// ContactDBHelper.java

package com.cfk.contentproviderstudy.data;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

import androidx.annotation.Nullable;

/**
 * ContactDBHelper类是SQLiteOpenHelper的子类，用于管理联系人数据库的创建和版本控制。
 */
public class ContactDBHelper extends SQLiteOpenHelper {

    // 数据库名称
    public static final String DATABASE_NAME = "contact.db";
    // 数据库版本
    public static final int DATABASE_VERSION = 1;

    /**
     * ContactDBHelper的构造函数。
     *
     * @param context 上下文
     */
    public ContactDBHelper(@Nullable Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    /**
     * 在数据库首次创建时调用，用于执行创建表的 SQL 语句。
     *
     * @param sqLiteDatabase 数据库实例
     */
    @Override
    public void onCreate(SQLiteDatabase sqLiteDatabase) {
        // 创建联系人数据表的 SQL 语句
        final String SQL_CREATE_CONTACTS_TABLE = "CREATE TABLE " +
                ContactContract.ContactEntry.TABLE_NAME + " (" +
                ContactContract.ContactEntry._ID + " INTEGER PRIMARY KEY AUTOINCREMENT," +
                ContactContract.ContactEntry.COLUMN_NAME + " TEXT NOT NULL, " +
                ContactContract.ContactEntry.COLUMN_PHONE + " TEXT NOT NULL);";

        // 执行创建表的 SQL 语句
        sqLiteDatabase.execSQL(SQL_CREATE_CONTACTS_TABLE);
    }

    /**
     * 在数据库版本升级时调用，用于执行升级操作。
     *
     * @param sqLiteDatabase 数据库实例
     * @param oldVersion     旧版本号
     * @param newVersion     新版本号
     */
    @Override
    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
        // 在版本升级时执行的操作，这里是删除旧表，重新创建新表
        sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + ContactContract.ContactEntry.TABLE_NAME);
        onCreate(sqLiteDatabase);
    }
}
```

**说明：**

- 数据库帮助类，用于创建和管理联系人数据表。
- 在 `onCreate` 方法中，执行 SQL 语句创建联系人数据表。
- 在 `onUpgrade` 方法中，处理版本升级时的逻辑，删除旧表并重新创建新表。

**步骤3：创建 ContactProvider 类**

- **路径：** `com.cfk.contentproviderstudy.data`
- **文件名：** `ContactProvider.java`

```java
// ContactProvider.java

package com.cfk.contentproviderstudy.data;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.net.Uri;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

/**
 * ContactProvider是一个ContentProvider，用于提供联系人数据的增删改查功能。
 * 它通过实现ContentProvider的各个方法，与其他应用共享数据。
 */
public class ContactProvider extends ContentProvider {

    // URI匹配码
    private static final int CONTACTS = 100;
    private static final int CONTACT_ID = 101;

    private ContactDBHelper dbHelper;
    private UriMatcher uriMatcher;

    @Override
    public boolean onCreate() {
        // 在ContentProvider创建时初始化数据库帮助类和URI匹配器
        dbHelper = new ContactDBHelper(getContext());

        // 设置UriMatcher来匹配URI
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI(ContactContract.AUTHORITY, ContactContract.PATH_CONTACTS, CONTACTS);
        uriMatcher.addURI(ContactContract.AUTHORITY, ContactContract.PATH_CONTACTS + "/#", CONTACT_ID);

        return true;
    }

    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @NonNull String[] projection, @NonNull String selection, @NonNull String[] selectionArgs, @NonNull String sortOrder) {
        // 获取数据库读取实例
        SQLiteDatabase db = dbHelper.getReadableDatabase();

        // 根据传入的URI匹配相应的操作
        int match = uriMatcher.match(uri);
        Cursor cursor;

        switch (match) {
            case CONTACTS:
                // 查询整个联系人表
                cursor = db.query(ContactContract.ContactEntry.TABLE_NAME,
                        projection,
                        selection,
                        selectionArgs,
                        null,
                        null,
                        sortOrder);
                break;
            case CONTACT_ID:
                // 查询单个联系人
                selection = ContactContract.ContactEntry._ID + "=?";
                selectionArgs = new String[]{String.valueOf(ContentUris.parseId(uri))};
                cursor = db.query(ContactContract.ContactEntry.TABLE_NAME,
                        projection,
                        selection,
                        selectionArgs,
                        null,
                        null, sortOrder);
                break;
            default:
                throw new IllegalArgumentException("Unknown URI：" + uri);
        }

        // 设置通知监听，当数据变化时通知相关观察者
        cursor.setNotificationUri(getContext().getContentResolver(), uri);

        return cursor;
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        // 返回MIME类型，暂时不实现
        throw new UnsupportedOperationException("Not yet implemented");
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues contentValues) {
        // 获取数据库写入实例
        SQLiteDatabase db = dbHelper.getWritableDatabase();

        // 根据传入的URI匹配相应的操作
        int match = uriMatcher.match(uri);

        Uri returnUri;

        switch (match) {
            case CONTACTS:
                // 插入数据到联系人表
                long id = db.insert(ContactContract.ContactEntry.TABLE_NAME, null, contentValues);
                if (id > 0) {
                    returnUri = ContentUris.withAppendedId(ContactContract.ContactEntry.CONTENT_URI, id);
                } else {
                    throw new SQLException("Failed to insert row into" + uri);
                }
                break;
            default:
                throw new IllegalArgumentException("Unknown URI: " + uri);
        }

        // 通知观察者数据变化
        getContext().getContentResolver().notifyChange(uri, null);

        return returnUri;
    }

    @Override
    public int delete(@NonNull Uri uri, @NonNull String selection, @NonNull String[] selectionArgs) {
        // 获取数据库写入实例
        SQLiteDatabase db = dbHelper.getWritableDatabase();

        // 根据传入的URI匹配相应的操作
        int match = uriMatcher.match(uri);
        int rowsDeleted;

        switch (match) {
            case CONTACTS:
                // 删除联系人表中的数据
                rowsDeleted = db.delete(ContactContract.ContactEntry.TABLE_NAME, selection, selectionArgs);
                break;
            case CONTACT_ID:
                // 删除单个联系人数据
                selection = ContactContract.ContactEntry._ID + "=?";
                selectionArgs = new String[]{String.valueOf(ContentUris.parseId(uri))};
                rowsDeleted = db.delete(ContactContract.ContactEntry.TABLE_NAME, selection, selectionArgs);
                break;
            default:
                throw new IllegalArgumentException("Unknown URI: " + uri);
        }

        // 如果有数据删除，通知观察者
        if (rowsDeleted != 0) {
            getContext().getContentResolver().notifyChange(uri, null);
        }

        return rowsDeleted;
    }

    @Override
    public int update(@NonNull Uri uri, @NonNull ContentValues values, @NonNull String selection, @NonNull String[] selectionArgs) {
        // 获取数据库写入实例
        SQLiteDatabase db = dbHelper.getWritableDatabase();

        // 根据传入的URI匹配相应的操作
        int match = uriMatcher.match(uri);
        int rowUpdated;

        switch (match) {
            case CONTACTS:
                // 更新联系人表中的数据
                rowUpdated = db.update(ContactContract.ContactEntry.TABLE_NAME, values, selection, selectionArgs);
                break;
            case CONTACT_ID:
                // 更新单个联系人数据
                selection = ContactContract.ContactEntry._ID + "=?";
                selectionArgs = new String[]{String.valueOf(ContentUris.parseId(uri))};
                rowUpdated = db.update(ContactContract.ContactEntry.TABLE_NAME, values, selection, selectionArgs);
                break;
            default:
                throw new IllegalArgumentException("Unknown URI: " + uri);
        }

        // 如果有数据更新，通知观察者
        if (rowUpdated != 0) {
            getContext().getContentResolver().notifyChange(uri, null);
        }

        return rowUpdated;
    }
}
```

**说明：**

- 实际的 ContentProvider 实现，用于对外提供联系人数据。
- 在 `onCreate` 方法中，初始化数据库帮助类和 URI 匹配器。
- 设置 UriMatcher 来匹配传入的 URI，以便进行相应的操作。在这个例子中，匹配了整个联系人表和单个联系人。

**步骤4：添加 ContentProvider 权限到 AndroidManifest.xml**

- **路径：** `app/src/main`
- **文件名：** `AndroidManifest.xml`

```xml
<!-- AndroidManifest.xml -->

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.ContentProviderStudy"
        tools:targetApi="31">

        <!--
            在应用程序的清单文件中注册ContentProvider，用于对外提供联系人数据。
            设置了provider元素，声明了ContactProvider类作为ContentProvider。
            这个元素包括了必要的配置信息，如authorities和exported属性。
            authorities属性用于指定ContentProvider的授权信息，exported属性设置为false表示不允许其他应用访问此ContentProvider。
        -->
        <provider
            android:name=".data.ContactProvider"
            android:authorities="com.cfk.contentproviderstudy.provider"
            android:exported="false" />
    </application>
</manifest>
```

在 `AndroidManifest.xml` 文件中，我们添加了一个 `provider` 元素，用于声明 `ContactProvider` 类作为 Content Provider。这个元素包括了必要的配置信息，如 `authorities` 和 `exported` 属性。`authorities` 属性用于指定 Content Provider 的授权信息，`exported` 属性设置为 `false` 表示不允许其他应用访问此 Content Provider。

**步骤4：创建测试类并运行测试**

1. **ContactContractTest**

   - **路径：** `app/src/androidTest/java/com/cfk/contentproviderstudy/data/ContactContractTest.java`
   - **文件名：** `ContactContractTest.java`

   ```java
   // ContactContractTest.java
   // File: app/src/androidTest/java/com/cfk/contentproviderstudy/data/ContactContractTest.java
   
   package com.cfk.contentproviderstudy.data;
   
   import android.net.Uri;
   import android.util.Log;
   
   import androidx.test.ext.junit.runners.AndroidJUnit4;
   import androidx.test.platform.app.InstrumentationRegistry;
   
   import org.junit.Test;
   import org.junit.runner.RunWith;
   
   import static org.junit.Assert.assertEquals;
   
   /**
    * ContactContract的单元测试类。
    */
   @RunWith(AndroidJUnit4.class)
   public class ContactContractTest {
   
       private static final String TAG = "ContactContractTest";
   
       @Test
       public void testBuildContactUri() {
           // 使用 InstrumentationRegistry 获取上下文
           android.content.Context context = InstrumentationRegistry.getInstrumentation().getContext();
   
           // 获取测试的URI
           Uri testUri = ContactContract.ContactEntry.CONTENT_URI;
   
           // 验证URI是否被正确构建
           assertEquals("Error: The Contact URI was not built correctly.",
                   testUri.toString(), "content://com.cfk.contentproviderstudy.provider/contacts");
   
           // 输出日志
           Log.d(TAG, "TestBuildContactUri passed: Contact URI is correctly built - " + testUri);
       }
   }
   ```

   说明：

   - 该测试类用于验证 `ContactContract` 类的功能。
   - `testBuildContactUri` 方法测试构建 Contact URI 的正确性，通过验证 URI 是否正确构建来确保该功能的正确性。
   - 该类使用 Android 测试框架，并将测试结果输出到日志中。

   运行该程序，运行结果如下图所示：

   ![笔记-ContentProvider的使用中ContactContractTest运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-ContentProvider%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%ADContactContractTest%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

   由上图可知，以上测试通过，且成功输出了对应的日志。

2. **ContactDBHelperTest**

   - **路径：** `app/src/androidTest/java/com/cfk/contentproviderstudy/data/ContactDBHelperTest.java`
   - **文件名：** `ContactDBHelperTest.java`

   ```java
   // ContactDBHelperTest.java
   // File: app/src/androidTest/java/com/cfk/contentproviderstudy/data/ContactDBHelperTest.java
   
   package com.cfk.contentproviderstudy.data;
   
   import static org.junit.Assert.assertTrue;
   
   import android.content.Context;
   import android.database.sqlite.SQLiteDatabase;
   import android.util.Log;
   
   import androidx.test.core.app.ApplicationProvider;
   import androidx.test.ext.junit.runners.AndroidJUnit4;
   
   import org.junit.After;
   import org.junit.Before;
   import org.junit.Test;
   import org.junit.runner.RunWith;
   
   /**
    * ContactDBHelper的单元测试类。
    */
   @RunWith(AndroidJUnit4.class)
   public class ContactDBHelperTest {
   
       private static final String TAG = "ContactDBHelperTest";
       private Context context;
   
       @Before
       public void setUp() throws Exception {
           // 使用 ApplicationProvider 获取上下文
           context = ApplicationProvider.getApplicationContext();
       }
   
       @Test
       public void testDatabaseCreation() {
           // 创建 ContactDBHelper 实例
           ContactDBHelper dbHelper = new ContactDBHelper(context);
   
           // 获取可读数据库实例
           SQLiteDatabase db = dbHelper.getReadableDatabase();
   
           // 验证数据库是否成功创建
           assertTrue("Error: Database not created successfully.",
                   db.isOpen());
   
           // 关闭数据库
           db.close();
   
           // 输出日志
           Log.d(TAG, "TestDatabaseCreation passed: Database is created successfully.");
       }
   
       @After
       public void tearDown() {
           // 可以在这里添加清理操作
           Log.d(TAG, "TestDatabaseCreation completed.");
       }
   }
   ```

   运行该程序，运行结果如下图所示：

   ![笔记-ContentProvider的使用中ContactDBHelperTest运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-ContentProvider%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%ADContactDBHelperTest%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

   由上图可知，以上测试通过，且成功输出了对应的日志。

3. **ContactProviderTest**

   - **路径：** `app/src/androidTest/java/com/cfk/contentproviderstudy/data/ContactProviderTest.java`
   - **文件名：** `ContactProviderTest.java`

   ```java
   // ContactProviderTest.java
   // File: app/src/androidTest/java/com/cfk/contentproviderstudy/data/ContactProviderTest.java
   
   package com.cfk.contentproviderstudy.data;
   
   import android.content.ContentValues;
   import android.content.Context;
   import android.database.Cursor;
   import android.net.Uri;
   import android.util.Log;
   
   import androidx.test.ext.junit.runners.AndroidJUnit4;
   import androidx.test.platform.app.InstrumentationRegistry;
   
   import org.junit.After;
   import org.junit.Before;
   import org.junit.Test;
   import org.junit.runner.RunWith;
   
   import static org.junit.Assert.assertEquals;
   import static org.junit.Assert.assertNotNull;
   import static org.junit.Assert.assertTrue;
   
   /**
    * 集成测试类，测试 ContentProvider 的插入和查询功能
    */
   @RunWith(AndroidJUnit4.class)
   public class ContactProviderTest {
   
       private Context context;
   
       @Before
       public void setUp() throws Exception {
           context = InstrumentationRegistry.getInstrumentation().getContext();
           // 清空数据库，确保每个测试开始时数据库是空的
           clearDatabase();
       }
   
       @After
       public void tearDown() throws Exception {
           // 清空数据库，确保每个测试结束时数据库是空的
           clearDatabase();
       }
   
       @Test
       public void testInsertAndQuery() {
           // 插入测试数据
           ContentValues values = new ContentValues();
           values.put(ContactContract.ContactEntry.COLUMN_NAME, "John Doe");
           values.put(ContactContract.ContactEntry.COLUMN_PHONE, "123456789");
   
           Uri uri = context.getContentResolver().insert(ContactContract.ContactEntry.CONTENT_URI, values);
           assertNotNull("Error: Insert failed.", uri);
           Log.d("ContactProviderTest", "Inserted URI: " + uri);
   
           // 查询测试数据
           Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
           assertNotNull("Error: Query failed.", cursor);
   
           Log.d("ContactProviderTest", "Query result count: " + cursor.getCount());
   
           assertTrue("Error: Move to the first row failed.", cursor.moveToFirst());
   
           // 检查查询结果与插入的数据是否匹配
           assertEquals("Error: Name not matched.", "John Doe", cursor.getString(cursor.getColumnIndex(ContactContract.ContactEntry.COLUMN_NAME)));
           assertEquals("Error: Phone not matched.", "123456789", cursor.getString(cursor.getColumnIndex(ContactContract.ContactEntry.COLUMN_PHONE)));
   
           cursor.close();
       }
   
       @Test
       public void testUpdate() {
           // 插入测试数据
           ContentValues values = new ContentValues();
           values.put(ContactContract.ContactEntry.COLUMN_NAME, "Jane Doe");
           values.put(ContactContract.ContactEntry.COLUMN_PHONE, "987654321");
   
           Uri insertUri = context.getContentResolver().insert(ContactContract.ContactEntry.CONTENT_URI, values);
           assertNotNull("Error: Insert failed.", insertUri);
   
           Log.d("ContactProviderTest", "Inserted URI for update: " + insertUri);
   
           // 更新测试数据
           ContentValues updateValues = new ContentValues();
           updateValues.put(ContactContract.ContactEntry.COLUMN_NAME, "Updated Name");
           updateValues.put(ContactContract.ContactEntry.COLUMN_PHONE, "Updated Phone");
   
           int updateCount = context.getContentResolver().update(insertUri, updateValues, null, null);
           Log.d("ContactProviderTest", "Update count: " + updateCount);
   
           // 查询更新后的数据
           Cursor cursor = context.getContentResolver().query(insertUri, null, null, null, null);
           assertNotNull("Error: Query after update failed.", cursor);
   
           assertTrue("Error: Move to the first row after update failed.", cursor.moveToFirst());
   
           // 检查更新后的数据是否正确
           assertEquals("Error: Updated name not matched.", "Updated Name", cursor.getString(cursor.getColumnIndex(ContactContract.ContactEntry.COLUMN_NAME)));
           assertEquals("Error: Updated phone not matched.", "Updated Phone", cursor.getString(cursor.getColumnIndex(ContactContract.ContactEntry.COLUMN_PHONE)));
   
           cursor.close();
       }
   
       @Test
       public void testDelete() {
           // 插入测试数据
           ContentValues values = new ContentValues();
           values.put(ContactContract.ContactEntry.COLUMN_NAME, "Delete Me");
           values.put(ContactContract.ContactEntry.COLUMN_PHONE, "555555555");
   
           Uri insertUri = context.getContentResolver().insert(ContactContract.ContactEntry.CONTENT_URI, values);
           assertNotNull("Error: Insert failed.", insertUri);
   
           Log.d("ContactProviderTest", "Inserted URI for delete: " + insertUri);
   
           // 删除测试数据
           int deleteCount = context.getContentResolver().delete(insertUri, null, null);
           Log.d("ContactProviderTest", "Delete count: " + deleteCount);
   
           // 查询是否删除成功
           Cursor cursor = context.getContentResolver().query(insertUri, null, null, null, null);
           assertNotNull("Error: Query after delete failed.", cursor);
   
           assertEquals("Error: Delete did not succeed.", 0, cursor.getCount());
   
           cursor.close();
       }
   
       @Test
       public void testBulkInsert() {
           ContentValues[] bulkInsertValues = new ContentValues[3];
   
           for (int i = 0; i < 3; i++) {
               ContentValues values = new ContentValues();
               values.put(ContactContract.ContactEntry.COLUMN_NAME, "Bulk Insert " + (i + 1));
               values.put(ContactContract.ContactEntry.COLUMN_PHONE, "Bulk Phone " + (i + 1));
               bulkInsertValues[i] = values;
           }
   
           // 批量插入测试数据
           int insertedCount = context.getContentResolver().bulkInsert(ContactContract.ContactEntry.CONTENT_URI, bulkInsertValues);
           Log.d("ContactProviderTest", "Bulk insert count: " + insertedCount);
   
           // 查询批量插入后的数据
           Cursor cursor = context.getContentResolver().query(ContactContract.ContactEntry.CONTENT_URI, null, null, null, null);
           assertNotNull("Error: Query after bulk insert failed.", cursor);
   
           assertEquals("Error: Incorrect number of rows after bulk insert.", 3, cursor.getCount());
   
           cursor.close();
       }
   
       private void clearDatabase() {
           // 清空数据库，以确保每个测试开始或结束时数据库是空的
           context.deleteDatabase(ContactDBHelper.DATABASE_NAME);
           Log.d("ContactProviderTest", "Cleared the database");
       }
   }
   ```

   运行该程序，运行结果如下图所示：

   ![笔记-ContentProvider的使用中ContactProviderTest运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-ContentProvider%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%ADContactProviderTest%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

   由上图可知，以上测试通过，且成功输出了对应的日志。

# 11 布局

**定义：**

布局是一种将用户界面中的各种视图元素按照一定规则进行排列和组织的技术或方法。在Android中，布局通常通过XML文件定义，开发者可以在XML中声明界面的结构和层次，包括各种视图元素的相对位置、大小和样式。

**背景与意义：**

**a. 多设备适配性：**

Android系统运行在众多不同分辨率和屏幕尺寸的设备上，包括手机、平板和电视等。布局提供了一种灵活的方式，使得应用能够适应不同设备的屏幕尺寸和分辨率，确保用户在各种设备上都能够获得一致的用户体验。

**b. 灵活性与可维护性：**

使用布局可以使界面元素的排列更加灵活，开发者可以通过修改布局而不是直接修改代码来调整UI。这提高了应用的可维护性，减少了对代码的依赖，使得界面设计和调整更加方便。

**c. 分离关注点：**

布局的使用有助于分离关注点，使得界面设计和业务逻辑分离。开发者可以专注于定义界面的结构和外观，而不必深陷于处理视图的具体细节。

**d. 提升用户体验：**

合理的布局设计可以提升用户体验，使得应用界面看起来更加美观、直观，并且易于使用。通过良好的布局，用户可以更容易理解和操作应用。

**其它介绍及使用方法如下。**

## 11.1 五大布局

### 11.1.1 五大布局的介绍

当在Android开发中设计用户界面时，选择适当的布局方式至关重要。以下是对五大布局方式的更为详细的介绍，每个布局都包含有形象的例子：

1. **线性布局 (LinearLayout)：**

线性布局是一种简单而灵活的布局方式，按照水平或垂直方向线性排列子视图。通过`android:orientation`属性可以指定布局方向，可以是水平 (`horizontal`) 或垂直 (`vertical`)。

**主要属性：**

- `android:layout_weight`：设置视图在布局中的权重，用于实现相对占比。

**适用场景：**
当子视图需要线性排列，且相对占比需要动态调整时，线性布局是一个不错的选择。

**例子：**

```xml
<!-- 文件路径：app/src/main/res/layout/activity_try.xml -->
<!-- 1. 线性布局 (LinearLayout) -->
<!--
    线性布局是一种简单而灵活的布局方式，按照垂直方向线性排列子视图。
    可以根据需要更改 android:orientation 为 "horizontal" 以实现水平排列。
-->

<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:gravity="center">

    <!-- 示例子视图1：TextView -->
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:text="Item 1"
        android:textSize="18sp"
        android:gravity="center"
        android:background="#e0e0e0"
        android:padding="8dp"
        android:layout_marginBottom="8dp" />

    <!-- 示例子视图2：Button -->
    <Button
        android:layout_width="wrap_content"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:layout_marginTop="8dp"
        android:text="Click Me"
        android:textSize="18sp"
        android:gravity="center"
        android:background="#4CAF50"
        android:paddingStart="24dp"
        android:paddingEnd="24dp"
        android:paddingTop="12dp"
        android:paddingBottom="12dp"
        android:textColor="#FFFFFF"
        android:elevation="4dp"
        android:stateListAnimator="@null"
        android:outlineSpotShadowColor="@android:color/transparent" />
    
    <!-- 示例子视图3：ImageView -->
    <ImageView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="2"
        android:src="@drawable/image"
        android:scaleType="fitCenter"
        android:layout_marginTop="16dp" />
</LinearLayout>
```

```xml
<!-- 文件路径：app/src/main/res/drawable/image.xml -->
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <!--正常状态下的图片-->
    <item android:drawable="@drawable/dog"/>
</selector>
```

在上面的代码中，`android:orientation="vertical"` 表示线性布局是垂直方向排列的，即子视图按照从上到下的顺序排列。`android:layout_weight`用于控制子视图在布局中的相对权重，以实现按比例分配剩余空间。在示例中，TextView和Button的权重都为1，ImageView的权重为2，表示ImageView在垂直方向上占用的空间是TextView和Button的两倍。

布局代码显示结果如下图所示：

![笔记-五大布局的介绍中线性布局运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%AD%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

**2. 相对布局 (RelativeLayout)：**

相对布局允许子视图相对于其他视图或父布局定位。通过使用规则（如`android:layout_below`、`android:layout_toRightOf`等）定义视图的位置。

**主要属性：**
- 规则属性如 `android:layout_above`、`android:layout_below` 等。

**适用场景：**
当需要根据其他视图的相对位置排列子视图时，相对布局是一个强大的选择。

**例子：**
```xml
<!-- 文件路径：app/src/main/res/layout/activity_try.xml -->
<!-- 2. 相对布局 (RelativeLayout) -->
<!--
    相对布局允许子视图相对于其他视图或父布局定位。
    在这个例子中，一个 TextView 被放置在左上角，而一个 Button 则位于 TextView 的下方和右侧。
-->

<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:gravity="center">

    <!-- 示例子视图1：TextView，ID 为 textView1 -->
    <TextView
        android:id="@+id/textView1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Top Left"
        <!-- 设置 TextView 位于左上角 -->
        android:layout_alignParentStart="true"
        android:layout_alignParentTop="true"
        android:layout_marginStart="16dp"
        android:layout_marginTop="16dp" />

    <!-- 示例子视图2：Button -->
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Bottom Right"
        <!-- 设置 Button 位于 textView1 的下方和右侧 -->
        android:layout_below="@id/textView1"
        android:layout_toEndOf="@id/textView1"
        android:layout_marginTop="8dp"
        android:layout_marginStart="8dp" />
</RelativeLayout>
```

在这个例子中，通过设置 `TextView` 位于左上角，并添加了一些 margin，以使得它在左上角更为明显。同时，`Button` 位于 `TextView` 的下方和右侧，通过 `layout_below` 和 `layout_toEndOf` 属性来定位。

布局代码显示结果如下图所示：

![笔记-五大布局的介绍中相对布局运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%AD%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

**3. 帧布局 (FrameLayout)：**

帧布局是一种简单的布局，将子视图堆叠在彼此之上，后加入的子视图会覆盖先加入的。通常用于容纳单一视图或叠加效果。

**主要属性：**
- `android:layout_gravity`：设置子视图在布局中的对齐方式。

**适用场景：**
当需要在同一区域显示多个视图，但只显示最上层视图时，帧布局是一个适合的选择。

**例子：**
```xml
<!-- 帧布局 (FrameLayout) -->
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- 示例子视图1：ImageView -->
    <ImageView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:src="@drawable/image" />

    <!-- 背景遮罩 -->
    <View
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="#80000000" />

    <!-- 示例子视图2：ProgressBar -->
    <ProgressBar
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        style="?android:attr/progressBarStyleLarge"
        android:indeterminateTint="@android:color/white" />
</FrameLayout>
```

```xml
<!-- 文件路径：app/src/main/res/drawable/image.xml -->
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <!--正常状态下的图片-->
    <item android:drawable="@drawable/dog"/>
</selector>
```

帧布局在这个例子中的应用场景是实现一个图片上的加载状态提示。通过将ImageView作为背景，覆盖一个半透明的遮罩层，再在中央放置一个ProgressBar，实现了加载状态的视觉效果。

布局代码显示结果如下图所示：

![笔记-五大布局的介绍中帧布局运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%AD%E5%B8%A7%E5%B8%83%E5%B1%80%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

**4. 表格布局 (TableLayout)：**

表格布局是一种按行和列排列子视图的方式。使用 `<TableRow>` 来定义每一行，子视图放置在行内。

**主要属性：**
- `android:layout_span`：定义子视图跨越的列数。
- `android:layout_column`：定义子视图所在的列。

**适用场景：**
当需要创建表格状的布局，子视图按行列排列时，表格布局是一个适合的选择。

**例子：**
```xml
<!-- 表格布局 (TableLayout) -->
<!--
    表格布局是一种按行和列排列子视图的方式。
    在这个例子中，创建了一个简单的学生信息表格，每一行代表一个学生的信息。
    字体大小进行了进一步调整。
-->

<TableLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:stretchColumns="*">

    <!-- 表头行 -->
    <TableRow>
        <!-- 学生姓名 -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="姓名"
            android:gravity="center"
            android:textStyle="bold"
            android:textSize="20sp"/>

        <!-- 学生年龄 -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="年龄"
            android:gravity="center"
            android:textStyle="bold"
            android:textSize="20sp"/>

        <!-- 学生成绩 -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="成绩"
            android:gravity="center"
            android:textStyle="bold"
            android:textSize="20sp"/>
    </TableRow>

    <!-- 学生1的信息 -->
    <TableRow>
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Alice"
            android:gravity="center"
            android:textSize="18sp"/>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="20"
            android:gravity="center"
            android:textSize="18sp"/>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="90"
            android:gravity="center"
            android:textSize="18sp"/>
    </TableRow>

    <!-- 学生2的信息 -->
    <TableRow>
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Bob"
            android:gravity="center"
            android:textSize="18sp"/>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="22"
            android:gravity="center"
            android:textSize="18sp"/>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="85"
            android:gravity="center"
            android:textSize="18sp"/>
    </TableRow>

</TableLayout>
```

这个例子中，我们创建了一个学生信息的表格，每一行包含学生的姓名、年龄和成绩。表头行显示了每列的信息类型，而每个子视图都被放置在相应的列中。这样的表格布局可以更好地展示表格的结构和内容。

布局代码显示结果如下图所示：

![笔记-五大布局的介绍中表格布局运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%AD%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

**5. 网格布局 (GridLayout)：**

网格布局允许子视图按照行和列的网格方式排列。通过指定 `layout_row` 和 `layout_column` 属性来定义子视图在网格中的位置。

**主要属性：**

- `android:rowCount` 和 `android:columnCount`：定义行数和列数。

**适用场景：**
当需要实现复杂的网格状布局，子视图可以跨越多行多列时，网格布局是一个强大的选择。

**例子：**
```xml
<!-- 网格布局 (GridLayout) -->
<!--
    网格布局允许子视图按照行和列的网格方式排列。
    在这个例子中，创建了一个包含两列的网格布局。
    四个 Button 分别被放置在不同的行和列中，形成了一个简单的按钮网格。
    网格布局在水平和垂直方向均居中显示。
-->

<GridLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:columnCount="4">

    <!-- 子视图1：ImageView -->
    <ImageView
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:src="@drawable/image"
        android:scaleType="fitCenter"
        android:layout_row="0"
        android:layout_column="0"
        android:layout_rowSpan="2" />

    <!-- 子视图2：TextView -->
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Title"
        android:textSize="18sp"
        android:layout_row="0"
        android:layout_column="1" />

    <!-- 子视图3：TextView -->
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Description"
        android:textSize="14sp"
        android:layout_row="1"
        android:layout_column="1" />

    <!-- 子视图4：Button -->
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Action"
        android:layout_row="0"
        android:layout_column="2" />

    <!-- 子视图5：Button -->
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Details"
        android:layout_row="1"
        android:layout_column="2" />

</GridLayout>
```

这个GridLayout布局中的各个子视图占用的网格位置如下：

1. **ImageView (子视图1)：**
   - **占用网格位置：** 位于第0行、第0列，横跨了2行（`android:layout_row="0"`, `android:layout_column="0"`, `android:layout_rowSpan="2"`）。

2. **TextView (子视图2)：**
   - **占用网格位置：** 位于第0行、第1列（`android:layout_row="0"`, `android:layout_column="1"`）。

3. **TextView (子视图3)：**
   - **占用网格位置：** 位于第1行、第1列（`android:layout_row="1"`, `android:layout_column="1"`）。

4. **Button (子视图4)：**
   - **占用网格位置：** 位于第0行、第2列（`android:layout_row="0"`, `android:layout_column="2"`）。

5. **Button (子视图5)：**
   - **占用网格位置：** 位于第1行、第2列（`android:layout_row="1"`, `android:layout_column="2"`）。

通过指定每个子视图的`layout_row`和`layout_column`属性，我们定义了它们在GridLayout中的行和列位置。此外，ImageView使用了`layout_rowSpan`属性横跨了两行，占据了更大的空间。这样的网格布局方式使得每个子视图都能准确地被放置在指定的位置，形成了一个整齐有序的界面。

布局代码显示结果如下图所示：

![笔记-五大布局的介绍中网格布局运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%AD%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

### 11.1.2 五大布局的区别

Android中的五大布局分别是线性布局（LinearLayout）、相对布局（RelativeLayout）、帧布局（FrameLayout）、表格布局（TableLayout）和网格布局（GridLayout）。它们在布局结构和使用方式上有一些关键的区别：

1. **线性布局 (LinearLayout)：**
   - **特点：** 子视图按照水平或垂直的线性方向排列。
   - **使用场景：** 适用于简单的线性排列，如水平排列的按钮、文本等。

2. **相对布局 (RelativeLayout)：**
   - **特点：** 子视图的位置相对于父布局或其他子视图确定。
   - **使用场景：** 适用于复杂的界面，可以根据其他视图的位置来相对定位。

3. **帧布局 (FrameLayout)：**
   - **特点：** 子视图堆叠在彼此之上，后加入的子视图会覆盖先加入的。
   - **使用场景：** 适用于需要显示单一视图或实现叠加效果的情况，如显示图片和加载状态。

4. **表格布局 (TableLayout)：**
   - **特点：** 子视图按照行和列的方式排列，通过TableRow来定义每一行。
   - **使用场景：** 适用于创建表格状的布局，子视图按行列排列，如显示数据表格。

5. **网格布局 (GridLayout)：**
   - **特点：** 子视图按照行和列的网格方式排列，可以指定每个子视图所占的行列数。
   - **使用场景：** 适用于实现复杂的网格状布局，子视图可以跨越多行多列，提供更灵活的布局方式。

总体而言，选择布局方式取决于具体的设计需求。线性布局适用于简单的线性排列，相对布局适用于复杂的相对定位，帧布局适用于显示单一视图或实现叠加效果，表格布局适用于表格状的排列，而网格布局则提供了更为灵活的网格状布局方式。在实际开发中，通常会根据界面的复杂度和设计要求选择合适的布局方式或组合多种布局方式。

### 11.1.3 五大布局的使用

五大布局指的是Android中常用的五种布局方式：线性布局、相对布局、帧布局、表格布局和绝对布局。以下是简单的用法说明：

1. **线性布局（LinearLayout）：**

   线性布局（LinearLayout）是Android开发中常用的布局之一，它以水平或垂直的线性方式排列子视图。下面是关于线性布局的一些详细解释和使用示例：

   **（1）布局方向（Orientation）：**

   线性布局可以有两种方向：水平（horizontal）和垂直（vertical）。在XML布局文件中，通过设置`android:orientation`属性来指定方向。

   ```xml
   <!-- 垂直布局 -->
   <LinearLayout
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:orientation="vertical">
   
       <!-- 子视图们 -->
   
   </LinearLayout>
   
   <!-- 水平布局 -->
   <LinearLayout
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:orientation="horizontal">
   
       <!-- 子视图们 -->
   
   </LinearLayout>
   ```

   **（2）权重（Weight）：**

   权重用于指定子视图在布局中所占的比例。在使用权重时，需要将子视图的宽度或高度设置为0dp（match_parent会被忽略），然后使用`android:layout_weight`属性设置权重值。

   ```xml
   <LinearLayout
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:orientation="horizontal">
   
       <Button
           android:layout_width="0dp"
           android:layout_height="wrap_content"
           android:layout_weight="1"
           android:text="Button 1"/>
   
       <Button
           android:layout_width="0dp"
           android:layout_height="wrap_content"
           android:layout_weight="2"
           android:text="Button 2"/>
   
       <!-- 更多子视图们 -->
   
   </LinearLayout>
   ```

   在上面的例子中，第二个按钮的权重是第一个按钮的两倍，因此它会占据更多的空间。

   **（3）布局重力（Gravity）：**

   通过`android:gravity`属性可以设置线性布局中所有子视图的对齐方式，包括垂直和水平方向。

   ```xml
   <LinearLayout
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:orientation="horizontal"
       android:gravity="center_vertical">
   
       <!-- 子视图们 -->
   
   </LinearLayout>
   ```

   在这个例子中，`android:gravity="center_vertical"`将使得所有子视图在垂直方向上居中对齐。

   **（4）子视图间距（Spacing）：**

   使用`android:layout_margin`属性可以设置子视图之间的间距，这适用于水平和垂直方向。

   ```xml
   <LinearLayout
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:orientation="horizontal"
       android:layout_margin="16dp">
   
       <!-- 子视图们 -->
   
   </LinearLayout>
   ```

   在这个例子中，子视图之间的间距为16dp。

   **（5）嵌套使用：**

   线性布局可以嵌套使用，以创建更复杂的界面结构。

   ```xml
   <LinearLayout
       android:layout_width="match_parent"
       android:layout_height="match_parent"
       android:orientation="vertical">
   
       <!-- 垂直线性布局的子视图 -->
   
       <LinearLayout
           android:layout_width="match_parent"
           android:layout_height="wrap_content"
           android:orientation="horizontal">
   
           <!-- 水平线性布局的子视图 -->
   
       </LinearLayout>
   
       <!-- 更多嵌套的线性布局或其他布局 -->
   
   </LinearLayout>
   ```

   这些是使用线性布局的一些基本概念和例子。通过灵活地组合方向、权重、布局重力和间距等属性，可以实现各种不同的布局效果。

   下面我们结合一个具体的例子来说明线性布局的使用：

   假设我们要设计一个登录界面，其中包括一个用户名输入框、一个密码输入框、以及登录按钮。我们将使用垂直线性布局来排列这些元素。

   ```xml
   <LinearLayout
       xmlns:android="http://schemas.android.com/apk/res/android"<!--定义命名空间，用于指定XML文件中所使用的命名空间。在安卓开发中，通常使用http://schemas.android.com/apk/res/android-->
       android:layout_width="match_parent"<!--设置布局的宽度，match_parent表示布局会充满其父容器-->
       android:layout_height="match_parent"<!--设置布局的高度，match_parent表示布局会充满其父容器-->
       android:orientation="vertical"<!--这个属性决定了线性布局的方向。在这里，它被设置为vertical，表示子视图会垂直排列-->
       android:padding="16dp"<!--内边距，指定了布局的内部边距。这里设置为16dp，表示布局内容区域距边界的距离是16dp-->
       android:gravity="center"><!--定义了布局内部所有子视图的对齐方式。被设置为center表示子视图在布局中会居中对齐-->
       <!--用户名输入框-->
       <EditText
           android:layout_width="match_parent"<!--设置EditText的高度，match_parent表明它的宽度会充满父容器-->
           android:layout_height="wrap_content"<!--设置EditText的高度，match_parent表明它的高度会充满父容器-->
           android:hint="Username"<!--设置在文本输入框内部显示的提示性文字，这里设置为“Username"，提示用户在这个输入框中输入用户名-->
           android:inputType="text"/><!--定义用户可以在文本输入框中输入的数据类型，这里设置为”text“表示用户可以输入任意文本。根据相应的需求，你可以设置不同的值，比如”number“表示只能输入数字，”textPassword“表示输入密码->
   
       <!--密码输入框-->
       <EditText
           android:layout_width="match_parent"<!--设置EditText的宽度，match_parent表明它的宽度会充满父容器-->
           android:layout_height="wrap_content"<!--设置EditText的高度，match_parent表明它的高度会充满父容器-->
           android:hint="Password"<!--设置在文本输入框内部显示的提示性文字，这里设置为“Password"，提示用户在这个输入框中输入用户名-->
           android:inputType="textPassword"<!--定义用户可以在文本输入框中输入的数据类型，这里设置为”textPassword“表示输入密码-->
           android:layout_marginTop="8dp"/><!--设置了EditText与其上方的父容器或其他视图之间的上边距，这里设置为8dp表示上边距为8dp-->
   
       <!--登录按钮-->
       <Button
           android:layout_width="wrap_content"<!--设置Button的宽度，match_parent表明它的宽度会充满父容器-->
           android:layout_height="wrap_content"<!--设置Button的高度，match_parent表明它的宽度会充满父容器-->
           android:text="Login"<!--设置按钮上显示的文本内容，这里设置为“Login”表示按钮上将显示登录的文字-->
           android:layout_marginTop="16dp"/><!--设置了Button与其上方的父容器或其他视图之间的上边距，这里设置为8dp表示上边距为16dp-->
   </LinearLayout>
   ```

   这个例子的解释如下：

   1. 我们创建了一个垂直线性布局，设置了 `android:orientation="vertical"` 表示子视图将在垂直方向上排列。
   2. 使用 `android:padding` 属性为整个布局设置内边距。
   3. 添加了一个用户名输入框（EditText），设置了提示文字和输入类型。
   4. 添加了一个密码输入框，同样设置了提示文字和输入类型为密码。
   5. 最后，加入了一个登录按钮。

   这个布局会使得用户名输入框、密码输入框和登录按钮垂直排列，并且整体居中显示。你可以根据实际需求进行修改和扩展。

   布局代码显示结果如下图所示：

   ![笔记-五大布局的使用中线性布局运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

2. **相对布局（RelativeLayout）：**

   相对布局（RelativeLayout）是Android开发中常用的布局之一，它允许你定义子视图相对于其他视图或父布局的位置。下面是相对布局的基本使用方法：

   **（1）在XML布局文件中定义RelativeLayout**

   ```xml
   <?xml version="1.0" encoding="utf-8"?>
   <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
       android:layout_width="match_parent"
       android:layout_height="match_parent">
   
       <!-- 在这里添加子视图 -->
   
   </RelativeLayout>
   ```

   **（2）添加子视图并设置相对关系**

   在`RelativeLayout`中，你可以使用各种属性来定义子视图之间的相对关系。以下是一些常见的属性：

   - `android:layout_above`: 将当前视图放置在指定视图的上方。
   - `android:layout_below`: 将当前视图放置在指定视图的下方。
   - `android:layout_toLeftOf`: 将当前视图放置在指定视图的左侧。
   - `android:layout_toRightOf`: 将当前视图放置在指定视图的右侧。
   - `android:layout_alignTop`: 将当前视图的顶部与指定视图的顶部对齐。
   - `android:layout_alignBottom`: 将当前视图的底部与指定视图的底部对齐。
   - `android:layout_alignLeft`: 将当前视图的左侧与指定视图的左侧对齐。
   - `android:layout_alignRight`: 将当前视图的右侧与指定视图的右侧对齐。

   以下是一个简单的例子，展示了如何使用相对布局来放置两个按钮：

   ```xml
   <?xml version="1.0" encoding="utf-8"?>
   <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
       android:layout_width="match_parent"
       android:layout_height="match_parent">
   
       <Button
           android:id="@+id/btnLeft"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:text="Left Button"
           android:layout_alignParentLeft="true" />
   
       <Button
           android:id="@+id/btnRight"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:text="Right Button"
           android:layout_alignParentRight="true" />
   
   </RelativeLayout>
   ```

   在这个例子中，第一个按钮（btnLeft）被放置在父布局的左侧，而第二个按钮（btnRight）被放置在父布局的右侧。

   **（3）相对布局的其他属性**

   相对布局还有一些其他属性，例如`android:layout_centerInParent`可以将子视图放置在父布局的中心，`android:layout_centerHorizontal`和`android:layout_centerVertical`可以分别将子视图水平和垂直居中等。

   总体来说，相对布局提供了很大的灵活性，可以根据需要灵活地定义子视图之间的相对关系。

   下面我们通过一个具体的例子来说明相对布局的使用：

   假设我们要设计一个美观的美食详情页面。图片、美食名称、评分和喜欢按钮都被巧妙地放置在屏幕上，下面是相关的代码：

   ```xml
   <?xml version="1.0" encoding="utf-8"?>
   <!-- 主要布局容器为RelativeLayout，用于相对定位子视图 -->
   <RelativeLayout
       xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:app="http://schemas.android.com/apk/res-auto"
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:background="#F5F5F5" <!-- 整体背景色 -->
       android:padding="16dp"> <!-- 整体内边距 -->
   
       <!-- 美食图片，居中显示 -->
       <ImageView
           android:id="@+id/ivFoodImage"
           android:layout_width="match_parent"
           android:layout_height="200dp"
           android:src="@drawable/hamburger" <!-- 图片资源 -->
           android:scaleType="fitCenter" <!-- 图片缩放类型，居中显示 -->
           android:layout_centerInParent="true"/> <!-- 在父容器中居中显示 -->
   
       <!-- 美食名称，位于图片的下方，水平居中 -->
       <TextView
           android:id="@+id/tvFoodName"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:text="汉堡" <!-- 美食名称 -->
           android:textSize="30sp" <!-- 文字大小 -->
           android:textStyle="bold" <!-- 粗体文字 -->
           android:layout_below="@+id/ivFoodImage" <!-- 位于图片下方 -->
           android:layout_centerHorizontal="true" <!-- 水平居中 -->
           android:layout_marginTop="150dp" <!-- 与图片底部的距离 -->
           android:textColor="#333"/> <!-- 文字颜色，深灰色 -->
   
       <!-- 评分，位于美食名称的下方，水平居中 -->
       <TextView
           android:id="@+id/tvRating"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:text="评分：4.5" <!-- 评分文字 -->
           android:textSize="20sp" <!-- 文字大小 -->
           android:layout_below="@+id/tvFoodName" <!-- 位于美食名称下方 -->
           android:layout_centerHorizontal="true" <!-- 水平居中 -->
           android:layout_marginTop="6dp" <!-- 与美食名称的距离 -->
           android:textColor="#FFC107"/> <!-- 文字颜色，Material Design 的黄色 -->
   
       <!-- 喜欢按钮，位于评分的下方，水平居中 -->
       <ImageButton
           android:id="@+id/btnLike"
           android:layout_width="56dp" <!-- 按钮宽度 -->
           android:layout_height="56dp" <!-- 按钮高度 -->
           android:src="@android:drawable/btn_star_big_off" <!-- 按钮图标 -->
           android:background="?android:attr/selectableItemBackgroundBorderless" <!-- 按钮背景 -->
           android:layout_below="@+id/tvRating" <!-- 位于评分下方 -->
           android:layout_centerHorizontal="true" <!-- 水平居中 -->
           android:layout_marginTop="8dp" <!-- 与评分的距离 -->
           app:tint="#FF4081" /> <!-- 按钮颜色，Material Design 的粉红色 -->
   </RelativeLayout>
   ```

   这个例子是一个使用RelativeLayout布局的Android XML文件，用于展示美食详情页面。页面包括一个居中显示的美食图片，美食名称位于图片下方水平居中，评分位于美食名称下方水平居中，而喜欢按钮则位于评分下方水平居中。整体布局通过相对定位，使得各个元素在页面上有序排列。美食详情页面设计得简洁而美观，适合展示单个美食的相关信息。

   布局代码显示结果如下图所示：

   ![笔记-五大布局的使用中相对布局运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

3. **帧布局（FrameLayout）：**
   
   在Android开发中，`FrameLayout` 是一种简单的布局容器，用于在屏幕上放置子视图（View）。`FrameLayout` 是一种轻量级的布局，它允许子视图堆叠在一起，但只有一个子视图可见。当你添加多个子视图时，它们将按照它们被添加的顺序依次叠放，后添加的子视图会覆盖在前面添加的子视图上。
   
   以下是 `FrameLayout` 的基本使用方法：
   
   1. **在布局文件中声明 `FrameLayout`：**
   
      在 XML 布局文件中，你可以使用 `<FrameLayout>` 标签声明一个 `FrameLayout`。例如：
   
      ```xml
      <FrameLayout
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
   
          <!-- 添加子视图在这里 -->
   
      </FrameLayout>
      ```
   
   2. **添加子视图：**
   
      在 `FrameLayout` 中，你可以添加各种子视图，例如 `ImageView`、`TextView`、`Button` 等。子视图会按照它们被添加的顺序堆叠在一起。
   
      ```xml
      <FrameLayout
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
   
          <ImageView
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:src="@drawable/my_image"/>
   
          <TextView
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="Hello, FrameLayout!"
              android:layout_gravity="center"/>
   
      </FrameLayout>
      ```
   
      在上面的例子中，`ImageView` 和 `TextView` 分别是 `FrameLayout` 的两个子视图。由于 `TextView` 的 `layout_gravity` 属性设置为 `center`，它将在屏幕中心显示。
   
   3. **调整子视图的位置：**
   
      你可以通过 `layout_gravity` 属性调整子视图在 `FrameLayout` 中的位置。例如，设置为 `top|start` 可以使子视图位于左上角。
   
      ```xml
      <FrameLayout
          xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
   
          <ImageView
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:src="@drawable/my_image"/>
   
          <TextView
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="Hello, FrameLayout!"
              android:layout_gravity="top|start"/>
   
      </FrameLayout>
      ```
   
      上述代码中，`TextView` 将位于屏幕的左上角。
   
   4. **注意事项：**
   
      - 当你添加多个子视图时，后添加的子视图会叠放在前面的子视图之上。
      - `FrameLayout` 的大小默认是包裹其所有子视图的大小，但你也可以通过设置 `layout_width` 和 `layout_height` 来指定大小。
   
   这是 `FrameLayout` 的基本使用方法。你可以通过组合不同的子视图和使用不同的布局参数来创建各种复杂的界面。希望这能帮助你更好地理解如何使用 `FrameLayout` 进行 Android 布局。
   
   下面我们通过一个图片切换的实例来具体介绍一下帧布局：
   
   在这个例子中，我们将创建一个简单的图片浏览应用，使用 `FrameLayout` 来实现图片切换效果。这个应用包含两个按钮和一个 `ImageView`，用户点击按钮时可以切换显示的图片。
   
   1. **准备图片资源：**
   
      在 `src/res/drawable` 文件夹下放入两张图片（例如 `sun.jpg` 和 `moon.jpg`）。
   
   2. **创建布局文件：**
   
      在 `src/res/layout` 文件夹下创建一个 XML 布局文件（例如 `activity_main.xml`），使用 `FrameLayout` 声明布局结构：
   
      ```xml
      <?xml version="1.0" encoding="utf-8"?>
      <!-- FrameLayout 是一个简单的布局容器，允许子视图堆叠在一起。 -->
      <FrameLayout
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
      
          <!-- ImageView 用于显示图片 -->
          <ImageView
              android:id="@+id/imageView"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:scaleType="fitCenter" <!-- 图片按比例缩放并居中显示 -->
              android:src="@drawable/sun"/> <!-- 初始显示的图片资源 -->
      
          <!-- Button 用于切换图片 -->
          <Button
              android:id="@+id/btnSwitch"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="Switch Image" <!-- 按钮显示的文本 -->
              android:layout_gravity="start|bottom" <!-- 按钮位于左下角 -->
              android:layout_marginStart="16dp" <!-- 距离左边的边距 -->
              android:layout_marginBottom="16dp" <!-- 距离底边的边距 -->
              tools:ignore="MissingConstraints" /> <!-- 防止在设计时出现缺少约束的警告 -->
      
          <!-- Button 用于重置照片 -->
          <Button
              android:id="@+id/btnReset"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="Reset Image" <!-- 按钮显示的文本 -->
              android:layout_gravity="end|bottom" <!-- 按钮位于右下角 -->
              android:layout_marginEnd="16dp" <!-- 距离右边的边距 -->
              android:layout_marginBottom="16dp" <!-- 距离底边的边距 -->
              tools:ignore="MissingConstraints" /> <!-- 防止在设计时出现缺少约束的警告 -->
      
      </FrameLayout>
      ```
   
      在这个布局中，我们使用 `ImageView` 显示图片，并添加了两个按钮（`btnSwitch` 和 `btnReset`）分别用于切换图片和重置图片。按钮的位置通过 `layout_gravity` 和 `layout_margin` 进行设置。
   
   3. **在 `FrameLayoutActivity.java` 中实现逻辑：**
   
      在`src/main/java/com/cfk/layoutstudy/activity/FrameLayoutActivity.java` 文件中处理按钮点击事件，实现图片的切换和重置：
   
      ```java
      package com.cfk.layoutstudy.activity;
      
      import android.os.Bundle;
      import android.view.View;
      import android.widget.Button;
      import android.widget.ImageView;
      
      import androidx.annotation.Nullable;
      import androidx.appcompat.app.AppCompatActivity;
      
      import com.cfk.layoutstudy.R;
      
      /**
       * FrameLayoutActivity 演示了在 FrameLayout 中切换和重置图片的功能。
       */
      public class FrameLayoutActivity extends AppCompatActivity {
          private ImageView imageView;
          private Button btnSwitch;
          private Button btnReset;
      
          private int currentImage = 1; // 用于跟踪当前显示的图片
      
          @Override
          protected void onCreate(@Nullable Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.activity_frame_layout);
      
              // 初始化视图
              imageView = findViewById(R.id.imageView);
              btnSwitch = findViewById(R.id.btnSwitch);
              btnReset = findViewById(R.id.btnReset);
      
              // 设置按钮点击事件
              btnSwitch.setOnClickListener(new View.OnClickListener() {
                  @Override
                  public void onClick(View v) {
                      switchImage();
                  }
              });
              btnReset.setOnClickListener(new View.OnClickListener() {
                  @Override
                  public void onClick(View v) {
                      resetImage();
                  }
              });
          }
      
          /**
           * 切换图片
           */
          private void switchImage() {
              currentImage = (currentImage == 1) ? 2 : 1;
              int imageResId = (currentImage == 1) ? R.drawable.sun : R.drawable.moon;
              imageView.setImageResource(imageResId);
          }
      
          /**
           * 重置图片
           */
          private void resetImage() {
              currentImage = 1;
              imageView.setImageResource(R.drawable.sun);
          }
      }
      ```
   
      在 `FrameLayoutActivity` 中，我们通过 `findViewById` 获取布局中的 `ImageView` 和两个按钮，然后设置按钮的点击事件。`switchImage` 方法用于切换图片，`resetImage` 方法用于重置图片。
   
   4. 在`AndroidManifest.xml`文件中注册活动：
   
      在`AndroidManifest.xml`文件中注册`FrameLayoutActivity`活动，代码如下：
   
      ```xml
      <?xml version="1.0" encoding="utf-8"?>
      <!-- AndroidManifest.xml 文件定义了应用程序的基本信息，包括权限、组件等配置 -->
      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools">
      
          <!-- 应用程序的配置信息 -->
          <application
              android:allowBackup="true" <!-- 允许备份应用数据 -->
              android:dataExtractionRules="@xml/data_extraction_rules" <!-- 数据提取规则 -->
              android:fullBackupContent="@xml/backup_rules" <!-- 完整备份内容规则 -->
              android:icon="@mipmap/ic_launcher" <!-- 应用图标 -->
              android:label="@string/app_name" <!-- 应用名称 -->
              android:roundIcon="@mipmap/ic_launcher_round" <!-- 圆形图标 -->
              android:supportsRtl="true" <!-- 支持右到左布局 -->
              android:theme="@style/Theme.LayoutStudy" <!-- 应用主题样式 -->
              tools:targetApi="31"> <!-- 指定工具目标 API 版本 -->
      
              <!-- 应用程序包含的活动组件 -->
              <activity
                  android:name=".activity.FrameLayoutActivity" <!-- 指定活动的类名 -->
                  android:exported="true"> <!-- 允许其他应用启动该活动 -->
      
                  <!-- 定义活动的启动意图 -->
                  <intent-filter>
                      <action android:name="android.intent.action.MAIN" /> <!-- 主要入口点 -->
                      <category android:name="android.intent.category.LAUNCHER" /> <!-- 设置为启动器 -->
                  </intent-filter>
              </activity>
          </application>
      
      </manifest>
      ```
   
      `AndroidManifest.xml` 是 Android 应用程序的清单文件，其中的 `<activity>` 元素定义了应用包含的活动组件。在这段清单中，`<activity>` 元素指定了 `FrameLayoutActivity` 作为应用的一个活动，并通过设置 `android:exported="true"` 允许其他应用启动该活动。在 `<intent-filter>` 元素内，通过定义 `<action>` 为 `"android.intent.action.MAIN"` 和 `<category>` 为 `"android.intent.category.LAUNCHER"`，将该活动设置为应用程序的主要入口点和启动器，使得应用启动时直接进入 `FrameLayoutActivity`。这样，清单文件配置了应用的初始界面和入口行为。
   
   5. **运行测试：**
   
      编译并运行应用，你将看到一个带有两个按钮的界面。点击 "Switch Image" 按钮，可以切换显示的图片，点击 "Reset Image" 按钮，可以重置图片为初始状态。运行结果截图如下所示：
   
      ![笔记-五大布局的使用中帧布局运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%B8%A7%E5%B8%83%E5%B1%80%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)
   
      由上面的运行结果我们可知点击 "Switch Image" 按钮成功实现了图片切换的操作，点击 "Reset Image" 按钮，成功实现了重置图片的操作。
   
4. **表格布局（TableLayout）：**
   
   在Android开发中，`TableLayout` 是一种布局容器，用于以表格形式排列子视图。它包含多个 `TableRow`，每个 `TableRow` 包含多个 `View`，这些 `View` 通常是 `TextView`、`Button` 或其他视图组件。以下是使用 `TableLayout` 的基本步骤：
   
   1. **在XML布局文件中定义TableLayout：**
      在你的布局文件（通常是 `res/layout/activity_main.xml`）中，使用 `<TableLayout>` 标签定义一个表格布局。可以在 `TableLayout` 中包含多个 `TableRow`。
   
      ```xml
      <TableLayout
          android:id="@+id/tableLayout"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:stretchColumns="*"
          android:shrinkColumns="*">
          
          <!-- TableRows and Views go here -->
          
      </TableLayout>
      ```
   
      - `android:stretchColumns` 和 `android:shrinkColumns` 属性用于指定哪些列应该拉伸和收缩以适应布局的宽度。
   
   2. **在TableLayout中添加TableRow：**
      在 `TableLayout` 中，每个 `TableRow` 代表表格中的一行。在每个 `TableRow` 中，添加 `View` 组件作为单元格。
   
      ```xml
      <!-- First TableRow -->
      <TableRow>
          <TextView
              android:text="Cell 1"
              android:padding="10dp"/>
          <TextView
              android:text="Cell 2"
              android:padding="10dp"/>
      </TableRow>
      
      <!-- Second TableRow -->
      <TableRow>
          <TextView
              android:text="Cell 3"
              android:padding="10dp"/>
          <TextView
              android:text="Cell 4"
              android:padding="10dp"/>
      </TableRow>
      ```
   
      每个 `TextView` 代表一个单元格，你可以根据需要添加其他视图组件。
   
   3. **设置TableRow和View属性：**
      为了更好地控制表格的外观和行为，可以设置 `TableRow` 和 `View` 的属性。例如，你可以设置背景颜色、文字颜色、文字大小等。
   
      ```xml
      <TableRow
          android:background="#CCCCCC"
          android:layout_marginBottom="5dp">
      
          <TextView
              android:text="Header 1"
              android:padding="10dp"
              android:textSize="18sp"
              android:textColor="#333333"/>
      
          <TextView
              android:text="Header 2"
              android:padding="10dp"
              android:textSize="18sp"
              android:textColor="#333333"/>
      </TableRow>
      ```
   
      在这个示例中，`TableRow` 设置了背景颜色和外边距，而 `TextView` 设置了文字大小和颜色。
   
   4. **在Activity中动态添加行和单元格：**
      除了静态地在XML中定义表格外，你还可以在Activity中动态地添加行和单元格。首先，获取`TableLayout`的引用，然后创建`TableRow`和`View`并将它们添加到`TableLayout`中。
   
      ```java
      TableLayout tableLayout = findViewById(R.id.tableLayout);
      
      TableRow tableRow = new TableRow(this);
      
      TextView cell1 = new TextView(this);
      cell1.setText("Dynamic Cell 1");
      cell1.setPadding(10, 10, 10, 10);
      
      TextView cell2 = new TextView(this);
      cell2.setText("Dynamic Cell 2");
      cell2.setPadding(10, 10, 10, 10);
      
      tableRow.addView(cell1);
      tableRow.addView(cell2);
      
      tableLayout.addView(tableRow);
      ```
   
      这段代码创建了一个新的`TableRow`，在其中添加了两个`TextView`，然后将整个`TableRow`添加到`TableLayout`中。
   
      下面我们通过一个例子来介绍一下表格布局，如下：
   
      1. **在XML布局文件中定义TableLayout：**
   
         在 `src/res/layout` 文件夹下创建一个 XML 布局文件（例如 `activity_table_layout.xml`），使用 `TableLayout` 声明布局结构：
   
      ```xml
      <?xml version="1.0" encoding="utf-8"?>
      <TableLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/tableLayout"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:stretchColumns="*"
          android:shrinkColumns="*">
      
          <!-- 表头 -->
          <TableRow
              android:background="#3489db"   <!-- 设置表头背景颜色为深蓝色 -->
              android:layout_marginBottom="5dp">
      
              <!-- 第一列：学生姓名 -->
              <TextView
                  android:text="学生姓名"
                  android:padding="10dp"   <!-- 设置文字与单元格边缘的内边距 -->
                  android:textSize="18dp"   <!-- 设置文字大小为18dp -->
                  android:textColor="#ffffff"   <!-- 设置文字颜色为白色 -->
                  android:gravity="center"/>   <!-- 设置文字居中对齐 -->
      
              <!-- 第二列：年龄 -->
              <TextView
                  android:text="年龄"
                  android:padding="10dp"
                  android:textSize="18sp"   <!-- 使用sp作为文字大小的单位，适应不同屏幕的密度 -->
                  android:textColor="#ffffff"
                  android:gravity="center"/>
      
              <!-- 第三列：成绩 -->
              <TextView
                  android:text="成绩"
                  android:padding="10dp"
                  android:textSize="18sp"
                  android:textColor="#ffffff"
                  android:gravity="center"/>
      
          </TableRow>
      
          <!-- 数据行将动态添加 -->
      
      </TableLayout>
      ```
      
      2. **在TableLayoutActivity中动态添加数据行：**
   
      在`src/main/java/com/cfk/layoutstudy/activity/TableLayoutActivity.java` 文件中添加数据行，代码如下：
   
      ```java
      // TableLayoutActivity.java
      
      import android.os.Bundle;
      import android.widget.TableLayout;
      import android.widget.TableRow;
      import android.widget.TextView;
      
      import androidx.appcompat.app.AppCompatActivity;
      
      public class TableLayoutActivity extends AppCompatActivity {
      
          @Override
          protected void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.activity_main);
      
              // 获取TableLayout的引用
              TableLayout tableLayout = findViewById(R.id.tableLayout);
      
              // 示例数据（替换为实际数据）
              String[][] studentData = {
                      {"约翰·杜", "21", "A"},
                      {"简·史密斯", "22", "B+"},
                      {"鲍勃·约翰逊", "20", "A-"},
                      {"爱丽丝·布朗", "23", "B"},
                      {"查理·怀特", "19", "A+"}
              };
      
              // 动态添加数据行
              for (String[] rowData : studentData) {
                  TableRow tableRow = new TableRow(this);
      
                  for (String data : rowData) {
                      // 创建TextView并设置文本、内边距、文字颜色和居中对齐
                      TextView textView = new TextView(this);
                      textView.setText(data);
                      textView.setPadding(10, 10, 10, 10);
                      textView.setTextColor(getResources().getColor(R.color.text_color));
                      textView.setGravity(android.view.Gravity.CENTER);
      
                      // 将TextView添加到TableRow中
                      tableRow.addView(textView);
                  }
      
                  // 将TableRow添加到TableLayout中
                  tableLayout.addView(tableRow);
              }
          }
      }
      ```
      
      在这个例子中，表头的背景颜色被设置为蓝色 (`#3498db`)，文本颜色为白色 (`#ffffff`)，并使用 `android:gravity="center"` 属性使文本在单元格中居中显示。同时，每个数据行的文本颜色被设置为一个在 `res/values/colors.xml` 文件中定义的颜色资源（`R.color.text_color`）。
   
      确保在你的 `res/values/colors.xml` 文件中添加以下内容：
   
      ```xml
      <!-- res/values/colors.xml -->
      
      <resources>
          <!-- 定义文字颜色的颜色资源 -->
          <color name="text_color">#333333</color>
      </resources>
      ```
      
      **3.在`AndroidManifest.xml`文件中注册`TableLayoutActivity`**：
   
      在`AndroidManifest.xml`文件中注册`TableLayoutActivity`，代码如下：
   
      ```xml
      <?xml version="1.0" encoding="utf-8"?>
      <manifest xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools">
      
          <application
              android:allowBackup="true"   <!-- 允许备份应用数据 -->
              android:dataExtractionRules="@xml/data_extraction_rules"   <!-- 指定数据提取规则 -->
              android:fullBackupContent="@xml/backup_rules"   <!-- 指定完全备份内容规则 -->
              android:icon="@mipmap/ic_launcher"   <!-- 设置应用图标 -->
              android:label="@string/app_name"   <!-- 设置应用名称 -->
              android:roundIcon="@mipmap/ic_launcher_round"   <!-- 设置应用圆形图标 -->
              android:supportsRtl="true"   <!-- 支持RTL（Right To Left）布局 -->
              android:theme="@style/Theme.LayoutStudy"   <!-- 设置应用主题 -->
              tools:targetApi="31">   <!-- 指定目标API版本 -->
      
              <!-- 设置应用的主Activity -->
              <activity android:name=".activity.TableLayoutActivity"
                  android:exported="true"   <!-- 允许其他应用启动此Activity -->
                  tools:ignore="DuplicateActivity">   <!-- 忽略重复的Activity声明 -->
      
                  <!-- 定义启动此Activity的意图过滤器 -->
                  <intent-filter>
                      <action android:name="android.intent.action.MAIN"/>   <!-- 主Action，表示应用启动的主要入口 -->
                      <category android:name="android.intent.category.LAUNCHER"/>   <!-- 主Activity的启动器类别 -->
                  </intent-filter>
              </activity>
          </application>
      
      </manifest>
      ```
      
      **4.运行测试：**
   
      运行该Android应用程序后，你将看到一个简洁的表格界面，其中包含学生的姓名、年龄和成绩信息。顶部为深蓝色的表头显示每列的标题，而数据行则以白色文本在深灰色背景上呈现，文本居中对齐。这个表格是通过XML布局和Java代码动态添加数据而构建的。运行结果截图如下：
   
      ![笔记-五大布局的使用中表格布局运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%AD%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)
   
      由运行结果截图可知，在TableLayoutActivity中成功添加了学生信息到布局中，布局文件也成功展示了学生信息。
   
5. **绝对布局（AbsoluteLayout）：**

   在Android开发中，`AbsoluteLayout` 已经被标记为过时（deprecated），不建议在新的应用程序中使用。过时的意味着官方推荐使用其他布局方式，因为`AbsoluteLayout`存在一些问题，例如在不同屏幕尺寸和密度上可能导致布局错乱。推荐使用更灵活、适应性更强的布局管理器，如`RelativeLayout`、`LinearLayout`、`ConstraintLayout`等。

   不过，下面是简要地介绍一下`AbsoluteLayout` 的基本使用方式，以便你了解。在一个`AbsoluteLayout` 中，子视图的位置是通过指定它们相对于父布局左上角的精确坐标来确定的。

   以下是一个简单的例子：

   ```xml
   <?xml version="1.0" encoding="utf-8"?>
   <!-- 
       AbsoluteLayout 已经被标记为过时，建议使用更灵活的布局管理器，比如 RelativeLayout、LinearLayout 或 ConstraintLayout。
   -->
   <AbsoluteLayout xmlns:android="http://schemas.android.com/apk/res/android"
       android:layout_width="match_parent"
       android:layout_height="match_parent">
   
       <!-- 按钮 1 -->
       <Button
           android:id="@+id/btnOne"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:text="按钮 1"
           
           <!-- 设置按钮 1 相对于父布局左侧的X坐标 -->
           android:layout_x="50dp" 
           
           <!-- 设置按钮 1 相对于父布局顶部的Y坐标 -->
           android:layout_y="50dp"/>
   
       <!-- 按钮 2 -->
       <Button
           android:id="@+id/btnTwo"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:text="按钮 2"
           
           <!-- 设置按钮 2 相对于父布局左侧的X坐标 -->
           android:layout_x="150dp" 
           
           <!-- 设置按钮 2 相对于父布局顶部的Y坐标 -->
           android:layout_y="150dp"/>
   
   </AbsoluteLayout>
   ```

   在这个例子中，我们有两个按钮，分别通过 `android:layout_x` 和 `android:layout_y` 指定它们相对于左上角的位置。请注意，这是一个简单的演示，实际开发中可能会遇到很多问题，尤其是在不同屏幕尺寸和密度上的设备上。运行结果如下：

   ![笔记-五大布局的使用中绝对布局运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BA%94%E5%A4%A7%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%BB%9D%E5%AF%B9%E5%B8%83%E5%B1%80%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

   由上图运行结果可知，两个按钮通过绝对布局（相对于父容器的左上角进行偏移）成功地被放置到了对应的的位置。

   **推荐的替代方案：**
   如果你需要更灵活的布局方式，强烈建议使用其他布局管理器。例如，使用 `RelativeLayout` 可以通过设置子视图之间的相对位置关系来达到类似的效果，而且更加灵活和可维护。

## 11.2 约束布局

**定义：**

约束布局是一种灵活的布局方式，通过在布局中的子视图之间定义约束关系，而不是直接指定视图的位置，来实现界面的排列。每个子视图都会根据与其他视图的约束关系自动调整自己的位置和大小，从而适应不同屏幕尺寸和方向。

**背景与意义：**

- **灵活性：** 约束布局提供了更灵活的方式来定义视图之间的关系，使得开发者能够更容易地适应各种屏幕尺寸和设备方向。
- **性能优势：** 与相对布局和线性布局相比，约束布局在运行时的性能更好。它能够更有效地计算和调整视图的位置，减少了布局层次的嵌套，提高了渲染性能。
- **响应式设计：** 约束布局支持在不同屏幕尺寸和方向下创建响应式的用户界面。通过设置不同的约束条件，可以轻松实现在横向和纵向上的灵活适配。
- **可视化编辑：** Android Studio提供了直观的可视化编辑工具，可以方便地在设计界面中拖动、调整视图，并自动生成相应的约束关系。
- **复杂布局：** 对于需要复杂布局的场景，如嵌套和层叠的布局，约束布局更容易实现，而不需要深度嵌套的视图层次结构。

总体而言，约束布局在Android应用开发中具有重要的地位，它为开发者提供了更多的灵活性和效率，使得应用能够更好地适应不断变化的设备和屏幕环境。

**其它介绍以及使用方法如下。**

### 11.2.1 约束布局和五大布局的比较

在Android开发中，有五大基本布局方式：线性布局（LinearLayout）、相对布局（RelativeLayout）、帧布局（FrameLayout）、表格布局（TableLayout）、和约束布局（ConstraintLayout）。下面是对这些布局方式的详细比较：

**1. 线性布局（LinearLayout）：**
   - **定位方式：** 按照水平或垂直方向排列子视图。
   - **优点：** 简单易用，适用于一维的布局。
   - **缺点：** 对于复杂的二维布局，嵌套多个线性布局可能导致性能问题。

**2. 相对布局（RelativeLayout）：**
   - **定位方式：** 子视图相对于父布局或其他子视图进行定位。
   - **优点：** 灵活，可以实现相对复杂的布局。
   - **缺点：** 嵌套较多时，布局复杂性提高，可能影响性能。

**3. 帧布局（FrameLayout）：**
   - **定位方式：** 子视图堆叠在顶部，后添加的视图覆盖在前面的视图上。
   - **优点：** 简单，适用于叠加效果。
   - **缺点：** 不适合复杂的布局，难以精确控制子视图的位置。

**4. 表格布局（TableLayout）：**
   - **定位方式：** 子视图按行和列组织成表格。
   - **优点：** 适用于二维网格状布局，相对简单。
   - **缺点：** 不够灵活，难以实现某些复杂的布局。

**5. 约束布局（ConstraintLayout）：**

   - **定位方式：** 子视图通过设置彼此之间的约束关系进行定位。
   - **优点：** 灵活，适应性强，性能较好。可视化编辑工具支持快速设计。
   - **缺点：** 学习曲线较陡峭，相对复杂的布局可能需要花费更多的时间。

**比较总结：**
- **灵活性：** 约束布局最灵活，能够处理各种复杂的布局场景。相对布局也较为灵活，但对于一些特殊需求可能稍显不足。
  
- **性能：** 约束布局通常在性能上优于相对布局，特别是在层次结构较深的情况下。线性布局和表格布局适用于简单布局，性能较好。帧布局适用于简单的叠加效果，性能一般。

- **学习曲线：** 约束布局的学习曲线相对较陡，但一旦掌握，可以更高效地实现复杂布局。其他布局方式相对简单，学习成本较低。

- **可视化编辑：** 约束布局在可视化编辑方面有优势，Android Studio提供了直观的可视化工具。其他布局方式的可视化编辑相对简单或者有限。

在选择布局方式时，应根据具体需求和性能考虑做出合适的选择。在大多数情况下，约束布局是一个强大而灵活的选择，特别适合复杂和响应式的界面设计。

### 11.2.2 约束布局的使用

约束布局（ConstraintLayout）是一种灵活且强大的布局方式，用于在Android应用中创建复杂的用户界面。它通过定义视图之间的关系，而不是直接指定它们的位置，来实现灵活的屏幕适配和响应式设计。下面是约束布局的基本使用方法：

**1. 引入依赖**

在项目的`build.gradle`文件中，确保你的应用使用了约束布局库：

```gradle
implementation 'androidx.constraintlayout:constraintlayout:2.1.0'
```

**2. 在XML布局文件中使用约束布局**

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- Your UI elements go here -->

</androidx.constraintlayout.widget.ConstraintLayout>
```

**3. 添加约束**

在`ConstraintLayout`中，每个子视图都被称为一个约束。通过以下方式为视图添加约束：

- **直接在XML中添加约束：**

    ```xml
    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"/>
    ```

- **使用图形编辑器：**

    Android Studio提供了可视化的布局编辑器，你可以通过拖拽视图和箭头来定义约束。

**4. 约束关系**

常用的约束关系有：

- `app:layout_constraintTop_toTopOf`: 将视图的顶部边缘约束到另一个视图或父布局的顶部。
- `app:layout_constraintStart_toStartOf`: 将视图的开始边缘约束到另一个视图或父布局的开始。
- `app:layout_constraintEnd_toEndOf`: 将视图的结束边缘约束到另一个视图或父布局的结束。
- `app:layout_constraintBottom_toBottomOf`: 将视图的底部边缘约束到另一个视图或父布局的底部。
- `app:layout_constraintHorizontal_bias`: 设置水平方向上的偏移。
- `app:layout_constraintVertical_bias`: 设置垂直方向上的偏移。

**5. Chain（链）**

Chain是一组相邻视图的链式关系。可以通过设置`app:layout_constraintHorizontal_chainStyle`和`app:layout_constraintVertical_chainStyle`属性来定义链的样式，如`spread`, `spread_inside`, `packed`等。

**6. 响应式设计**

通过使用百分比约束、宽高比例约束等特性，可以轻松实现屏幕适配和响应式设计。

**7. Guidelines（指南）**

指南是辅助线，用于帮助定位和约束视图。可以通过`app:layout_constraintGuide_percent`属性设置指南的位置。

**8. 在代码中操作约束**

可以在Java或Kotlin代码中获取`ConstraintLayout`中的约束，并动态地设置约束条件。

```java
ConstraintLayout constraintLayout = findViewById(R.id.constraintLayout);
ConstraintSet constraintSet = new ConstraintSet();
constraintSet.clone(constraintLayout);
constraintSet.connect(R.id.button, ConstraintSet.TOP, ConstraintSet.PARENT_ID, ConstraintSet.TOP);
constraintSet.applyTo(constraintLayout);
```

以上只是约束布局的基础，它具有更多强大的功能和属性。建议查阅官方文档以获取更详细的信息：[ConstraintLayout官方文档](https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout)。

下面我们通过一个例子来介绍一下表格布局，如下：

当使用约束布局时，你可以创建一个简单的布局，例如包含一个按钮和一个文本视图。以下是一个详细、形象的约束布局示例：

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
    这个XML布局文件演示了在Android中使用ConstraintLayout的方法。
    它包含一个Button和一个TextView，使用ConstraintLayout垂直排列。

    1. Button（按钮）：
        - 位于ConstraintLayout的顶部。
        - 通过约束连接到父布局的开始、顶部和结束。
        - 位于TextView的上方，带有一定的边距。
        - 显示文本“Click me”。

    2. TextView（文本视图）：
        - 位于Button的下方，带有一定的边距。
        - 通过约束连接到父布局的开始、结束和底部。
        - 显示文本“Hello, ConstraintLayout!”。

    注意：
    - TextView的layout_width设置为0dp，以允许宽度由约束条件确定，确保它在水平方向上填充可用空间。

    - 为了在视图之间添加间距，添加了边距。
-->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- Button -->
    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Click me"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/textView"
        android:layout_marginTop="16dp"
        android:layout_marginEnd="16dp"
        android:layout_marginStart="16dp"
        />

    <!-- TextView -->
    <TextView
        android:id="@+id/textView"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="Hello, ConstraintLayout!"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/button"
        app:layout_constraintBottom_toBottomOf="parent"
        android:layout_marginTop="16dp"
        android:layout_marginEnd="16dp"
        android:layout_marginStart="16dp"
        android:layout_marginBottom="16dp"
        />

</androidx.constraintlayout.widget.ConstraintLayout>
```

在这个例子中：

1. 一个按钮（Button）和一个文本视图（TextView）都被放置在`ConstraintLayout`中。
2. Button 的顶部和文本视图的底部通过约束相互连接，确保它们垂直排列。
3. Button 的开始和结束通过约束连接到父布局的开始和结束，使其水平居中。
4. 文本视图的开始和结束也通过约束连接到父布局的开始和结束，使其水平居中。
5. 通过设置`layout_width`为`0dp`，可以使视图的宽度由约束决定，确保其充满水平方向。
6. 使用`layout_margin`属性来为视图添加一些间距。

这是一个简单的例子，演示了如何使用约束布局创建基本的界面。你可以通过修改这个例子，尝试使用链式约束、指南、百分比约束等高级特性，以适应更复杂的布局需求。

布局代码显示结果如下图所示：

![笔记-约束布局中约束布局使用示例运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80%E4%B8%AD%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

由上面的截图可知，该布局文件成功地使用了约束布局展示了一个按钮（Button）和一个文本视图（TextView）。

# 12 应用资源

**定义：**

应用资源是指应用程序中除了代码之外的各种元素，这些元素以非编程方式为应用提供不同方面的支持。主要类型的资源包括但不限于：

1. **布局资源（Layout Resources）：** 定义应用界面的排列和组织方式，通常使用XML文件来描述。
2. **字符串资源（String Resources）：** 存储应用中使用的文本字符串，使得可以轻松进行本地化和国际化。
3. **图像资源（Drawable Resources）：** 包括图标、图片等可绘制的资源，以不同的分辨率适应不同的设备。
4. **颜色资源（Color Resources）：** 存储应用中使用的颜色值，便于在整个应用中进行一致的颜色管理。
5. **尺寸资源（Dimension Resources）：** 定义应用中的尺寸，以适应不同的屏幕尺寸和分辨率。

**背景与意义：**

1. **适应多设备：** Android设备具有多样化的屏幕尺寸、分辨率和像素密度。通过使用资源，开发者能够创建适应不同设备的用户界面，确保应用在各种设备上都能提供良好的用户体验。
2. **易于维护：** 将不同类型的资源分离到独立的文件中，使得修改和维护变得更加简单。例如，要更改应用的颜色主题，只需修改颜色资源而不用修改整个代码。
3. **本地化和国际化：** 字符串资源的使用使得应用的本地化和国际化变得容易。开发者可以为不同的语言提供不同的字符串资源，使得应用可以在全球范围内更容易地被接受。
4. **提高可读性：** 使用资源可以使代码更加清晰和可读。通过引用资源而不是直接在代码中硬编码数值，代码变得更易于理解和维护。
5. **支持主题定制：** 资源的使用使得应用的外观和感觉可以轻松定制。通过更改颜色、图像等资源，开发者可以创建不同的主题，以满足用户的个性化需求。

综上所述，应用资源在Android开发中扮演着至关重要的角色，它们不仅提高了应用的适应性和可维护性，还为开发者提供了丰富的工具和选项，以创建吸引人、灵活和可扩展的Android应用。

## 12.1 drawable文件夹可自定义文件的种类

在Android开发中，`res/drawable` 文件夹用于存放可绘制资源，这些资源主要包括图像、图标、形状等，用于构建应用的用户界面。`drawable` 文件夹下可以放置各种不同类型的可自定义文件，以满足应用在不同分辨率和屏幕密度下的需求。以下是常见的 drawable 文件夹下可自定义文件的种类：

1. **位图文件（Bitmaps）：**
   - **.png:** Portable Network Graphics 格式，支持透明度，常用于图标、按钮等。
   - **.jpg (或 .jpeg):** Joint Photographic Experts Group 格式，用于照片等不需要透明度的图像。
   - **.gif:** Graphics Interchange Format 格式，支持动画。

2. **矢量图文件（Vector Drawables）：**
   - **.xml:** 使用矢量图形语言描述的可缩放矢量图，通常以 XML 文件格式存在。矢量图形可在不同分辨率下保持清晰度，适用于图标和图形。

3. **图层列表文件（Layer Lists）：**
   - **.xml:** 定义一个图层列表，允许在同一位置上放置多个可绘制对象，以便它们可以叠加在一起。

4. **状态列表文件（State Lists）：**
   - **.xml:** 用于定义在不同状态下（例如按下、选中等）应该显示的可绘制对象。常用于按钮的不同状态。

5. **级联样式表文件（Shape Drawables）：**
   - **.xml:** 通过 XML 描述定义的形状，如矩形、圆形、椭圆等，可用于创建背景、边框等。

6. **.9.png 文件（Nine-Patch）：**
   - **.9.png:** 可拉伸的图像格式，用于在不失真的情况下调整图像大小，尤其适用于背景图。

7. **层级文件（Layer Drawable）：**
   - **.xml:** 包含多个不同可绘制对象的组合，通过 XML 文件指定层次结构。

8. **动画文件（Animation Drawables）：**
   - **.xml:** 用于定义逐帧或补间动画的 XML 文件，可以在可绘制资源中使用，例如图标的渐变、旋转等动画效果。

这些可自定义文件类型允许开发者使用不同的资源文件来适应不同的屏幕分辨率、密度和尺寸，从而提供更好的用户体验。通过合理使用这些 drawable 资源，开发者可以确保应用在各种设备上呈现出优雅且一致的外观。

## 12.2 自定义drawable资源

在Android开发中，自定义`drawable`资源涉及创建自定义的图形、形状或者动画等可绘制对象，以满足应用程序的特定需求。以下是一步一步详细、形象地讲解如何自定义`drawable`资源：

**步骤1：在 `res/drawable` 文件夹下创建 XML 文件**

1. 打开 Android Studio，进入你的项目。
2. 在 `res/drawable` 文件夹（如不存在，手动创建）下新建一个 XML 文件，用于定义自定义 `drawable` 资源。

**步骤2：创建矢量图形（Vector Drawable）**

使用 XML 描述矢量图形。以下是一个例子，创建一个包含矩形和箭头的图形：

```xml
<!-- res/drawable/custom_vector.xml -->

<!-- 
    这是一个矢量图形（Vector Drawable）的 XML 文件，定义了一个包含两个路径的图形：
    1. 一个红色矩形（路径）从 (0,0) 到 (100,0) 到 (100,100) 到 (0,100)，形成一个闭合的矩形。
    2. 一个绿色三角形（路径）从 (50,0) 到 (100,50) 到 (50,100) 到 (0,50)，形成一个闭合的三角形。
-->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="64dp"
    android:height="64dp"
    android:viewportWidth="100"
    android:viewportHeight="100">

    <!-- 路径1：红色矩形 -->
    <path
        android:fillColor="#FF0000" <!-- 填充颜色设置为红色 -->
        android:pathData="M0,0 L100,0 L100,100 L0,100 Z"/> <!-- 使用 SVG 路径数据定义矩形 -->

    <!-- 路径2：绿色三角形 -->
    <path
        android:fillColor="#00FF00" <!-- 填充颜色设置为绿色 -->
        android:pathData="M50,0 L100,50 L50,100 L0,50 Z"/> <!-- 使用 SVG 路径数据定义三角形 -->
</vector>
```

下面是对该段代码的相关介绍：

这段 XML 代码定义了一个矢量图形（Vector Drawable），描述了一个宽高为64dp的图形，其中包含一个红色的矩形和一个绿色的三角形。下面我们详细解释这个 Vector Drawable 的代码结构以及如何使用。

**1. 根元素 - `<vector>`:**
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="64dp"
    android:height="64dp"
    android:viewportWidth="100"
    android:viewportHeight="100">
```
- `<vector>` 是根元素，用于定义矢量图形。
- `xmlns:android="http://schemas.android.com/apk/res/android"` 是命名空间声明，引入 Android XML 命名空间。
- `android:width="64dp"` 和 `android:height="64dp"` 指定了图形的宽度和高度。
- `android:viewportWidth="100"` 和 `android:viewportHeight="100"` 定义了虚拟视口的宽度和高度。

**2. `<path>` 元素 - 矩形:**
```xml
<path
    android:fillColor="#FF0000"
    android:pathData="M0,0 L100,0 L100,100 L0,100 Z"/>
```
- `<path>` 表示一个路径形状。
- `android:fillColor="#FF0000"` 设置路径的填充颜色为红色。
- `android:pathData="M0,0 L100,0 L100,100 L0,100 Z"` 使用 SVG 路径语法定义了路径，从点(0,0) 到 (100,0) 到 (100,100) 到 (0,100) 并闭合，形成一个矩形。

**3. `<path>` 元素 - 三角形:**
```xml
<path
    android:fillColor="#00FF00"
    android:pathData="M50,0 L100,50 L50,100 L0,50 Z"/>
```
- 同样使用 `<path>` 元素表示路径形状。
- `android:fillColor="#00FF00"` 设置路径的填充颜色为绿色。
- `android:pathData="M50,0 L100,50 L50,100 L0,50 Z"` 使用 SVG 路径语法定义了路径，从点(50,0) 到 (100,50) 到 (50,100) 到 (0,50) 并闭合，形成一个三角形。

**使用自定义 Drawable:**
在布局文件或者代码中，可以通过 `@drawable/` 引用自定义的 drawable 资源：

```xml
<!-- 在布局文件中引用自定义 Drawable -->
<ImageView
    android:id="@+id/customImageView"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:src="@drawable/custom_vector" />

<!-- 或者在代码中设置 -->
ImageView imageView = findViewById(R.id.customImageView);
imageView.setImageResource(R.drawable.custom_vector);
```

这样，你就可以在应用中使用这个自定义的矢量图形。矢量图形的优势在于其可缩放性，适应不同屏幕密度和尺寸的设备，同时保持清晰度和质量。

上面的代码显示结果如下图所示：

![笔记-自定义drawable资源中自定义矢量图形示例运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89drawable%E8%B5%84%E6%BA%90%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%BD%A2%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

由上图可知，上面的代码成功地绘制出了一个红色的矩形和一个绿色的三角形。

**步骤3：创建层列表（Layer List）**

使用层列表在同一位置上放置多个可绘制对象。以下是一个例子，创建一个有两层的图形：

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- 
    这是一个层列表（Layer List）Drawable的XML文件。
    它定义了一个包含两个图层的可绘制对象：一个绿色矩形和一个带有10dp内边距的蓝色矩形。
-->

<layer-list xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- 图层1：绿色矩形 -->
    <item>
        <shape android:shape="rectangle">
            <solid android:color="#00ff00"/> <!-- 填充颜色设置为绿色 -->
        </shape>
    </item>

    <!-- 图层2：带有内边距的蓝色矩形 -->
    <item 
        android:top="10dp" 
        android:right="10dp" 
        android:left="10dp" 
        android:bottom="10dp">
        <shape android:shape="rectangle">
            <solid android:color="#0000FF"/> <!-- 填充颜色设置为蓝色 -->
        </shape>
    </item>

</layer-list>
```

下面是对该段代码的介绍：

当涉及到 Android 层列表（Layer List）Drawable的 XML 文件时，可以分为两个主要部分来解释，即 XML 文件结构和层列表的使用。

**XML文件结构：**

**1. XML文件声明：**

```xml
<?xml version="1.0" encoding="utf-8"?>
```

这是 XML 文件的声明，指定 XML 版本和编码方式。

**2. 根元素：**

```xml
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
```

`<layer-list>` 是根元素，用于定义层列表。`xmlns:android` 指定了 XML 文件的命名空间。

**3. 图层1：绿色矩形：**

```xml
<item>
    <shape android:shape="rectangle">
        <solid android:color="#00ff00"/> <!-- 填充颜色设置为绿色 -->
    </shape>
</item>
```

- `<item>` 表示层列表中的一个图层。
- `<shape android:shape="rectangle">` 定义一个形状为矩形的可绘制对象。
- `<solid android:color="#00ff00"/>` 设置绿色矩形的填充颜色。

**4. 图层2：带有内边距的蓝色矩形：**

```xml
<item 
    android:top="10dp" 
    android:right="10dp" 
    android:left="10dp" 
    android:bottom="10dp">
    <shape android:shape="rectangle">
        <solid android:color="#0000FF"/> <!-- 填充颜色设置为蓝色 -->
    </shape>
</item>
```

- `<item>` 表示第二个图层，带有上、右、左、下的内边距。
- `<shape android:shape="rectangle">` 定义一个形状为矩形的可绘制对象。
- `<solid android:color="#0000FF"/>` 设置蓝色矩形的填充颜色。

**5. 根元素的闭合：**

```xml
</layer-list>
```

**层列表的使用：**

在 Android 开发中，你可以将上述 XML 文件用作可绘制对象，并将其应用于视图（View）。例如，你可以在布局文件中使用 `android:background` 属性引用这个层列表：

```xml
<ImageView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/your_layer_list_drawable"/>
```

这里 `@drawable/your_layer_list_drawable` 是指向你的层列表 XML 文件的引用。这样，ImageView 将显示层列表中定义的图层效果，即绿色矩形和带有内边距的蓝色矩形叠加在一起的效果。

上面的代码显示结果如下图所示：

![笔记-自定义drawable资源中自定义层列表示例运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89drawable%E8%B5%84%E6%BA%90%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%82%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

由上图可知，该段代码成功展示了绿色矩形和带有内边距的蓝色矩形叠加效果。

**步骤4：创建形状（Shape）**

直接创建单个形状，例如一个圆形：

```xml
<!-- res/drawable/custom_shape.xml -->

<!-- 
    这是一个定义椭圆形状的可绘制对象的XML文件。
    它使用<shape>元素指定形状为椭圆（oval）。
    椭圆的填充颜色被设置为紫色（#FF00FF）。
-->

<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="#FF00FF"/> <!-- 设置填充颜色为紫色 -->
</shape>
```

下面是对该段代码的介绍：

这段 XML 代码定义了一个形状（Shape）为椭圆（oval）的可绘制对象。下面逐一解释这个 XML 文件的结构和形状的使用：

**XML文件结构：**

```xml
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="#FF00FF"/> <!-- 设置填充颜色为紫色 -->
</shape>
```

1. **根元素 (`<shape>`)：**

   - `<shape>` 元素是定义可绘制对象形状的根元素。
   - `xmlns:android="http://schemas.android.com/apk/res/android"` 表示 XML 命名空间，其中定义了 Android 特定的 XML 属性。
   - `android:shape="oval"` 指定了形状为椭圆。

2. **形状属性 (`android:shape="oval"`)：**

   - `android:shape` 属性指定可绘制对象的形状，这里是椭圆。

3. **填充颜色 (`<solid android:color="#FF00FF"/>`)：**
   - `<solid>` 元素用于指定形状的填充颜色。
   - `android:color="#FF00FF"` 设置填充颜色为紫色。

**形状的使用：**

在 Android 开发中，你可以将这个 XML 文件用作可绘制对象，并将其应用于视图（View）或其他可接受可绘制对象的 UI 元素。例如，在布局文件中使用 `android:background` 属性引用这个形状：

```xml
<ImageView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/custom_shape"/>
```

这里 `@drawable/custom_shape` 是指向你的形状 XML 文件的引用。这样，ImageView 将显示一个紫色的椭圆形状。形状可用于背景、边框等各种 UI 元素。

上面的代码显示结果如下图所示：

![笔记-自定义drawable资源中自定义形状示例运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89drawable%E8%B5%84%E6%BA%90%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A2%E7%8A%B6%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

由上面的图片可知，该段代码成功地显示出了一个紫色的椭圆形状。

**步骤5：创建状态列表（State List）**

使用状态列表根据不同状态显示不同的 Drawable。以下是一个例子，创建一个在按下时颜色变化的按钮：

```xml
<!-- res/drawable/custom_state_list.xml -->
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- 当视图处于按下状态时 -->
    <item android:state_pressed="true">
        <!-- 使用矩形形状的图形 -->
        <shape android:shape="rectangle">
            <!-- 设置按下状态的背景颜色为红色 -->
            <solid android:color="#FF0000"/>
        </shape>
    </item>

    <!-- 默认状态 -->
    <item>
        <!-- 使用矩形形状的图形 -->
        <shape android:shape="rectangle">
            <!-- 设置默认状态的背景颜色为绿色 -->
            <solid android:color="#00FF00"/>
        </shape>
    </item>
</selector>
```

下面是对该段代码的介绍：

这段XML代码是用于创建Android中状态列表（State List）的XML文件。状态列表允许你为不同的视图状态定义不同的外观，例如按下状态、选中状态等。在这个例子中，我们定义了一个简单的状态列表，根据按下状态改变矩形的颜色。

让我们来详细解释这个XML文件的结构以及如何使用它：

1. **根元素：**
   ```xml
   <selector xmlns:android="http://schemas.android.com/apk/res/android">
   ```
   - `selector` 是根元素，指定这是一个状态列表XML文件。
   - `xmlns:android` 是一个命名空间声明，指定了使用Android资源的XML文件命名空间。

2. **状态项（Items）：**
   ```xml
   <item android:state_pressed="true">
       <!-- Pressed State -->
       <shape android:shape="rectangle">
           <solid android:color="#FF0000"/>
       </shape>
   </item>
   <item>
       <!-- Default State -->
       <shape android:shape="rectangle">
           <solid android:color="#00FF00"/>
       </shape>
   </item>
   ```
   - `<item>` 元素定义了一个状态项，其中 `android:state_pressed="true"` 表示按下状态。
   - 在按下状态下，使用红色 (#FF0000) 的矩形作为形状。
   - 第二个 `<item>` 是默认状态，即没有特定状态时的样式。
   - 在默认状态下，使用绿色 (#00FF00) 的矩形作为形状。

3. **形状定义（Shape）：**
   ```xml
   <shape android:shape="rectangle">
       <solid android:color="#FF0000"/>
   </shape>
   ```
   - `<shape>` 元素定义了矩形形状。
   - `<solid>` 元素定义了形状的填充颜色。

4. **使用：**
   你可以将这个状态列表XML文件应用到一个视图（例如按钮）的背景属性中，以使其根据不同的状态显示不同的外观。

   ```xml
   <Button
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:text="Click me"
       android:background="@drawable/custom_state_list"/>
   ```
   - `@drawable/custom_state_list` 是引用上述状态列表XML文件的方式。

通过这个状态列表XML文件，你可以定义在按钮被按下时和默认状态下的不同颜色，以改变按钮的外观。这是Android中利用状态列表实现视图状态变化的简单示例。

上面的代码显示结果如下图所示：

![笔记-自定义drawable资源中自定义状态列表示例运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89drawable%E8%B5%84%E6%BA%90%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

由上图可知，该段代码成功实现了在按钮被按下时和默认状态下的不同颜色功能。

**步骤6：创建旋转动画（Rotate Animation）**

定义一个 XML 文件创建旋转动画。例如：

```xml
<!-- res/anim/custom_rotate.xml -->

<!-- 
    此XML文件定义了一个用于Android应用程序的旋转动画。
    
    - xmlns:android：指定Android XML命名空间。
    
    - <rotate>：根元素，表示旋转动画。
    
        - android:fromDegrees：旋转的起始角度，以度为单位。在这里，设置为0度。
        
        - android:toDegrees：旋转的结束角度，以度为单位。在这里，设置为360度，表示完整的旋转。
        
        - android:pivotX：旋转的中心点的X坐标。在这里，设置为"50%"，表示视图的中心。
        
        - android:pivotY：旋转的中心点的Y坐标。在这里，设置为"50%"，表示视图的中心。
        
        - android:duration：旋转的持续时间，以毫秒为单位。在这里，设置为1000毫秒（1秒）。
        
        - android:repeatCount：动画应重复的次数。在这里，设置为"infinite"，使旋转持续进行。

-->

<rotate xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromDegrees="0"
    android:toDegrees="360"
    android:pivotX="50%"
    android:pivotY="50%"
    android:duration="1000"
    android:repeatCount="infinite" />
```

下面是对该段代码的介绍：

上面提供的代码片段是一个用于在Android应用中创建旋转动画的XML文件。让我们逐行解释这个XML文件的结构以及如何使用它。

```xml
<!-- res/anim/custom_rotate.xml -->
```

这一行是注释，用于提供文件的路径和说明。在Android项目中，通常将动画资源文件放置在`res/anim/`目录下。

```xml
<rotate xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromDegrees="0"
    android:toDegrees="360"
    android:pivotX="50%"
    android:pivotY="50%"
    android:duration="1000"
    android:repeatCount="infinite" />
```

这是定义旋转动画的主要部分。以下是对每个属性的详细解释：

- `<rotate>`: 这是根元素，表示这是一个旋转动画。
- `xmlns:android="http://schemas.android.com/apk/res/android"`: 定义了XML文件中使用的命名空间，通常用于Android属性。
- `android:fromDegrees="0"`: 指定旋转动画的起始角度，这里是0度。
- `android:toDegrees="360"`: 指定旋转动画的结束角度，这里是360度，即一圈。
- `android:pivotX="50%"`和`android:pivotY="50%"`: 定义旋转的中心点的位置。这里是以视图的中心为旋转中心，分别在X和Y方向上的位置都是视图的50%。
- `android:duration="1000"`: 定义动画的持续时间，这里是1000毫秒，即1秒。
- `android:repeatCount="infinite"`: 指定动画的重复次数，这里设置为无限循环。

如何在Android应用中使用这个动画呢？你可以在代码中使用`AnimationUtils`类加载这个XML文件，并将其应用于视图元素。以下是一个简单的示例：

```java
// 在你的Activity或Fragment中
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.ImageView;

// ...

// 获取旋转动画
Animation rotateAnimation = AnimationUtils.loadAnimation(this, R.anim.custom_rotate);

// 获取要应用动画的视图元素（这里假设是一个ImageView）
ImageView imageView = findViewById(R.id.imageView);

// 应用动画
imageView.startAnimation(rotateAnimation);
```

在这个例子中，`R.anim.custom_rotate`指定了动画资源的引用，它会加载`res/anim/custom_rotate.xml`文件中定义的动画。然后，通过`startAnimation`方法将动画应用到相应的`ImageView`上。

**步骤7：使用自定义 Drawable**

在布局文件或代码中，通过 `@drawable/` 引用自定义的 drawable 资源或者在代码中设置：

```xml
<!-- 在布局文件中引用自定义 Drawable -->
<ImageView
    android:id="@+id/customImageView"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:src="@drawable/custom_vector" />
```

```java
<!-- 或者在代码中设置 -->
ImageView imageView = findViewById(R.id.customImageView);
imageView.setImageResource(R.drawable.custom_layer_list);
```

通过这些步骤，你可以更详细地了解如何创建和使用各种类型的自定义 drawable 资源，以满足应用程序的特定需求。

下面我们创建一个综合的例子来说明如何进行自定义drawable资源：

我们将创建一个简单的用户界面，其中包括一个按钮和一个ImageView。按钮用于切换ImageView的背景，而ImageView的背景将根据按钮的不同状态显示不同的自定义drawable资源。

好的，让我们综合之前的代码，创建一个包含多个自定义drawable资源的示例。我们将创建一个简单的用户界面，其中包括一个按钮和一个ImageView。按钮用于切换ImageView的背景，而ImageView的背景将根据按钮的不同状态显示不同的自定义drawable资源。

**1. 创建矢量图形（Vector Drawable）**

在 `res/drawable` 文件夹下创建 `custom_vector.xml` 文件，代码如下：

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="64dp"                <!-- 设置矢量图的宽度为64dp -->
    android:height="64dp"               <!-- 设置矢量图的高度为64dp -->
    android:viewportWidth="100"         <!-- 设置视图坐标系的宽度为100 -->
    android:viewportHeight="100">       <!-- 设置视图坐标系的高度为100 -->

    <!--路径1：红色矩形-->
    <path
        android:fillColor="#FF0000"     <!-- 设置填充颜色为红色 -->
        android:pathData="M0,0 L100,0 L100,100 L0,100 Z"/> <!-- 定义矩形的路径，从左上角到右上角到右下角再到左下角形成一个闭合路径 -->

    <!--路径2：绿色三角形-->
    <path
        android:fillColor="#00FF00"     <!-- 设置填充颜色为绿色 -->
        android:pathData="M50,0 L100,50 L50,100 L0,50 Z"/> <!-- 定义三角形的路径，从中上点到右下点到中下点再到左上点形成一个闭合路径 -->

</vector>
```

**2. 创建层列表（Layer List）**

在 `res/drawable` 文件夹下创建 `custom_layer_list.xml` 文件，代码如下：

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="64dp"                <!-- 设置矢量图的宽度为64dp -->
    android:height="64dp"               <!-- 设置矢量图的高度为64dp -->
    android:viewportWidth="100"         <!-- 设置视图坐标系的宽度为100 -->
    android:viewportHeight="100">       <!-- 设置视图坐标系的高度为100 -->

    <!--路径1：红色矩形-->
    <path
        android:fillColor="#FF0000"     <!-- 设置填充颜色为红色 -->
        android:pathData="M0,0 L100,0 L100,100 L0,100 Z"/> <!-- 定义矩形的路径，从左上角到右上角到右下角再到左下角形成一个闭合路径 -->

    <!--路径2：绿色三角形-->
    <path
        android:fillColor="#00FF00"     <!-- 设置填充颜色为绿色 -->
        android:pathData="M50,0 L100,50 L50,100 L0,50 Z"/> <!-- 定义三角形的路径，从中上点到右下点到中下点再到左上点形成一个闭合路径 -->

</vector>
```

**3. 创建形状（Shape）**

在 `res/drawable` 文件夹下创建 `custom_shape.xml` 文件，代码如下：

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:shape="line"                     <!-- 定义形状为线 -->
    tools:ignore="ExtraText">                <!-- 工具忽略额外的文本 -->

    <stroke android:width="4dp"              <!-- 设置描边的宽度为4dp -->
        android:color="#00FF00"/>            <!-- 设置描边的颜色为绿色 -->

</shape>
```

**4. 创建状态列表（State List）**

在 `res/drawable` 文件夹下创建 `custom_state_list.xml` 文件，代码如下：

```xml
<!-- res/drawable/button_custom_background.xml -->

<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- 当按钮处于按下状态时 -->
    <item android:state_pressed="true">
        <!-- 使用矩形形状的图形 -->
        <shape android:shape="rectangle">
            <!-- 设置按下状态的背景颜色为深蓝色 -->
            <solid android:color="#033C68"/>
            <!-- 添加圆角边角，圆角半径为12dp -->
            <corners android:radius="12dp"/>
        </shape>
    </item>

    <!-- 默认状态 -->
    <item>
        <!-- 使用矩形形状的图形 -->
        <shape android:shape="rectangle">
            <!-- 设置默认状态的背景颜色为浅蓝色 -->
            <solid android:color="#03A9F4"/>
            <!-- 添加圆角边角，圆角半径为12dp -->
            <corners android:radius="12dp"/>
        </shape>
    </item>

</selector>
```

**5. 创建旋转动画（Rotate Animation）**

在 `res/anim` 文件夹下创建 `custom_rotate.xml` 文件，代码如下：

```xml
<!-- res/anim/rotation_animation.xml -->

<rotate
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromDegrees="0"             <!-- 起始旋转角度为0度 -->
    android:toDegrees="360"             <!-- 终止旋转角度为360度，即一圈 -->
    android:pivotX="50%"                <!-- 旋转轴的X坐标相对于图形宽度的百分比，这里是居中 -->
    android:pivotY="50%"                <!-- 旋转轴的Y坐标相对于图形高度的百分比，这里是居中 -->
    android:duration="2000"             <!-- 旋转动画的持续时间为2000毫秒 -->
    android:repeatCount="infinite"/>    <!-- 重复次数，这里设置为无限循环 -->
```

**6. 在布局文件中使用**

在你的布局文件中，创建 `activity_main.xml`，代码如下：

```xml
<!-- res/layout/activity_main.xml -->

<!--
    RelativeLayout：相对布局，用于放置按钮和ImageView
    android:layout_width="match_parent"：宽度与父布局相同
    android:layout_height="match_parent"：高度与父布局相同
    android:padding="16dp"：设置内边距为16dp
-->
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp">

    <!--
        Button：按钮控件
        android:id="@+id/changeBackgroundButton"：设置按钮的ID为changeBackgroundButton
        android:layout_width="wrap_content"：宽度自适应内容
        android:layout_height="wrap_content"：高度自适应内容
        android:text="Change Background"：按钮显示的文本为"Change Background"
        android:layout_centerHorizontal="true"：水平居中
        android:background="@drawable/button_state_list"：按钮的背景使用@drawable/button_state_list定义的状态列表
    -->
    <Button
        android:id="@+id/changeBackgroundButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Change Background"
        android:layout_centerHorizontal="true"
        android:background="@drawable/button_state_list"/>

    <!--
        ImageView：图片显示控件
        android:id="@+id/customImageView"：设置ImageView的ID为customImageView
        android:layout_width="200dp"：宽度为200dp
        android:layout_height="200dp"：高度为200dp
        android:layout_below="@+id/changeBackgroundButton"：位于changeBackgroundButton的下方
        android:layout_marginTop="80dp"：上边距为80dp
        android:layout_centerHorizontal="true"：水平居中
    -->
    <ImageView
        android:id="@+id/customImageView"
        android:layout_width="200dp"
        android:layout_height="200dp"
        android:layout_below="@+id/changeBackgroundButton"
        android:layout_marginTop="80dp"
        android:layout_centerHorizontal="true"/>
</RelativeLayout>
```

**7. 在Activity中应用**

在你的Activity中，创建 `MainActivity.java`文件，代码如下：

```java
package com.cfk.customdrawableresourcegeneralexample.activity;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.os.Bundle;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.Button;
import android.widget.ImageView;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

import com.cfk.customdrawableresourcegeneralexample.R;

public class MainActivity extends AppCompatActivity {
    private ImageView customImageView;
    private int currentBackgroundIndex = 0;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 获取ImageView实例
        customImageView = findViewById(R.id.customImageView);

        // 获取按钮实例
        Button changeBackgroundButton = findViewById(R.id.changeBackgroundButton);

        // 设置按钮背景为状态列表
        changeBackgroundButton.setBackgroundResource(R.drawable.button_state_list);

        // 设置按钮点击事件
        changeBackgroundButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 切换背景
                switchBackground();
            }
        });
    }

    private void switchBackground() {
        // 获取背景资源数组
        int[] backgrounds = {R.drawable.custom_vector, R.drawable.custom_layer_list, R.drawable.custom_shape};

        // 加载旋转动画
        Animation rotateAnimation = AnimationUtils.loadAnimation(this, R.anim.custom_rotate);

        // 应用旋转动画
        customImageView.startAnimation(rotateAnimation);

        // 计算下一个背景资源的索引
        currentBackgroundIndex = (currentBackgroundIndex + 1) % backgrounds.length;

        // 创建ObjectAnimator，实现背景透明化的变化
        ObjectAnimator animator = ObjectAnimator.ofFloat(customImageView, "alpha", 1f, 0f);
        animator.setDuration(500); // 设置动画时长

        // 设置动画监听器，在动画结束时切换背景资源和重置透明度
        animator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                super.onAnimationEnd(animation);
                customImageView.setImageResource(backgrounds[currentBackgroundIndex]);
                ObjectAnimator.ofFloat(customImageView, "alpha", 0f, 1f).setDuration(500).start();
            }
        });

        // 启动动画
        animator.start();
    }
}
```

**8.在`AndroidManifest.xml`文件中注册**

在`AndroidManifest.xml`文件中注册MainActivity活动，代码如下：

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:allowBackup="true"                             <!-- 允许备份 -->
        android:dataExtractionRules="@xml/data_extraction_rules"  <!-- 指定数据提取规则 -->
        android:fullBackupContent="@xml/backup_rules"            <!-- 指定完全备份规则 -->
        android:icon="@mipmap/ic_launcher"                        <!-- 设置应用图标 -->
        android:label="@string/app_name"                          <!-- 设置应用标签 -->
        android:roundIcon="@mipmap/ic_launcher_round"             <!-- 设置圆形图标 -->
        android:supportsRtl="true"                                <!-- 支持RTL布局 -->
        android:theme="@style/Theme.CustomDrawableResourceGeneralExample"  <!-- 设置应用主题 -->
        tools:targetApi="31">                                      <!-- 指定工具使用的目标API版本 -->

        <!-- 设置应用的主活动 -->
        <activity android:name=".activity.MainActivity"
            android:exported="true">                             <!-- 设置活动是否允许其他应用调用 -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>

</manifest>
```

这个示例中，我们创建了一个包含按钮和ImageView的简单布局。通过点击按钮（按钮按下时会有背景颜色的变化），我们可以切换ImageView的背景，同时ImageView的背景还将拥有旋转动画效果。

**9.运行测试**

运行上述程序，运行结果截图如下：

![笔记-自定义drawable资源综合示例运行结果.gif](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89drawable%E8%B5%84%E6%BA%90%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.gif)

由上图可知，当按钮按下时，按钮背景颜色出现了变化，同时点击按钮也成功实现了北京切换的效果，各个背景也都包含着旋转动画的效果。

# 13 View

**定义：**

**View（视图）** 是 Android 中用于构建用户界面的基本元素之一。它是一个抽象类，用于表示屏幕上的可见元素。所有的用户界面元素，如按钮、文本框、图像等，都是 View 的子类。

**背景与意义：**

- **界面元素**：View 是 Android 应用程序中可见界面元素的基础。它可以是简单的按钮、文本框，也可以是复杂的自定义控件。

- **层次结构**：View 组成了一个层次结构，被组织成一个树状结构，称为 View Hierarchy。每个 View 都有一个唯一的标识符，即资源ID，用于在代码中引用。
- **事件处理**：View 可以响应用户的输入事件，如点击、滑动等。通过设置监听器，可以在特定事件发生时执行相应的操作，从而实现用户交互。
- **布局管理**：View 在布局中占据一定的空间，并通过布局管理器（如 LinearLayout、RelativeLayout）来决定其在屏幕上的位置和大小。
- **自定义视图**：开发者可以通过继承 View 类来创建自定义的视图组件，以满足特定的设计和功能需求。
- **视图组合**：多个 View 可以组合在一起形成一个复杂的界面。这种组合的方式允许开发者构建灵活而强大的用户界面。

总的来说，View 在安卓开发中具有重要的地位，它不仅仅是用户界面的基础构建块，还提供了丰富的功能和灵活性，使开发者能够创建各种各样交互丰富、美观的移动应用程序。

**其他介绍及使用方法如下。**

## 13.1 ListView

### 13.1.1 ListView的介绍

**定义：**

**ListView（列表视图）** 是 Android 中用于显示一系列垂直滚动的数据项的组件。它允许用户在屏幕上垂直滚动，以查看和选择列表中的各个项目。ListView 可以显示文本、图像等任何类型的 View。

**背景与意义：**

- **数据展示**：ListView 是用于展示大量数据的有效方式，尤其适用于需要滚动浏览的情境。通过适配器（Adapter），可以将数据源绑定到 ListView，实现动态加载和显示列表项。
- **优化性能**：ListView 采用了视图回收机制，只在屏幕上显示可见区域的列表项，避免了一次性加载整个列表的开销，提高了应用性能。
- **用户交互**：ListView 提供了对列表项的点击、长按等用户交互事件的支持，开发者可以通过设置相应的监听器来处理用户的操作，实现与列表中数据的交互。
- **自定义布局**：开发者可以通过自定义适配器和列表项的布局，实现不同类型的列表项显示，从而创建具有灵活性和个性化的列表。
- **多种模式**：ListView 支持单一选择、多项选择等多种选择模式，使其适用于各种应用场景，如联系人列表、商品展示等。
- **适配器模式**：通过适配器模式，ListView 实现了数据和视图的分离，使得数据的变化不影响界面的显示，提高了代码的可维护性。

总体而言，ListView 在安卓开发中是一个重要的界面元素，为开发者提供了一种方便、高效、可定制的方式来展示和交互大量数据，是构建移动应用中常见列表功能的核心组件。

**使用方法如下。**

### 13.1.2 ListView的使用

ListView 在 Android 开发中是用于显示滚动列表的常见组件。下面详细讲解如何使用 ListView，包括创建布局文件、准备数据、创建适配器和设置监听器等步骤。

**1. 创建布局文件（activity_main.xml）**

首先，在 `res/layout` 目录下创建一个 XML 文件，用于定义包含 ListView 的布局。

```xml
<!-- activity_main.xml -->
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingLeft="16dp"
    android:paddingTop="16dp"
    android:paddingRight="16dp"
    android:paddingBottom="16dp"
    tools:context=".MainActivity">

    <ListView
        android:id="@+id/listView"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</RelativeLayout>
```

**2. 准备数据**

在 `MainActivity.java` 中准备一些数据，例如一个字符串数组。

```java
// MainActivity.java
import android.os.Bundle;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 准备数据
        String[] data = {"Item 1", "Item 2", "Item 3", "Item 4", "Item 5"};

        // 获取 ListView 实例
        ListView listView = findViewById(R.id.listView);

        // 创建适配器
        ArrayAdapter<String> adapter = new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, data);

        // 设置适配器
        listView.setAdapter(adapter);
    }
}
```

**3. 创建适配器**

在上述代码中，通过 `ArrayAdapter` 创建了一个简单的适配器，并将数据和默认的列表项布局 `android.R.layout.simple_list_item_1` 关联起来。实际应用中，你可以创建自定义的适配器以实现更复杂的布局。

**4. 设置监听器**

如果需要响应用户的点击事件，可以设置 `OnItemClickListener` 监听器。

```java
// MainActivity.java
import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 准备数据
        String[] data = {"Item 1", "Item 2", "Item 3", "Item 4", "Item 5"};

        // 获取 ListView 实例
        ListView listView = findViewById(R.id.listView);

        // 创建适配器
        ArrayAdapter<String> adapter = new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, data);

        // 设置适配器
        listView.setAdapter(adapter);

        // 设置点击事件监听器
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // 处理点击事件
                String selectedItem = (String) parent.getItemAtPosition(position);
                Toast.makeText(MainActivity.this, "Clicked: " + selectedItem, Toast.LENGTH_SHORT).show();
            }
        });
    }
}
```

这里使用 `Toast` 来显示点击的项，你可以根据实际需求执行其他操作。

以上是一个简单的 ListView 使用示例。在实际开发中，可能会涉及到更复杂的数据结构和自定义布局，但这个例子提供了一个基本的框架，可以帮助你理解如何在 Android 应用中使用 ListView 来展示数据。

下面看一个具体的实例来演示ListView的使用：

好的，我们来创建一个更具体、形象的例子，假设我们要展示一个简单的联系人列表。每个联系人有姓名和电话号码，点击列表项时会显示一个 Toast 提示该联系人的电话号码。

**1. 创建布局文件（activity_main.xml）**

```xml
<!-- res/layout/activity_main.xml -->
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".activity.MainActivity">

    <!--
        ConstraintLayout 是 Android 中用于灵活布局的 ViewGroup。
        这里的布局包含一个 ConstraintLayout，其中包含一个 ListView。

        ListView 的宽度和高度都设置为 0dp，这是 ConstraintLayout 的特性。
        app:layout_constraintBottom_toBottomOf="parent" 将底部约束到父布局的底部。
        app:layout_constraintEnd_toEndOf="parent" 将右侧约束到父布局的右侧。
        app:layout_constraintStart_toStartOf="parent" 将左侧约束到父布局的左侧。
        app:layout_constraintTop_toTopOf="parent" 将顶部约束到父布局的顶部。
        这样设置使得 ListView 充满整个父布局。
    -->
    <ListView
        android:id="@+id/listView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>
```

**2. 创建数据模型（Contact.java）**

```java
// 文件路径: src/com/cfk/listviewstudy/entity/Contact.java

package com.cfk.listviewstudy.entity;

/**
 * 联系人实体类，表示一个联系人对象。
 */
public class Contact {
    // 联系人姓名
    private String name;
    
    // 联系人电话号码
    private String phoneNumber;

    /**
     * 构造方法，用于初始化联系人对象。
     *
     * @param name 联系人姓名
     * @param phoneNumber 联系人电话号码
     */
    public Contact(String name, String phoneNumber) {
        this.name = name;
        this.phoneNumber = phoneNumber;
    }

    /**
     * 获取联系人姓名。
     *
     * @return 联系人姓名
     */
    public String getName() {
        return name;
    }

    /**
     * 获取联系人电话号码。
     *
     * @return 联系人电话号码
     */
    public String getPhoneNumber() {
        return phoneNumber;
    }
}
```

**3. 创建适配器（ContactAdapter.java）**

```java
// 文件路径: src/com/cfk/listviewstudy/adapter/ContactAdapter.java

package com.cfk.listviewstudy.adapter;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.cfk.listviewstudy.R;  // 这里假设 R 文件的路径是 com.cfk.listviewstudy

import com.cfk.listviewstudy.entity.Contact;

import java.util.List;

/**
 * 自定义适配器类，用于将联系人数据与界面进行绑定。
 */
public class ContactAdapter extends ArrayAdapter<Contact> {

    /**
     * 构造方法，用于初始化适配器。
     *
     * @param context 上下文
     * @param contacts 联系人列表
     */
    public ContactAdapter(@NonNull Context context, List<Contact> contacts) {
        super(context, 0, contacts);
    }

    /**
     * 重写方法，获取视图并设置数据。
     *
     * @param position 在适配器数据中的位置
     * @param convertView 用于重用的视图
     * @param parent 视图的父级
     * @return 填充了数据的视图
     */
    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        // 获取数据项
        Contact contact = getItem(position);

        // 重用视图以提高性能
        if (convertView == null) {
            convertView = LayoutInflater.from(getContext()).inflate(android.R.layout.simple_list_item_1, parent, false);
        }

        // 获取布局中的 TextView
        TextView textView = convertView.findViewById(android.R.id.text1);

        // 设置文本内容
        textView.setText(contact.getName());

        return convertView;
    }
}
```

**4. 更新 MainActivity.java**

```java
// 文件路径: src/com/cfk/listviewstudy/activity/MainActivity.java

package com.cfk.listviewstudy.activity;

import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ListView;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

import com.cfk.listviewstudy.R;  // 这里假设 R 文件的路径是 com.cfk.listviewstudy
import com.cfk.listviewstudy.adapter.ContactAdapter;
import com.cfk.listviewstudy.entity.Contact;

import java.util.ArrayList;
import java.util.List;

/**
 * 主活动类，负责初始化界面和处理用户交互。
 *
 * @version : 0.0.1
 * @Date : 2024/1/2 15:30
 * @author : B_T_D-btd_
 * @E-Mail : cui.fk@neusoft.com
 */
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 准备联系人数据
        List<Contact> contacts = new ArrayList<>();
        contacts.add(new Contact("Alice", "123-456-7890"));
        contacts.add(new Contact("Bob", "987-654-3210"));
        contacts.add(new Contact("Charlie", "555-123-4567"));

        // 获取 ListView 实例
        ListView listView = findViewById(R.id.listView);

        // 创建适配器
        ContactAdapter adapter = new ContactAdapter(this, contacts);

        // 设置适配器
        listView.setAdapter(adapter);

        // 设置点击事件监听器
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // 处理点击事件，显示电话号码
                Contact selectedContact = (Contact) parent.getItemAtPosition(position);
                String phoneNumber = selectedContact.getPhoneNumber();
                Toast.makeText(MainActivity.this, "Calling " + selectedContact.getName() + " at " + phoneNumber, Toast.LENGTH_SHORT).show();
            }
        });
    }
}
```

**5.在`AndroidManifest.xml`文件中注册MainActivity**

```xml
<!-- AndroidManifest.xml -->

<!-- 声明 XML 命名空间 -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 应用程序的主要配置信息 -->
    <application
        android:allowBackup="true"  <!-- 允许备份 -->
        android:dataExtractionRules="@xml/data_extraction_rules"  <!-- 数据提取规则 -->
        android:fullBackupContent="@xml/backup_rules"  <!-- 完全备份规则 -->
        android:icon="@mipmap/ic_launcher"  <!-- 应用图标 -->
        android:label="@string/app_name"  <!-- 应用名称 -->
        android:roundIcon="@mipmap/ic_launcher_round"  <!-- 圆形图标 -->
        android:supportsRtl="true"  <!-- 支持从右到左的布局 -->
        android:theme="@style/Theme.ListViewStudy"  <!-- 应用主题 -->
        tools:targetApi="31">  <!-- 指定工具目标 API 版本 -->

        <!-- 应用程序中的活动组件 -->
        <activity android:name=".activity.MainActivity"  <!-- 活动的类名 -->
            android:exported="true">  <!-- 允许其他应用组件调用此活动 -->
            
            <!-- 活动的意图过滤器，定义活动如何响应隐式意图 -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>  <!-- 主入口点的操作 -->
                <category android:name="android.intent.category.LAUNCHER"/>  <!-- 设置为启动器活动 -->
            </intent-filter>
        </activity>
    </application>

</manifest>
```

**6.运行测试**

在这个例子中，我们创建了一个简单的联系人类（`Contact`），一个自定义适配器（`ContactAdapter`），并在 `MainActivity` 中使用 ListView 展示联系人列表。当用户点击列表项时，会显示一个 Toast 提示联系人的电话号码。这个例子涵盖了 ListView、适配器、数据模型和点击事件处理的基本概念。在实际应用中，你可以根据需求进一步扩展和定制。

运行以上程序，运行结果截图如下所示：

![笔记-ListView的使用示例运行结果截图.gif](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-ListView%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%88%AA%E5%9B%BE.gif)

## 13.2 GridView

### 13.1.1 GridView的介绍

**定义：**
`GridView` 是 Android 中的一个布局控件，用于显示网格形式的数据。它可以用来展示一组数据，例如图片、文本或其他自定义的视图。`GridView` 可以让你以行和列的形式显示数据，类似于一个表格。每个单元格都可以包含一个视图，这样就可以创建灵活的网格布局。

在 Android 中，`GridView` 继承自 `AbsListView`，而后者又是 `ViewGroup` 的子类。`GridView` 的主要特点是可以通过适配器（Adapter）来提供数据，并通过列数和行数来进行布局。适配器负责将数据提供给 `GridView`，而 `GridView` 则负责显示这些数据。

**背景与意义：**

- **灵活的数据展示：** `GridView` 提供了一种灵活的方式来展示数据，特别适用于需要以网格形式呈现的场景，如图库、表格等。

- **适应不同屏幕尺寸：** Android 设备具有多样化的屏幕尺寸和分辨率，而 `GridView` 可以通过调整列数和行数来适应不同屏幕的显示，确保良好的用户体验。

- **与适配器的结合使用：** `GridView` 通常与适配器一起使用，适配器负责将数据提供给 `GridView` 并创建每个单元格的视图。这种模式使得 `GridView` 能够轻松地适应各种数据源，并实现数据与界面的分离。

- **交互性：** `GridView` 支持用户与单元格的交互，可以通过设置监听器来处理单元格的点击事件，从而提供更丰富的用户交互体验。

总的来说，`GridView` 是 Android 开发中一个常用且强大的布局控件，适用于需要以网格形式展示数据的情景，提供了灵活性、适应性和良好的交互性。

**使用方法如下。**

### 13.1.2 GridView的使用

在 Android 开发中，使用 `GridView` 主要涉及以下几个步骤：准备数据、创建适配器、设置适配器、处理点击事件。下面我将详细生动地介绍这些步骤：

**步骤一：准备数据**

首先，你需要准备要在 `GridView` 中显示的数据。假设我们要显示一组图片，可以将图片资源的 ID 存储在一个整数数组中：

```java
int[] imageIds = {
    R.drawable.image1,
    R.drawable.image2,
    R.drawable.image3,
    // 添加更多的图片资源...
};
```

**步骤二：创建适配器**

接下来，你需要创建一个适配器（Adapter），用于将数据提供给 `GridView`。Android 提供了 `BaseAdapter` 类，你可以通过继承它来创建自定义的适配器。以下是一个简单的例子：

```java
public class ImageAdapter extends BaseAdapter {
    private Context mContext;
    private int[] mImageIds;

    public ImageAdapter(Context context, int[] imageIds) {
        mContext = context;
        mImageIds = imageIds;
    }

    @Override
    public int getCount() {
        return mImageIds.length;
    }

    @Override
    public Object getItem(int position) {
        return null;
    }

    @Override
    public long getItemId(int position) {
        return 0;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ImageView imageView;
        if (convertView == null) {
            // 如果视图为空，创建一个新的 ImageView
            imageView = new ImageView(mContext);
            imageView.setLayoutParams(new GridView.LayoutParams(150, 150)); // 设置单元格的大小
            imageView.setScaleType(ImageView.ScaleType.CENTER_CROP); // 图片居中裁剪
        } else {
            imageView = (ImageView) convertView;
        }

        // 设置 ImageView 的图片资源
        imageView.setImageResource(mImageIds[position]);
        return imageView;
    }
}
```

**步骤三：设置适配器**

在你的活动（Activity）或片段（Fragment）中，通过以下方式设置 `GridView` 的适配器：

```java
GridView gridView = findViewById(R.id.gridView); // 假设你在布局文件中定义了一个名为 gridView 的 GridView
ImageAdapter adapter = new ImageAdapter(this, imageIds); // imageIds 是你之前准备的图片资源数组
gridView.setAdapter(adapter);
```

**步骤四：处理点击事件**

如果你想处理 `GridView` 中单元格的点击事件，可以为 `GridView` 设置一个点击监听器：

```java
gridView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        // 处理点击事件，例如显示大图或其他操作
        Toast.makeText(MainActivity.this, "Clicked position: " + position, Toast.LENGTH_SHORT).show();
    }
});
```

以上步骤涵盖了在 Android 中使用 `GridView` 的基本流程。通过这些步骤，你就可以在应用中展示一组图片，并处理用户的点击事件。当然，你可以根据具体需求对适配器和布局进行更多的自定义。

下面我们通过一个具体的例子来学习`GridView`的使用：

**1. 准备数据**

将猫咪图片保存在 `res/drawable` 文件夹下，例如 `cat1.jpg`、`cat2.jpg`、`cat3.jpg`、`cat4.jpg`。

**2. 布局文件**

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- res/layout/activity_main.xml -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".activity.MainActivity">

    <!-- GridView用于显示猫咪图片 -->
    <GridView
        android:id="@+id/gridView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:columnWidth="100dp"
        android:numColumns="auto_fit"
        android:verticalSpacing="5dp"
        android:horizontalSpacing="5dp"
        android:stretchMode="columnWidth"
        android:gravity="center"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"/>
</androidx.constraintlayout.widget.ConstraintLayout>
```

**3.创建适配器**

```java
//src/com/cfk/gridviewstudy/adapter/CatImageAdapter.java
package com.cfk.gridviewstudy.adapter;

import android.content.Context;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.GridView;
import android.widget.ImageView;

import com.cfk.gridviewstudy.R;

/**
 * 猫咪图片适配器，用于在GridView中显示猫咪图片。
 */
public class CatImageAdapter extends BaseAdapter {

    // 上下文对象
    private Context mContext;

    // 猫咪图片资源ID数组
    private int[] mCatImageIds = {
            R.drawable.cat1,
            R.drawable.cat2,
            R.drawable.cat3,
            R.drawable.cat4
    };

    /**
     * 构造函数，用于传递上下文对象。
     * @param context 上下文对象
     */
    public CatImageAdapter(Context context) {
        mContext = context;
    }

    /**
     * 获取GridView中的项数。
     * @return 项数
     */
    @Override
    public int getCount() {
        return mCatImageIds.length;
    }

    /**
     * 获取与指定位置的项关联的数据。
     * @param position 项的位置
     * @return 与指定位置的项关联的数据
     */
    @Override
    public Object getItem(int position) {
        return null;
    }

    /**
     * 获取指定位置的项的ID。
     * @param position 项的位置
     * @return 指定位置的项的ID
     */
    @Override
    public long getItemId(int position) {
        return mCatImageIds[position];
    }

    /**
     * 获取一个视图，显示在GridView中的指定位置。
     * @param position    要在GridView中显示的数据的位置
     * @param convertView 旧的缓存视图，可能为null
     * @param parent      GridView的父视图
     * @return 一个View对象，显示在GridView中的指定位置
     */
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ImageView imageView;
        if (convertView == null) {
            // 如果视图为空，创建一个新的ImageView
            imageView = new ImageView(mContext);
            imageView.setLayoutParams(new ViewGroup.LayoutParams(300, 300)); // 设置单元格的大小
            imageView.setScaleType(ImageView.ScaleType.CENTER_CROP); // 图片居中裁剪
        } else {
            imageView = (ImageView) convertView;
        }

        // 设置ImageView的图片资源
        imageView.setImageResource(mCatImageIds[position]);
        return imageView;
    }
}
```

**4. 设置适配器**

```java
//src/com/cfk/gridviewstudy/activity/MainActivity.java
package com.cfk.gridviewstudy.activity;

import android.content.DialogInterface;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.GridView;
import android.widget.ImageView;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;

import com.cfk.gridviewstudy.R;
import com.cfk.gridviewstudy.adapter.CatImageAdapter;

/**
 * 主活动类，负责显示GridView和处理点击事件。
 */
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 获取GridView控件
        GridView gridView = findViewById(R.id.gridView);

        // 创建猫咪图片适配器
        CatImageAdapter adapter = new CatImageAdapter(this);

        // 设置适配器
        gridView.setAdapter(adapter);

        // 设置GridView的点击事件监听器
        gridView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // 获取被点击猫咪图片资源
                int clickedImageId = (int) adapter.getItemId(position);

                // 显示大图
                showLargeImage(clickedImageId);
            }
        });
    }

    /**
     * 显示大图的方法。
     * @param imageResourceId 被点击猫咪图片的资源ID
     */
    private void showLargeImage(int imageResourceId) {
        // 创建AlertDialog来显示大图
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        ImageView imageView = new ImageView(this);

        // 设置ImageView的图片资源
        imageView.setImageResource(imageResourceId);
        imageView.setScaleType(ImageView.ScaleType.FIT_CENTER); // 可根据需要更改ScaleType

        // 设置AlertDialog的视图为ImageView
        builder.setView(imageView);

        // 设置AlertDialog的按钮，点击关闭对话框
        builder.setPositiveButton("关闭", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                dialog.dismiss();
            }
        });

        // 创建AlertDialog
        AlertDialog dialog = builder.create();

        // 设置AlertDialog的窗口大小
        dialog.getWindow().setLayout(800, 1000);  // 根据需要设置宽高

        // 显示AlertDialog
        dialog.show();

        // 打印日志
        Log.d("ShowLargeImage", "Dialog shown with imageResourceId: " + imageResourceId);
    }
}
```

**5.在`AndroidManifest.xml`文件中注册MainActivity**

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- AndroidManifest.xml 文件，用于声明应用程序的配置信息和组件信息 -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:allowBackup="true"  <!-- 允许备份 -->
        android:dataExtractionRules="@xml/data_extraction_rules"  <!-- 数据提取规则 -->
        android:fullBackupContent="@xml/backup_rules"  <!-- 完全备份内容 -->
        android:icon="@mipmap/ic_launcher"  <!-- 应用图标 -->
        android:label="@string/app_name"  <!-- 应用标签 -->
        android:roundIcon="@mipmap/ic_launcher_round"  <!-- 圆形应用图标 -->
        android:supportsRtl="true"  <!-- 支持从右到左的布局 -->
        android:theme="@style/Theme.GridViewStudy"  <!-- 应用主题 -->
        tools:targetApi="31">  <!-- 指定工具版本 -->

        <!-- 主活动声明 -->
        <activity android:name=".activity.MainActivity"
            android:exported="true">  <!-- 允许其他应用调用此活动 -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>  <!-- 主活动入口点 -->
                <category android:name="android.intent.category.LAUNCHER"/>  <!-- 将此活动设为启动器 -->
            </intent-filter>
        </activity>

    </application>

</manifest>
```

**6.运行测试**

这个例子是一个简单的安卓应用，它包含一个`GridView`，用于显示猫咪的图片。点击图片会弹出一个对话框，展示点击的图片的大图，并提供关闭按钮。

运行该程序，运行结果截图如下：

![笔记-GridView的使用示例运行结果截图.gif](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-GridView%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%88%AA%E5%9B%BE.gif)

由上图可知，当点击任意一个图片时，成功地实现了放大图片的操作。

## 13.3 RecycleView

### 13.3.1 RecycleView的介绍

**定义：**

RecyclerView 是 Android 框架中的一个视图容器，用于展示大量数据集合。它允许开发者高效地回收和重复使用列表项视图，以减少内存占用和提高性能。RecyclerView 的主要组件包括布局管理器（LayoutManager）、适配器（Adapter）和项动画（ItemAnimator）。

**背景与意义：**

1. **灵活性与可定制性：** RecyclerView 提供了灵活的布局管理器，使得开发者可以轻松实现线性布局、网格布局、瀑布流等不同的列表展示方式。这使得应对各种数据展示需求变得更为容易。
2. **性能优化：** 相比传统的 ListView，RecyclerView 通过 ViewHolder 模式和局部刷新技术，实现了更高效的数据展示。ViewHolder 模式通过重复使用已经创建的视图减少了内存占用，而局部刷新则允许只更新变化的部分，减小了刷新操作的开销。
3. **动画支持：** RecyclerView 提供了内置的项动画支持，可以方便地为列表项的添加、删除和移动等操作添加动画效果，提升用户体验。
4. **支持异步加载：** 通过结合异步加载框架，RecyclerView 可以在后台加载数据，避免阻塞主线程，从而确保应用的流畅性。
5. **分割线和装饰：** RecyclerView 支持易于配置的分割线和装饰，帮助开发者更好地定制列表项的外观和间距。

综上所述，RecyclerView 是 Android 开发中强大的列表展示工具，通过其灵活性、性能优化和丰富的功能，使得开发者能够更加轻松地实现各种复杂的列表展示需求，并提供更好的用户体验。

### 13.3.2 RecycleView的使用

在 Android 开发中，使用 RecyclerView 可以通过以下步骤实现，包括布局文件的定义、适配器的创建、数据绑定以及添加动画效果。

**1. 布局文件定义：**

首先，在你的 XML 布局文件中定义 RecyclerView。例如，你可以在一个 `activity_main.xml` 文件中添加：

```xml
<!-- activity_main.xml -->
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:padding="16dp"
        android:clipToPadding="false"
        android:background="#EDEDED"
        android:scrollbars="vertical" />

</RelativeLayout>
```

**2. 创建数据模型类：**

定义一个数据模型类，例如 `MyDataModel`，用于表示 RecyclerView 中的每个数据项。

```java
public class MyDataModel {
    private String itemName;

    public MyDataModel(String itemName) {
        this.itemName = itemName;
    }

    public String getItemName() {
        return itemName;
    }
}
```

**3. 创建适配器：**

创建一个继承自 `RecyclerView.Adapter` 的适配器类，用于将数据模型与 RecyclerView 连接起来。

```java
public class MyAdapter extends RecyclerView.Adapter<MyAdapter.ViewHolder> {

    private List<MyDataModel> dataList;

    public MyAdapter(List<MyDataModel> dataList) {
        this.dataList = dataList;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_layout, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        MyDataModel dataModel = dataList.get(position);
        holder.bindData(dataModel);
    }

    @Override
    public int getItemCount() {
        return dataList.size();
    }

    public class ViewHolder extends RecyclerView.ViewHolder {
        private TextView itemNameTextView;

        public ViewHolder(@NonNull View itemView) {
            super(itemView);
            itemNameTextView = itemView.findViewById(R.id.itemNameTextView);
        }

        public void bindData(MyDataModel dataModel) {
            itemNameTextView.setText(dataModel.getItemName());
        }
    }
}
```

**4. 创建列表项布局文件：**

在 `res/layout` 文件夹下创建 `item_layout.xml` 文件，用于定义 RecyclerView 中每个列表项的布局。

```xml
<!-- item_layout.xml -->
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/itemNameTextView"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="10dp"
    android:textSize="16sp"
    android:background="?android:attr/selectableItemBackground"/>
```

**5. 在 MainActivity 中初始化 RecyclerView：**

在你的 `MainActivity.java` 文件中，初始化 RecyclerView、创建数据列表、创建适配器，并将适配器与 RecyclerView 绑定。

```java
public class MainActivity extends AppCompatActivity {

    private RecyclerView recyclerView;
    private List<MyDataModel> dataList;
    private MyAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        recyclerView = findViewById(R.id.recyclerView);
        dataList = generateData(); // 生成示例数据
        adapter = new MyAdapter(dataList);

        // 设置布局管理器，可以是线性、网格、瀑布流等
        RecyclerView.LayoutManager layoutManager = new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);

        // 设置适配器
        recyclerView.setAdapter(adapter);
    }

    private List<MyDataModel> generateData() {
        List<MyDataModel> data = new ArrayList<>();
        data.add(new MyDataModel("Item 1"));
        data.add(new MyDataModel("Item 2"));
        // 添加更多数据项...

        return data;
    }
}
```

这样，你就成功地使用 RecyclerView 实现了一个简单的列表。你可以根据需要自定义布局、添加点击事件监听、实现数据增删等操作。此外，你还可以通过添加项动画、分割线等来提升用户体验。

下面我们通过一个具体的例子来学习RecycleView的使用：

假设我们要开发一个简单的待办事项列表应用，使用 RecyclerView 来展示任务列表，创建步骤如下：

**1. 布局文件定义：**

在 `activity_main.xml` 中定义 RecyclerView：

```xml
<!-- res/layout/activity_main.xml -->
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".activity.MainActivity">

    <!-- 用于显示任务列表的 RecyclerView -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:padding="16dp"
        android:clipToPadding="false"
        android:background="#EDEDED"
        android:scrollbars="vertical"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>
</androidx.constraintlayout.widget.ConstraintLayout>
```

在 `res/layout` 文件夹下创建 `task_item_layout.xml`：

```xml
<!-- res/layout/task_item_layout.xml -->
<?xml version="1.0" encoding="utf-8"?>
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/taskNameTextView"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="10dp"
    android:textSize="18sp"
    android:background="?android:attr/selectableItemBackground"/>
```

**2. 数据模型类：**

创建一个 `TaskModel` 类，表示待办事项：

```java
package com.cfk.recyclerviewstudy.entity;

/**
 * @file TaskModel.java
 * @brief 用于表示待办任务的数据模型类
 */

public class TaskModel {
    private String taskName;

    /**
     * 构造函数，用于创建 TaskModel 对象
     *
     * @param taskName 待办任务的名称
     */
    public TaskModel(String taskName) {
        this.taskName = taskName;
    }

    /**
     * 获取待办任务的名称
     *
     * @return 任务名称
     */
    public String getTaskName() {
        return taskName;
    }
}
```

**3. 适配器：**

创建适配器 `TaskAdapter`：

```java
package com.cfk.recyclerviewstudy.adapter;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.cfk.recyclerviewstudy.R;
import com.cfk.recyclerviewstudy.entity.TaskModel;

import java.util.List;

/**
 * @file TaskAdapter.java
 * @brief 用于连接 RecyclerView 和 TaskModel 数据的适配器类
 */

public class TaskAdapter extends RecyclerView.Adapter<TaskAdapter.ViewHolder> {
    private List<TaskModel> taskList;

    /**
     * 构造函数，用于创建 TaskAdapter 对象
     *
     * @param taskList 待显示的任务列表
     */
    public TaskAdapter(List<TaskModel> taskList){
        this.taskList=taskList;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        // 创建一个新的视图，将其与 ViewHolder 关联
        View view= LayoutInflater.from(parent.getContext()).inflate(R.layout.task_item_layout,parent,false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull TaskAdapter.ViewHolder holder, int position) {
        // 获取指定位置的任务对象并将其绑定到 ViewHolder
        TaskModel task=taskList.get(position);
        holder.bindTask(task);
    }

    @Override
    public int getItemCount() {
        // 返回任务列表的大小，确定 RecyclerView 需要显示的项数
        return taskList.size();
    }

    /**
     * 内部类 ViewHolder，用于表示 RecyclerView 的单个项
     */
    public class ViewHolder extends RecyclerView.ViewHolder{
        private TextView taskNameTextView;

        /**
         * 构造函数，用于创建 ViewHolder 对象
         *
         * @param itemView 视图项
         */
        public ViewHolder(@NonNull View itemView){
            super(itemView);
            taskNameTextView=itemView.findViewById(R.id.taskNameTextView);
        }

        /**
         * 将指定任务绑定到视图中
         *
         * @param task 待办任务对象
         */
        public void bindTask(TaskModel task){
            taskNameTextView.setText(task.getTaskName());
        }
    }
}
```

**5.MainActivity 初始化：**

在 `MainActivity.java` 中初始化 RecyclerView：

```java
package com.cfk.recyclerviewstudy.activity;

import android.os.Bundle;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.cfk.recyclerviewstudy.R;
import com.cfk.recyclerviewstudy.adapter.TaskAdapter;
import com.cfk.recyclerviewstudy.entity.TaskModel;

import java.util.ArrayList;
import java.util.List;

/**
 * @file MainActivity.java
 * @brief 应用的主活动，显示任务列表
 */

public class MainActivity extends AppCompatActivity {
    private RecyclerView recyclerView;
    private List<TaskModel> taskList;
    private TaskAdapter adapter;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 设置活动布局
        setContentView(R.layout.activity_main);

        // 获取 RecyclerView 控件的引用
        recyclerView=findViewById(R.id.recyclerView);

        // 生成任务数据
        taskList=generateTaskData();

        // 创建适配器并将其与 RecyclerView 关联
        adapter=new TaskAdapter(taskList);

        // 创建布局管理器并将其与 RecyclerView 关联
        RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);

        // 将适配器设置到 RecyclerView 中
        recyclerView.setAdapter(adapter);
    }

    /**
     * 生成示例任务数据
     *
     * @return 任务数据列表
     */
    private List<TaskModel> generateTaskData(){
        List<TaskModel> tasks=new ArrayList<>();

        tasks.add(new TaskModel("Buy groceries"));
        tasks.add(new TaskModel("Read a book"));
        tasks.add(new TaskModel("Go for a run"));
        tasks.add(new TaskModel("Complete homework"));
        tasks.add(new TaskModel("Write a blog post"));
        tasks.add(new TaskModel("Practice coding"));
        tasks.add(new TaskModel("Call a friend"));
        tasks.add(new TaskModel("Learn a new language"));
        tasks.add(new TaskModel("Cook a new recipe"));
        tasks.add(new TaskModel("Exercise for 30 minutes"));
        tasks.add(new TaskModel("Organize the closet"));
        tasks.add(new TaskModel("Watch a documentary"));
        tasks.add(new TaskModel("Plan the week ahead"));
        tasks.add(new TaskModel("Visit a museum"));
        tasks.add(new TaskModel("Listen to a podcast"));
        tasks.add(new TaskModel("Write in a journal"));
        tasks.add(new TaskModel("Take a nature walk"));
        tasks.add(new TaskModel("Learn a musical instrument"));

        return tasks;
    }
}
```

**6.在`AndroidManifest.xml`文件中声明MainActivity ：**

```xml
<!-- AndroidManifest.xml -->
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools">

    <application
        android:allowBackup="true"                    <!-- 允许备份应用数据 -->
        android:dataExtractionRules="@xml/data_extraction_rules"  <!-- 指定数据提取规则 -->
        android:fullBackupContent="@xml/backup_rules" <!-- 定义完整备份内容规则 -->
        android:icon="@mipmap/ic_launcher"            <!-- 设置应用图标 -->
        android:label="@string/app_name"              <!-- 设置应用标签名称 -->
        android:roundIcon="@mipmap/ic_launcher_round" <!-- 设置应用圆形图标 -->
        android:supportsRtl="true"                    <!-- 支持从右到左的布局 -->
        android:theme="@style/Theme.RecyclerViewStudy" <!-- 设置应用主题样式 -->
        tools:targetApi="31">                          <!-- 使用的目标 API 版本 -->

        <!-- 主活动，应用的启动入口 -->
        <activity android:name=".activity.MainActivity"
                  android:exported="true">              <!-- 允许其他应用启动此活动 -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/> <!-- 指定为主活动 -->
                <category android:name="android.intent.category.LAUNCHER"/> <!-- 设置为启动器 -->
            </intent-filter>
        </activity>
    </application>

</manifest>
```

**7.运行测试：**

现在，你已经创建了一个简单的待办事项列表应用，使用 RecyclerView 显示任务列表。用户可以滚动查看任务，你还可以通过添加按钮、长按删除等操作来丰富用户体验。

运行以上程序，运行结果截图如下：

![笔记-RecyclerView使用示例运行结果截图.gif](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-RecyclerView%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%88%AA%E5%9B%BE.gif)

由上图可知，以上程序成功实现了使用 RecyclerView 显示任务列表，同时用户可以滚动查看任务。

### 13.3.3 使用RecycleView绘制分割线

在Android开发中，RecyclerView是一种强大的列表控件，它可以用于展示大量数据并支持灵活的布局管理。然而，RecyclerView默认情况下并不提供分割线的绘制，但我们可以通过定制ItemDecoration来实现分割线的效果。以下是详细的步骤：

1. **创建分割线的自定义类：**
   首先，你需要创建一个自定义的类，继承自RecyclerView.ItemDecoration。这个类将负责绘制分割线。

```java
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.drawable.Drawable;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.RecyclerView;
import android.view.View;

/**
 * 自定义RecyclerView分割线
 */
public class DividerItemDecoration extends RecyclerView.ItemDecoration {

    // 用于绘制分割线的Drawable
    private Drawable divider;

    /**
     * 构造方法，接受上下文和分割线资源ID作为参数
     *
     * @param context 上下文
     * @param resId   分割线资源ID
     */
    public DividerItemDecoration(Context context, int resId) {
        // 通过上下文获取分割线资源，并赋值给成员变量divider
        divider = ContextCompat.getDrawable(context, resId);
    }

    /**
     * 重写该方法，用于绘制分割线
     *
     * @param canvas  画布
     * @param parent  父级RecyclerView
     * @param state   RecyclerView的状态
     */
    @Override
    public void onDraw(Canvas canvas, RecyclerView parent, RecyclerView.State state) {
        // 获取RecyclerView左右padding值
        int left = parent.getPaddingLeft();
        int right = parent.getWidth() - parent.getPaddingRight();

        // 循环遍历RecyclerView的子View（Item）
        for (int i = 0; i < parent.getChildCount() - 1; i++) {
            // 获取当前子View
            View child = parent.getChildAt(i);
            // 获取子View的LayoutParams
            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();

            // 计算分割线的上下边界位置
            int top = child.getBottom() + params.bottomMargin;
            int bottom = top + divider.getIntrinsicHeight();

            // 设置分割线的边界，并绘制到Canvas上
            divider.setBounds(left, top, right, bottom);
            divider.draw(canvas);
        }
    }
}
```

2. **在RecyclerView的Adapter中应用分割线：**
   在你的RecyclerView的Adapter中，创建DividerItemDecoration的实例并应用到RecyclerView上。

```java
// 在你的Activity或Fragment中

// 获取RecyclerView实例
RecyclerView recyclerView = findViewById(R.id.recyclerView);

// 设置布局管理器，可以是LinearLayoutManager或其他
RecyclerView.LayoutManager layoutManager = new LinearLayoutManager(this);
recyclerView.setLayoutManager(layoutManager);

// 设置Adapter，替换成你自己的Adapter实例
MyAdapter adapter = new MyAdapter(data);
recyclerView.setAdapter(adapter);

// 创建并应用分割线
DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(this, R.drawable.divider);
// R.drawable.divider是你自定义的分割线资源，可以是一条矩形图片
recyclerView.addItemDecoration(dividerItemDecoration);
```

确保你的分割线资源（R.drawable.divider）是一个矩形的图片，这样它可以被拉伸或平铺以填充整个分割线区域。

这样，你就成功地为RecyclerView添加了自定义分割线。这个分割线将在RecyclerView的每个Item之间绘制，为列表提供更好的可视区分。

下面我们通过一个例子来学习如何使用RecyclerView来绘制分割线：

下面是详细步骤，帮你了解这个例子如何绘制分割线：

**步骤1：准备用户头像图像**

在 `res/drawable` 目录下放置用户头像图像文件：

- `alice.png`
- `bob.png`
- `charlie.png`

确保图像文件名是小写的，并且不包含空格或特殊字符。

**步骤2：准备分割线样式**

在 `res/drawable` 目录下创建分割线样式文件 `divider.xml`，内容如下：

```xml
<!-- res/drawable/divider.xml -->
<!--
    此 XML 可绘制资源定义了 RecyclerView 中项之间分隔线的外观。
    分隔线是一条具有指定高度和颜色的水平线。

    - shape: 定义可绘制的形状，这里是一个矩形。
    - size: 指定矩形的高度，代表分隔线的粗细。
    - solid: 定义矩形的颜色，代表分隔线的颜色。

    通过调整高度和颜色属性，您可以自定义分隔线的外观。

    注意：确保对于水平分隔线使用矩形形状；对于垂直分隔线，请调整宽度属性而不是高度。

    示例：
    若要自定义颜色，请将 "#03A9F4" 替换为您喜欢的颜色代码。
    若要调整高度，请将 "1dp" 的值修改为所需的粗细。
-->
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <size android:height="1dp"/>
    <solid android:color="#03A9F4"/> <!-- 用您喜欢的颜色替换 -->
</shape>
```

**步骤3：准备布局文件**

在 `res/layout` 目录下创建 `activity_user_list.xml`，内容如下：

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- 
    res/layout/activity_user_list.xml

    此 XML 布局文件表示 UserListActivity 的布局。
    它包含一个 ConstraintLayout 作为根布局，托管一个用于显示用户列表的 RecyclerView。

    - ConstraintLayout：为定位子视图提供了灵活的布局约束。
    - RecyclerView：用于显示可滚动项列表的强大而灵活的视图。

    属性解释：
    - layout_width="match_parent"：布局的宽度将匹配父布局的宽度。
    - layout_height="match_parent"：布局的高度将匹配父布局的高度。
    - app:layout_constraintTop_toTopOf="parent"：RecyclerView 的顶部边缘受到父布局顶部边缘的约束。
    - app:layout_constraintBottom_toBottomOf="parent"：RecyclerView 的底部边缘受到父布局底部边缘的约束。
    - app:layout_constraintStart_toStartOf="parent"：RecyclerView 的开始边缘（对于从左到右的语言是左边）受到父布局开始边缘的约束。
    - app:layout_constraintEnd_toEndOf="parent"：RecyclerView 的结束边缘（对于从左到右的语言是右边）受到父布局结束边缘的约束。
    - android:padding="16dp"：在 RecyclerView 周围添加内边距，以提供与边缘的间距。

    注意：根据设计偏好调整内边距和约束。

-->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- 用于显示用户列表的 RecyclerView -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:padding="16dp"/>

</androidx.constraintlayout.widget.ConstraintLayout>
```

**步骤4：准备用户项布局**

在 `res/layout` 目录下创建 `item_user.xml`，内容如下：

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- 
    res/layout/item_user.xml

    此 XML 布局文件表示 RecyclerView 中的一项布局（用户项）。
    它包含一个 ConstraintLayout 作为根布局，包括一个用于用户头像的 ImageView
    和一个用于显示用户名的 TextView。

    - ConstraintLayout：为定位子视图提供了灵活的布局约束。
    - ImageView：以指定的尺寸和缩放类型显示用户头像图像。
    - TextView：以指定的文本大小显示用户名。

    属性解释：
    - layout_width="match_parent"：布局的宽度将匹配父布局的宽度。
    - layout_height="wrap_content"：布局的高度将根据内容的高度调整。
    - app:layout_constraintStart_toStartOf="parent"：ImageView 的开始边缘（从左到右的语言中为左边）受到父布局开始边缘的约束。
    - app:layout_constraintTop_toTopOf="parent"：ImageView 的顶部边缘受到父布局顶部边缘的约束。
    - app:layout_constraintBottom_toBottomOf="parent"：ImageView 的底部边缘受到父布局底部边缘的约束。
    - app:layout_constraintStart_toEndOf="@+id/avatarImageView"：TextView 的开始边缘受到 ImageView 结束边缘的约束，创建水平间距。
    - app:layout_constraintTop_toTopOf="@+id/avatarImageView"：TextView 的顶部边缘受到 ImageView 的顶部边缘的约束，确保垂直对齐。
    - app:layout_constraintBottom_toBottomOf="@+id/avatarImageView"：TextView 的底部边缘受到 ImageView 的底部边缘的约束，保持垂直对齐。
    - app:layout_constraintEnd_toEndOf="parent"：TextView 的结束边缘（从左到右的语言中为右边）受到父布局结束边缘的约束。
    - android:layout_marginStart="16dp"：在 TextView 的开始侧添加边距，以在 ImageView 和 TextView 之间提供间距。

    注意：根据设计偏好调整尺寸、边距和约束。

-->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <!-- 用于显示用户头像的 ImageView -->
    <ImageView
        android:id="@+id/avatarImageView"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:scaleType="centerCrop"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"/>

    <!-- 用于显示用户名的 TextView -->
    <TextView
        android:id="@+id/usernameTextView"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:textSize="16sp"
        app:layout_constraintStart_toEndOf="@+id/avatarImageView"
        app:layout_constraintTop_toTopOf="@+id/avatarImageView"
        app:layout_constraintBottom_toBottomOf="@+id/avatarImageView"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginStart="16dp"/>

</androidx.constraintlayout.widget.ConstraintLayout>
```

**步骤5：创建用户实体类**

在 `com.cfk.exampleofdrawingdividersusingrecyclerview.entity` 包下创建 `User.java`：

```java
package com.cfk.exampleofdrawingdividersusingrecyclerview.entity;

/**
 * 用户实体类
 */
public class User {
    // 用户名
    private String username;
    
    // 用户头像资源ID
    private int avatarResId;

    /**
     * 构造方法，用于创建用户对象
     *
     * @param username    用户名
     * @param avatarResId 用户头像资源ID
     */
    public User(String username, int avatarResId) {
        this.username = username;
        this.avatarResId = avatarResId;
    }

    /**
     * 获取用户姓名
     *
     * @return 用户名
     */
    public String getUsername() {
        return username;
    }

    /**
     * 获取用户头像资源ID
     *
     * @return 用户头像资源ID
     */
    public int getAvatarResId() {
        return avatarResId;
    }
}
```

**步骤6：创建分割线绘制类**

在 `com.cfk.exampleofdrawingdividersusingrecyclerview.util` 包下创建 `DividerItemDecoration.java`：

```java
package com.cfk.exampleofdrawingdividersusingrecyclerview.util;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.drawable.Drawable;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.RecyclerView;

/**
 * 分割线绘制工具类
 *
 * @version : 0.0.1
 * @Date : 2024/1/3 15:23
 * @E-Mail : cui.fk@neusoft.com
 */
public class DividerItemDecoration extends RecyclerView.ItemDecoration {

    // 分割线 Drawable 对象
    private Drawable divider;

    /**
     * 构造方法，初始化分割线
     *
     * @param context 上下文
     * @param resId   分割线资源ID
     */
    public DividerItemDecoration(Context context, int resId) {
        // 通过上下文和资源ID获取分割线 Drawable 对象
        divider = ContextCompat.getDrawable(context, resId);
    }

    /**
     * 绘制分割线的方法
     *
     * @param canvas 画布对象
     * @param parent RecyclerView 对象
     * @param state  RecyclerView 状态对象
     */
    @Override
    public void onDraw(@NonNull Canvas canvas, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) {
        // 计算分割线的左右边缘
        int left = parent.getPaddingLeft();
        int right = parent.getWidth() - parent.getPaddingRight();

        // 循环绘制分割线
        for (int i = 0; i < parent.getChildCount() - 1; i++) {
            // 获取当前子视图（Item）
            View child = parent.getChildAt(i);

            // 获取子视图的布局参数
            RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();

            // 计算分割线的上下边缘
            int top = child.getBottom() + params.bottomMargin;
            int bottom = top + divider.getIntrinsicHeight();

            // 设置分割线的边界
            divider.setBounds(left, top, right, bottom);

            // 绘制分割线到画布上
            divider.draw(canvas);
        }
    }
}
```

**步骤7：创建用户适配器**

在 `com.cfk.exampleofdrawingdividersusingrecyclerview.adapter` 包下创建 `UserAdapter.java`：

```java
package com.cfk.exampleofdrawingdividersusingrecyclerview.adapter;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.cfk.exampleofdrawingdividersusingrecyclerview.R;
import com.cfk.exampleofdrawingdividersusingrecyclerview.entity.User;

import java.util.List;

/**
 * 用户列表适配器
 *
 * @version : 0.0.1
 * @Date : 2024/1/3 14:58
 * @E-Mail : cui.fk@neusoft.com
 */
public class UserAdapter extends RecyclerView.Adapter<UserAdapter.UserViewHolder> {

    // 用户列表数据
    private List<User> userList;

    /**
     * 构造方法，用于初始化用户列表数据
     *
     * @param userList 用户列表数据
     */
    public UserAdapter(List<User> userList) {
        this.userList = userList;
    }

    /**
     * 创建ViewHolder的方法，将布局文件转换为ViewHolder
     *
     * @param parent   父视图，即RecyclerView
     * @param viewType 视图类型
     * @return 创建的UserViewHolder对象
     */
    @NonNull
    @Override
    public UserViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        // 使用布局填充器从item_user.xml文件创建View
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_user, parent, false);
        return new UserViewHolder(view);
    }

    /**
     * 绑定数据到ViewHolder的方法，将数据展示在RecyclerView的每个Item上
     *
     * @param holder   UserViewHolder对象
     * @param position 当前Item的位置
     */
    public void onBindViewHolder(@NonNull UserViewHolder holder, int position) {
        // 获取当前位置的用户对象
        User user = userList.get(position);

        // 设置用户名和头像
        holder.usernameTextView.setText(user.getUsername());
        holder.avatarImageView.setImageResource(user.getAvatarResId());
    }

    /**
     * 获取用户列表的总数
     *
     * @return 用户列表的总数
     */
    public int getItemCount() {
        return userList.size();
    }

    /**
     * 用户ViewHolder类，用于保存Item中的控件引用
     */
    public static class UserViewHolder extends RecyclerView.ViewHolder {
        ImageView avatarImageView; // 用户头像ImageView
        TextView usernameTextView; // 用户名TextView

        /**
         * 构造方法，用于初始化ViewHolder中的控件引用
         *
         * @param itemView 当前Item的根布局View
         */
        public UserViewHolder(@NonNull View itemView) {
            super(itemView);
            this.avatarImageView = itemView.findViewById(R.id.avatarImageView);
            this.usernameTextView = itemView.findViewById(R.id.usernameTextView);
        }
    }
}
```

**步骤8：在活动中使用 RecyclerView 绘制分割线**

在 `UserListActivity.java` 中使用上述类来显示用户列表：

```java
package com.cfk.exampleofdrawingdividersusingrecyclerview.activity;

import android.graphics.drawable.Drawable;
import android.os.Bundle;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.DividerItemDecoration;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.cfk.exampleofdrawingdividersusingrecyclerview.R;
import com.cfk.exampleofdrawingdividersusingrecyclerview.adapter.UserAdapter;
import com.cfk.exampleofdrawingdividersusingrecyclerview.entity.User;

import java.util.ArrayList;
import java.util.List;

/**
 * 用户列表展示的Activity
 *
 * @version : 0.0.1
 * @Date : 2024/1/3 15:32
 * @E-Mail : cui.fk@neusoft.com
 */
public class UserListActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 设置当前Activity的布局文件为 activity_user_list.xml
        setContentView(R.layout.activity_user_list);

        // 获取RecyclerView实例
        RecyclerView recyclerView = findViewById(R.id.recyclerView);

        // 设置布局管理器，使用LinearLayoutManager，使列表垂直显示
        RecyclerView.LayoutManager layoutManager = new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);

        // 设置Adapter
        List<User> userList = generateUserList();
        UserAdapter adapter = new UserAdapter(userList);
        recyclerView.setAdapter(adapter);

        // 获取自定义分割线 Drawable 对象
        Drawable dividerDrawable = ContextCompat.getDrawable(this, R.drawable.divider);

        // 创建并配置分割线
        DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(this, DividerItemDecoration.VERTICAL);
        dividerItemDecoration.setDrawable(dividerDrawable);

        // 将分割线添加到 RecyclerView
        recyclerView.addItemDecoration(dividerItemDecoration);
    }

    /**
     * 生成用户列表数据的方法
     *
     * @return 生成的用户列表数据
     */
    private List<User> generateUserList() {
        List<User> userList = new ArrayList<>();

        // 添加三个用户到列表中
        userList.add(new User("Alice", R.drawable.alice));
        userList.add(new User("Bob", R.drawable.bob));
        userList.add(new User("Charlie", R.drawable.charlie));

        return userList;
    }
}
```

**步骤9：更新 AndroidManifest.xml**

在 `AndroidManifest.xml` 文件中，确保正确配置活动并添加必要的权限。以下是你提供的 `AndroidManifest.xml` 文件：

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- AndroidManifest.xml 文件，用于配置应用的基本信息和组件声明 -->

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 应用配置信息 -->
    <application
        android:allowBackup="true"                <!-- 是否允许备份 -->
        android:dataExtractionRules="@xml/data_extraction_rules"  <!-- 数据提取规则 -->
        android:fullBackupContent="@xml/backup_rules"              <!-- 备份规则 -->
        android:icon="@mipmap/ic_launcher"        <!-- 应用图标 -->
        android:label="@string/app_name"         <!-- 应用名称 -->
        android:roundIcon="@mipmap/ic_launcher_round" <!-- 圆形应用图标 -->
        android:supportsRtl="true"                <!-- 是否支持RTL（从右到左） -->
        android:theme="@style/Theme.ExampleOfDrawingDividersUsingRecyclerView" <!-- 应用主题 -->
        tools:targetApi="31">                      <!-- 编译目标 API 版本 -->

        <!-- 应用的主Activity，即入口Activity -->
        <activity android:name=".activity.UserListActivity"
            android:exported="true">               <!-- 是否允许其他应用启动该Activity -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>         <!-- 主Action，表示这是应用的主入口 -->
                <category android:name="android.intent.category.LAUNCHER"/> <!-- 主Category，表示这是应用的主入口 -->
            </intent-filter>
        </activity>
    </application>

</manifest>
```

确保将 `UserListActivity` 添加为启动活动，以便应用程序启动时打开用户列表活动。

**步骤10：运行测试**

以上是创建和使用 RecyclerView 绘制分割线的详细步骤。这个例子包含了用户头像、分割线样式、布局文件、用户实体类、分割线绘制类、用户适配器和活动的完整代码。在运行该应用程序后，你应该能够看到一个垂直的用户列表，列表项之间有自定义的分割线。

运行上面的程序，运行截图如下：

![笔记-使用RecyclerView绘制分割线示例运行结果截图.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8RecyclerView%E7%BB%98%E5%88%B6%E5%88%86%E5%89%B2%E7%BA%BF%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%88%AA%E5%9B%BE.png)

由上图可知，该程序成功地实现了一个垂直的用户列表，列表项之间有自定义的分割线的效果。

## 13.4 LIstView、GridView和RecycleView之间的区别

在安卓开发中，ListView、GridView和RecyclerView都是用于显示列表或网格数据的常用控件，它们在实现方式和功能上存在一些区别。下面详细介绍它们之间的区别：

1. **ListView（列表视图）：**
   - **布局：** 垂直滚动的单列列表。
   - **适用场景：** 适用于简单的垂直列表，数据量较小的情况。
   - **适配器：** 使用`ArrayAdapter`、`SimpleAdapter`等。
   - **性能：** 在大数据量情况下性能较差，因为它会一次性加载所有数据到内存中。

2. **GridView（网格视图）：**
   - **布局：** 二维网格，可垂直滚动，每行显示固定数量的列。
   - **适用场景：** 适用于呈现二维数据，例如图库展示，每个网格项通常具有相同的大小。
   - **适配器：** 使用`BaseAdapter`或其子类。
   - **性能：** 由于每个网格项通常具有相同的大小，性能较好，但在大数据量情况下仍可能存在性能问题。

3. **RecyclerView（可重用视图列表）：**
   - **布局：** 灵活的、高度可定制的列表控件，支持垂直和水平滚动，以及各种不同的布局管理器（LayoutManager）。
   - **适用场景：** 适用于复杂布局、数据量大的情况，可根据需要定制不同的布局管理器，如线性布局、网格布局、瀑布流布局等。
   - **适配器：** 使用`RecyclerView.Adapter`，提供了更灵活的数据绑定和视图复用机制。
   - **性能：** 通过视图的复用机制和分屏加载数据的方式，性能较好，特别适合大数据集。

总的来说，ListView和GridView是比较早期的控件，功能相对简单，而RecyclerView是在它们的基础上进行了进一步的扩展和优化，提供了更好的性能和灵活性，因此在现代安卓开发中更为推荐使用。

# 14 Dialog & PopWindow

## 14.1 Dialog

### 14.1.1 Dialog的介绍

**定义：**

在安卓开发中，Dialog（对话框）是一种用户界面元素，用于在应用程序中显示一些信息、接收用户输入或执行特定操作。它通常以弹出窗口的形式出现，覆盖在当前活动（Activity）的前面。Dialog提供了一种与用户进行简单交互的方式，以便展示重要信息、请求用户输入或执行某些操作。

**背景与意义：**

1. **信息展示：** Dialog可用于显示应用程序中的重要信息，如提示、警告或确认信息。这有助于向用户传达关键消息，提高用户体验。

2. **用户输入：** 通过Dialog，开发者可以方便地请求用户输入信息，例如用户名、密码、日期等。这样的交互方式能够使应用更灵活地适应用户需求。

3. **操作确认：** 在执行一些敏感或重要操作时，Dialog可以用于要求用户确认，以防止意外的操作。这有助于减少用户误操作的风险。

4. **多任务处理：** 当应用需要同时进行多个任务时，Dialog可以作为一种轻量级的界面元素，不必打断整个应用流程，而是在需要时弹出，提供必要的信息或操作。

5. **自定义UI：** Dialog允许开发者自定义其外观和行为，以适应应用的整体设计风格。这为创造独特的用户体验提供了便利。

总体而言，Dialog在安卓开发中是一种重要的界面元素，为开发者提供了一种简单而有效的方式来与用户进行交互，同时提高了用户体验和应用的灵活性。

### 14.1.2 Dialog的作用域

在安卓开发中，Dialog的作用域指的是它在应用界面中的展示范围和影响力。Dialog可以在不同的上下文中使用，根据其作用域的不同，它对应用的影响也会有所不同。下面详细介绍Dialog的几种常见作用域：

1. **Activity级别的Dialog：**
   - **作用范围：** 这种Dialog是与特定的Activity相关联的，只在该Activity中显示和操作。
   - **使用场景：** 当需要在某个具体的界面上展示信息、请求用户输入或执行操作时，可以使用Activity级别的Dialog。

2. **应用全局的Dialog：**
   - **作用范围：** 这种Dialog可以在整个应用中显示，不受特定Activity的限制。
   - **使用场景：** 当应用需要在任何界面都能够弹出提示、通知或请求用户确认时，可以使用应用全局的Dialog。

3. **Fragment级别的Dialog：**
   - **作用范围：** 与特定Fragment相关联，只在该Fragment中显示和操作。
   - **使用场景：** 当应用使用了多个Fragment组成一个Activity，并且需要在某个Fragment中展示Dialog时，可以选择使用Fragment级别的Dialog。

4. **系统级别的Dialog：**
   - **作用范围：** 这种Dialog覆盖整个系统窗口，不仅在应用内可见，而且可能会在应用之上显示，例如系统级别的提示框。
   - **使用场景：** 通常用于显示系统级别的通知、警告或权限请求，以及在应用外部进行交互。

5. **Activity之外的Dialog：**
   - **作用范围：** 这种Dialog可以在当前Activity之外显示，但仍然与应用相关。
   - **使用场景：** 当需要在应用外弹出一个悬浮的Dialog，例如悬浮通知或快捷操作按钮，可以使用Activity之外的Dialog。

Dialog的作用域选择取决于开发者的需求和设计，通过合理的选择，可以更好地满足用户交互的需求，提升应用的用户体验。

### 14.1.3 自定义Dialog

在安卓开发中，自定义Dialog允许开发者创建具有独特外观和交互方式的弹出窗口。以下是一步步生动形象地介绍如何自定义Dialog：

**步骤一：创建自定义布局文件**

首先，创建一个XML布局文件，定义Dialog的外观和组件。例如，创建一个名为 `custom_dialog.xml` 的布局文件：

```xml
<!-- custom_dialog.xml -->
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <!-- 添加自定义的视图组件，例如TextView、Button等 -->

</LinearLayout>
```

**步骤二：创建Dialog类**

在Java代码中创建一个自定义的Dialog类，继承自 `Dialog` 或其子类（如 `AlertDialog`）。在构造函数中加载之前创建的布局文件：

```java
public class CustomDialog extends Dialog {

    public CustomDialog(@NonNull Context context) {
        super(context);
        // 设置Dialog的外观
        setContentView(R.layout.custom_dialog);

        // 在这里可以获取并设置自定义布局中的组件，例如：TextView、Button等
        // findViewById(R.id.textView);

        // 添加其他初始化逻辑
    }
}
```

**步骤三：在Activity中使用自定义Dialog**

在你的Activity中，实例化自定义Dialog类并显示出来：

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 点击按钮弹出自定义Dialog
        Button showCustomDialogButton = findViewById(R.id.showCustomDialogButton);
        showCustomDialogButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                showCustomDialog();
            }
        });
    }

    private void showCustomDialog() {
        // 创建并显示自定义Dialog
        CustomDialog customDialog = new CustomDialog(this);
        customDialog.show();
    }
}
```

**步骤四：个性化定制**

根据需要，你可以在自定义Dialog类中添加更多逻辑，例如设置按钮点击事件、动画效果等。也可以在自定义布局中添加各种组件，以满足特定的设计需求。

通过这个过程，你就成功地创建了一个自定义Dialog，使你能够更灵活地设计和展示弹出窗口，以满足应用的独特需求。

下面我们通过一个具体的例子来学习如何自定义Dialog：

我们将创建一个自定义Dialog，其中包含一个显示笑脸的ImageView和一个按钮，点击按钮后Dialog将弹出一个简单的笑脸提示，步骤如下：

**步骤一：准备图片**

确保在 `res/drawable` 目录下包含名为 `happy_face.png` 的图片。

**步骤二：创建自定义布局文件**

`activity_main.xml`：

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- res/layout/activity_main.xml -->
<!-- 声明使用的命名空间 -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".activity.MainActivity">

    <!-- 按钮：点击将触发显示自定义Dialog -->
    <Button
        android:id="@+id/showDialogButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Show Dialog"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginTop="16dp"/>
</androidx.constraintlayout.widget.ConstraintLayout>
```

`custom_dialog_layout.xml`：

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- res/layout/custom_dialog_layout.xml -->

<!-- 使用 ConstraintLayout 布局 -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:padding="16dp">

    <!-- 显示笑脸的ImageView，设置了尺寸和约束 -->
    <ImageView
        android:id="@+id/dialogImageView"
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:src="@drawable/happy_face"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/closeButton"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintVertical_chainStyle="packed"
        android:layout_marginTop="16dp"/>

    <!-- 关闭按钮，设置了约束和尺寸 -->
    <Button
        android:id="@+id/closeButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Close"
        app:layout_constraintTop_toBottomOf="@+id/dialogImageView"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginTop="16dp"/>
</androidx.constraintlayout.widget.ConstraintLayout>
```

**步骤三：创建自定义Dialog类**

`CustomDialog.java`：

```java
// src/com/cfk/dialogstudy/dialog/CustomDialog.java

package com.cfk.dialogstudy.dialog;

import android.app.Dialog;
import android.content.Context;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;

import androidx.annotation.NonNull;

import com.cfk.dialogstudy.R;

/**
 * 自定义的Dialog类
 * 用于展示包含笑脸ImageView和关闭按钮的自定义布局
 */
public class CustomDialog extends Dialog {

    /**
     * 构造方法，用于初始化Dialog
     *
     * @param context 上下文环境
     */
    public CustomDialog(@NonNull Context context) {
        super(context);

        // 设置Dialog的布局为 custom_dialog_layout.xml
        setContentView(R.layout.custom_dialog_layout);
    }

    /**
     * 在Dialog创建时调用，用于设置布局中组件的事件等
     *
     * @param savedInstanceState 保存的实例状态
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // 获取布局中的组件
        ImageView dialogImageView = findViewById(R.id.dialogImageView);
        Button closeButton = findViewById(R.id.closeButton);

        // 设置关闭按钮点击事件
        closeButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                dismiss(); // 关闭Dialog
            }
        });
    }
}
```

**步骤四：创建主活动（MainActivity）**

`MainActivity.java`：

```java
// src/com/cfk/dialogstudy/activity/MainActivity.java

package com.cfk.dialogstudy.activity;

import android.os.Bundle;
import android.view.View;
import android.widget.Button;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

import com.cfk.dialogstudy.R;
import com.cfk.dialogstudy.dialog.CustomDialog;

/**
 * 主活动（MainActivity）类
 * 用于展示一个按钮，点击按钮将触发显示自定义Dialog
 */
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // 设置MainActivity的布局为 activity_main.xml
        setContentView(R.layout.activity_main);

        // 获取布局中的按钮
        Button showDialogButton = findViewById(R.id.showDialogButton);

        // 设置按钮点击事件
        showDialogButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 调用方法显示自定义Dialog
                showCustomDialog();
            }
        });
    }

    /**
     * 显示自定义Dialog的方法
     */
    private void showCustomDialog() {
        // 创建自定义Dialog实例
        CustomDialog customDialog = new CustomDialog(this);
        // 显示Dialog
        customDialog.show();
    }
}
```

**步骤五：清单文件注册**

`AndroidManifest.xml`：

```xml
<!-- AndroidManifest.xml -->

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 应用程序的配置信息 -->
    <application
        android:allowBackup="true" <!-- 允许备份 -->
        android:dataExtractionRules="@xml/data_extraction_rules" <!-- 数据提取规则 -->
        android:fullBackupContent="@xml/backup_rules" <!-- 备份规则 -->
        android:icon="@mipmap/ic_launcher" <!-- 应用图标 -->
        android:label="@string/app_name" <!-- 应用名称 -->
        android:roundIcon="@mipmap/ic_launcher_round" <!-- 圆形图标 -->
        android:supportsRtl="true" <!-- 支持右到左的布局 -->
        android:theme="@style/Theme.DialogStudy" <!-- 应用主题 -->
        tools:targetApi="31"> <!-- 目标API版本 -->

        <!-- 主活动的配置信息 -->
        <activity
            android:name=".activity.MainActivity" <!-- 指定活动的类名 -->
            android:exported="true"> <!-- 是否允许其他应用访问此活动 -->
            
            <!-- 意图过滤器，指定活动启动时的动作和类别 -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/> <!-- 主要动作，启动应用程序 -->
                <category android:name="android.intent.category.LAUNCHER"/> <!-- 主要类别，显示在主屏幕上的图标 -->
            </intent-filter>
        </activity>

    </application>

</manifest>
```

**步骤六：运行测试**

当你点击MainActivity中的按钮时，应用将会展示一个自定义Dialog，其中包含一个显示笑脸的ImageView和一个用于关闭Dialog的按钮。

运行以上程序，程序运行截图如下：

![笔记-自定义Dialog示例运行结果截图.gif](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89Dialog%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%88%AA%E5%9B%BE.gif)

由上图可知，该系统成功实现了点击按钮显示笑脸的ImageView和一个用于关闭Dialog的按钮（点击关闭按钮Dialog关闭）的效果。

## 14.2 PopupWindow

### 14.2.1 PopupWindow的介绍

**定义：**

`PopupWindow`（弹出窗口）是Android中的一个界面元素，它是一个用于显示在当前窗口之上的浮动窗口。通常，它用于在屏幕上方弹出一个小窗口，显示额外的信息、选项或操作。`PopupWindow`可以包含各种视图组件，如文本、图像、按钮等，以实现自定义的弹出界面。

在Android开发中，`PopupWindow`类是Android SDK提供的一个重要类，它使开发者能够轻松地创建和管理弹出窗口，以提供更灵活、交互性强的用户界面。

**背景与意义：**

1. **用户体验改善：** 弹出窗口能够提供一种非常直观的用户界面交互方式，可以在不离开当前页面的情况下展示额外的信息或选项，从而改善用户体验。
2. **节省空间：** 当应用程序需要显示额外的选项或者详细信息时，通过弹出窗口可以避免在主界面上占用过多空间，从而保持界面简洁。
3. **上下文相关操作：** 弹出窗口可以根据用户的操作上下文显示不同的内容，为用户提供更精确、有针对性的操作选项。
4. **定制化界面：** 开发者可以通过`PopupWindow`创建具有各种样式和布局的弹出窗口，从而实现对界面的灵活定制。
5. **多用途：** 弹出窗口可以用于多种场景，例如显示提示信息、实现菜单、选择日期或时间等。这种多功能性使得`PopupWindow`成为Android应用程序中常用的UI组件之一。

在Android开发中，了解如何使用和定制`PopupWindow`对于创建富有交互性和个性化的应用界面至关重要。

**PopupWindows的使用方法如下。**

### 14.2.2 自定义PopupWindow

在Android开发中，自定义`PopupWindow`可以为应用增添独特的界面效果和用户交互体验。下面是一步步详细地介绍如何自定义`PopupWindow`：

**步骤一：创建PopupWindow布局文件**

首先，创建自定义弹出窗口的布局文件，例如`custom_popup_layout.xml`：

```xml
<!-- custom_popup_layout.xml -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:padding="16dp">

    <!-- 在这里添加你的自定义视图，比如 TextView、ImageView、Button 等 -->
    <TextView
        android:id="@+id/tvPopupTitle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="自定义弹出窗口标题"
        android:textSize="18sp"
        android:textColor="@android:color/black"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <!-- 根据需要添加其他视图 -->

</androidx.constraintlayout.widget.ConstraintLayout>
```

**步骤二：创建PopupWindow类**

接下来，在你的Activity或Fragment中创建一个自定义`PopupWindow`的类，例如`CustomPopupWindow`：

```java
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.PopupWindow;
import android.widget.TextView;

public class CustomPopupWindow extends PopupWindow {

    private View popupView;
    private TextView tvPopupTitle;

    public CustomPopupWindow(Context context) {
        super(context);

        // 初始化布局
        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        popupView = inflater.inflate(R.layout.custom_popup_layout, null);

        // 设置PopupWindow的视图
        setContentView(popupView);
        setWidth(LinearLayout.LayoutParams.WRAP_CONTENT);
        setHeight(LinearLayout.LayoutParams.WRAP_CONTENT);
        setFocusable(true); // 设置为可获取焦点

        // 初始化布局中的控件
        tvPopupTitle = popupView.findViewById(R.id.tvPopupTitle);

        // 设置其他控件和事件监听器
        // ...

    }

    // 提供方法设置标题文本
    public void setPopupTitle(String title) {
        tvPopupTitle.setText(title);
    }

    // 添加其他方法，以便设置其他控件的内容或监听器
    // ...
}
```

**步骤三：在Activity中使用自定义PopupWindow**

在你的Activity中，实例化`CustomPopupWindow`并在需要的时候显示它。例如：

```java
public class MainActivity extends AppCompatActivity {

    private CustomPopupWindow customPopupWindow;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 初始化CustomPopupWindow
        customPopupWindow = new CustomPopupWindow(this);

        // 在某个触发事件中显示PopupWindow
        Button showPopupButton = findViewById(R.id.btnShowPopup);
        showPopupButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 设置标题文本
                customPopupWindow.setPopupTitle("Custom Popup Title");

                // 显示PopupWindow
                customPopupWindow.showAtLocation(v, Gravity.CENTER, 0, 0);
            }
        });

        // 添加其他UI控件和逻辑
        // ...
    }
}
```

这样，你就成功创建了一个自定义的`PopupWindow`，并在你的Activity中使用它。通过类似的方式，你可以继续添加其他控件和逻辑，实现更复杂的自定义弹出窗口。

下面我们结合一个例子来学习`PopupWindow`：

好的，让我们逐步详细讲解这个例子的步骤，包括文件路径和每个部分的宏观概述。

**1. `memo_popup_layout.xml`：**

```xml
<!-- /res/layout/memo_popup_layout.xml -->
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:background="#6C95B6" <!-- 设置背景色为蓝灰色 -->
    android:padding="16dp">

    <!-- 输入备忘录的 EditText -->
    <EditText
        android:id="@+id/etMemo"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:hint="Enter your memo"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/btnAddMemo"
        android:layout_marginBottom="8dp"
        tools:ignore="HardcodedText" <!-- 提示用户将来替换为字符串资源 -->
    />

    <!-- 添加备忘录的按钮 -->
    <Button
        android:id="@+id/btnAddMemo"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Add Memo"
        app:layout_constraintTop_toBottomOf="@+id/etMemo"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        android:layout_marginTop="8dp"
        tools:ignore="HardcodedText" <!-- 提示用户将来替换为字符串资源 -->
    />

</androidx.constraintlayout.widget.ConstraintLayout>
```

- 布局文件定义了一个 `ConstraintLayout`，其中包含一个用于输入备忘录的 `EditText` 和一个添加备忘录的 `Button`。
- 设置了背景色为蓝灰色，并设置了内边距。

**2. `activity_main.xml`：**

```xml
<!-- /res/layout/activity_main.xml -->
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".activity.MainActivity">

    <!-- 用于触发显示备忘录弹窗的按钮 -->
    <Button
        android:id="@+id/btnShowMemoPopup"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Show Memo Popup"
        app:layout_constraintTop_toTopOf="parent" <!-- 顶部对齐父布局顶部 -->
        app:layout_constraintStart_toStartOf="parent" <!-- 左侧对齐父布局左侧 -->
        app:layout_constraintEnd_toEndOf="parent" <!-- 右侧对齐父布局右侧 -->
        android:layout_marginTop="16dp" <!-- 顶部边距 16dp -->
        android:layout_marginEnd="16dp" <!-- 右侧边距 16dp -->
        android:layout_marginStart="16dp" <!-- 左侧边距 16dp -->
        tools:ignore="HardcodedText" <!-- 提示用户将来替换为字符串资源 -->
    />

</androidx.constraintlayout.widget.ConstraintLayout>
```

- 布局文件定义了一个 `ConstraintLayout`，其中包含一个按钮，点击该按钮将显示备忘录弹窗。

**3. `MemoPopupWindow.java`：**

```java
// /src/com/cfk/popupwindow/popupwindow/MemoPopupWindow.java
package com.cfk.popupwindow.popupwindow;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.PopupWindow;
import android.widget.Toast;

import com.cfk.popupwindow.R;

/**
 * `MemoPopupWindow` 是一个自定义的弹窗类，用于显示备忘录输入框和添加按钮。
 */
public class MemoPopupWindow extends PopupWindow {

    // 弹窗的布局视图
    private View popupView;

    // 备忘录输入框和添加按钮
    private EditText etMemo;
    private Button btnAddMemo;

    /**
     * 构造函数，用于初始化 MemoPopupWindow。
     *
     * @param context      上下文对象
     * @param memoListener 备忘录监听器，用于通知调用者备忘录的添加
     */
    public MemoPopupWindow(Context context, final MemoListener memoListener) {
        super(context);

        // 初始化布局
        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        popupView = inflater.inflate(R.layout.memo_popup_layout, null);

        // 设置 PopupWindow 的视图
        setContentView(popupView);
        setWidth(LinearLayout.LayoutParams.WRAP_CONTENT);
        setHeight(ViewGroup.LayoutParams.WRAP_CONTENT);
        setFocusable(true);

        // 初始化布局中的控件
        etMemo = popupView.findViewById(R.id.etMemo);
        btnAddMemo = popupView.findViewById(R.id.btnAddMemo);

        // 设置按钮点击事件
        btnAddMemo.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String memoText = etMemo.getText().toString();

                if (!memoText.isEmpty()) {
                    // 回调通知 Activity 添加备忘录
                    memoListener.onMemoAdded(memoText);

                    // 关闭 PopupWindow
                    dismiss();
                } else {
                    Toast.makeText(context, "Please enter your memo", Toast.LENGTH_SHORT).show();
                }
            }
        });
    }

    /**
     * 定义备忘录添加的回调接口 MemoListener。
     */
    public interface MemoListener {
        void onMemoAdded(String memo);
    }
}
```

- `MemoPopupWindow` 类继承自 `PopupWindow`，用于创建输入备忘录的弹窗。
- 通过 `LayoutInflater` 加载了 `memo_popup_layout.xml` 布局。
- 提供了一个回调接口 `MemoListener` 用于通知主界面添加备忘录。

**4. `MainActivity.java`：**

```java
// /src/com/cfk/popupwindow/activity/MainActivity.java
package com.cfk.popupwindow.activity;

import android.os.Bundle;
import android.view.Gravity;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

import com.cfk.popupwindow.R;
import com.cfk.popupwindow.popupwindow.MemoPopupWindow;

/**
 * `MainActivity` 是应用程序的主活动，负责展示主界面和处理用户交互。
 */
public class MainActivity extends AppCompatActivity {

    // MemoPopupWindow 弹窗实例
    private MemoPopupWindow memoPopupWindow;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 初始化 MemoPopupWindow
        memoPopupWindow = new MemoPopupWindow(this, new MemoPopupWindow.MemoListener() {
            @Override
            public void onMemoAdded(String memo) {
                // 处理备忘录添加逻辑，例如将备忘录添加到列表中
                // 在这里，我们简单地使用 Toast 显示备忘录内容
                Toast.makeText(MainActivity.this, "Memo added: " + memo, Toast.LENGTH_SHORT).show();
            }
        });

        // 在某个触发事件中显示 MemoPopupWindow
        Button showMemoPopupButton = findViewById(R.id.btnShowMemoPopup);
        showMemoPopupButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 显示 MemoPopupWindow
                memoPopupWindow.showAtLocation(v, Gravity.CENTER, 0, 0);
            }
        });

        // 添加其他 UI 控件和逻辑
        // ...
    }
}
```

- `MainActivity` 类是应用的主界面，包含一个按钮，点击该按钮将显示备忘录弹窗。
- 初始化了 `MemoPopupWindow` 实例，并设置了弹窗的回调，用于处理添加备忘录的逻辑。

**5. `AndroidManifest.xml`：**

```xml
<!-- /app/src/main/AndroidManifest.xml -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Application 元素包含了整个应用程序的配置信息 -->
    <application
        android:allowBackup="true" <!-- 是否允许备份应用数据 -->
        android:dataExtractionRules="@xml/data_extraction_rules" <!-- 数据提取规则 -->
        android:fullBackupContent="@xml/backup_rules" <!-- 完整备份规则 -->
        android:icon="@mipmap/ic_launcher" <!-- 应用图标 -->
        android:label="@string/app_name" <!-- 应用名称 -->
        android:roundIcon="@mipmap/ic_launcher_round" <!-- 圆形应用图标 -->
        android:supportsRtl="true" <!-- 是否支持RTL（右到左）布局 -->
        android:theme="@style/Theme.PopupWindow" <!-- 应用主题 -->
        tools:targetApi="31"> <!-- 针对的 API 级别 -->

        <!-- MainActivity 是应用的主活动 -->
        <activity android:name=".activity.MainActivity"
            android:exported="true"> <!-- 是否允许其他应用调用此 Activity -->
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/> <!-- 主活动的意图过滤器 -->
                <category android:name="android.intent.category.LAUNCHER"/> <!-- 启动器类别 -->
            </intent-filter>
        </activity>
    </application>

</manifest>
```

- 清单文件中注册了应用的主活动 `MainActivity`。

**6. 运行测试：**

这个例子实现了一个简单的备忘录应用。当你运行应用时，主界面上会有一个按钮，点击该按钮会弹出一个自定义的备忘录弹窗。在弹窗中，你可以输入备忘录内容并点击"Add Memo"按钮，然后弹窗会关闭，并通过`Toast`显示你刚刚输入的备忘录内容。

运行以上程序，运行结果截图如下：

![笔记-自定义PopupWindow示例运行结果截图.gif](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89PopupWindow%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%88%AA%E5%9B%BE.gif)

由上图可知，该程序成功实现了点击该按钮会弹出一个自定义的备忘录弹窗。在弹窗中，你可以输入备忘录内容并点击"Add Memo"按钮，然后弹窗会关闭，并通过`Toast`显示你刚刚输入的备忘录内容的效果。

## 14.3 Dialog和PopupWindow的区别

在Android开发中，Dialog和PopupWindow都是用于创建弹出式用户界面的工具，但它们在实现和使用上有一些区别。

**1. Dialog（对话框）：**

- **类型：** Dialog是一个广义的概念，用于描述应用中与用户进行交互的窗口。在Android中，Dialog通常指的是`Dialog`类的实例。
  
- **继承：** Dialog是直接继承自`Object`类，是Android系统提供的弹窗类。

- **显示位置：** Dialog是覆盖在整个Activity上的，通常会居中显示，用户在与Dialog进行交互时，会阻止对Activity的操作。

- **使用场景：** 适用于需要在应用的主界面上进行交互的情况，比如警告、确认、输入等。

- **代码示例：**

  ```java
  AlertDialog.Builder builder = new AlertDialog.Builder(context);
  builder.setTitle("Dialog Title")
         .setMessage("Dialog Message")
         .setPositiveButton("OK", new DialogInterface.OnClickListener() {
             public void onClick(DialogInterface dialog, int id) {
                 // 处理确定按钮点击事件
             }
         })
         .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
             public void onClick(DialogInterface dialog, int id) {
                 // 处理取消按钮点击事件
             }
         });
  AlertDialog dialog = builder.create();
  dialog.show();
  ```

**2. PopupWindow：**

- **类型：** PopupWindow是一个具体的类，属于View的一部分，用于在界面上方或下方弹出一个浮动的窗口。

- **继承：** PopupWindow是直接继承自`Object`类。

- **显示位置：** PopupWindow相对于其父布局或指定的锚点显示，可以自由设置位置。

- **使用场景：** 适用于需要在特定位置显示浮动窗口的情况，比如下拉菜单、提示框等。

- **代码示例：**

  ```java
  LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View popupView = inflater.inflate(R.layout.popup_layout, null);
  
  PopupWindow popupWindow = new PopupWindow(
      popupView,
      ViewGroup.LayoutParams.WRAP_CONTENT,
      ViewGroup.LayoutParams.WRAP_CONTENT
  );
  
  Button btnDismiss = popupView.findViewById(R.id.btnDismiss);
  btnDismiss.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View v) {
          // 关闭PopupWindow
          popupWindow.dismiss();
      }
  });
  
  // 显示PopupWindow相对于按钮的位置
  popupWindow.showAsDropDown(anchorView, 0, -30);
  ```

**主要区别：**

1. **继承关系：** Dialog是一个类似概念的界面元素，而PopupWindow是直接从`Object`继承的具体类。

2. **显示位置：** Dialog通常居中显示在整个Activity上，而PopupWindow可以相对于特定的锚点或父布局显示，具有更大的灵活性。

3. **适用场景：** Dialog适用于需要阻止对整个Activity的交互、对话框式的交互场景，而PopupWindow适用于需要在特定位置显示浮动窗口、与其他元素关联的场景。

总体而言，选择使用Dialog还是PopupWindow取决于你的交互需求和设计布局的复杂性。

# 15 Handler & AsyncTask

## 15.1 Handler

### 15.1.1 Handler的介绍

### 15.1.2 Handler的使用

## 15.2 AsyncTask

### 15.2.1 AsyncTask的介绍

### 15.2.2 AsyncTask的使用

# 16 Frament

## 16.1 Frament的介绍

## 16.2 Frament的生命周期

## 16.3 使用Frament切换不同用户片段

## 16.4 FragmentManager的介绍

## 16.5 Fragment与Activity之间的通信

# 17 SQLite

## 17.1 SQLite的介绍

## 17.2 表的创建操作

## 17.3 数据的增删改查操作

## 17.4 更新SQL表操作

# 18 动画

## 18.1 动画的介绍

## 18.2 动画的种类

### 18.3 动画的使用



# x1 APK Analyzer的使用

[APK Analyzer的使用](https://blog.csdn.net/qiantanlong/article/details/85127774)

# x2 在Android Studio中进行测试

[在AndroidStudio中使用单元测试](https://blog.csdn.net/yingaizhu/article/details/80297087)

# x3 Android分包策略推荐

[Android项目分包(二) Android分包策略推荐](https://blog.csdn.net/q610098308/article/details/78982551)

# x4 其它说明

## x4.1 res下中Drawable文件夹Dpi说明

**定义：**

在Android开发中，`dpi` 在 `drawable-mdpi` 中指的是 "Density-independent Pixels"，是一种与设备屏幕密度无关的像素单位。Density-independent Pixels (dpi)是一种度量像素的单位，与实际设备的屏幕密度无关。它允许开发者创建适用于不同屏幕密度的资源，确保应用在不同设备上都有一致的外观。

**背景与意义：**

关于Android开发中Dpi使用的背景与意义说明如下：

- **多屏幕适配：** Android设备具有各种屏幕密度，为了适应这些差异，开发者需要提供不同密度版本的图像和资源。`drawable-mdpi` 表示其中的资源适用于中等密度的屏幕，通过这样的命名约定，Android系统可以选择适当的资源版本以在各种设备上获得最佳显示效果。
- **密度无关性：** 使用`dpi`单位和相关的资源文件夹命名规则，Android系统可以在运行时动态选择适应目标设备的资源，从而实现对不同密度设备的优化，提供一致的用户体验，而无需过多关注实际的硬件屏幕密度。

总体来说，`dpi` 表示一种帮助开发者适应不同屏幕密度的概念，以确保在各种Android设备上都能提供一致的用户体验。

**详细介绍：**

 `dpi` 是一种度量像素的单位，表示 Density-independent Pixels，即与实际设备的屏幕密度无关的像素。Android 中的 `dpi` 单位用于适应不同屏幕密度的设备。使用 `dpi` 单位可以让开发者在设计应用界面时不必担心不同设备的屏幕密度差异。系统在运行时会根据设备的实际密度进行适当的缩放，以保持一致的用户体验。下面是关于`drawable`文件夹的说明。

**`drawable` 文件夹：**

- **定义：** `drawable` 文件夹是 Android 项目中用于存放可绘制资源的文件夹，包括图标、图片和其他图形元素，用于应用程序的用户界面。
- **多屏幕适配：** Android 提供了多屏幕适配机制，其中 `drawable` 文件夹被分为不同密度的子文件夹，以提供在不同设备上显示最佳效果的图像资源。

**`drawable` 的子文件夹：**

1. 当设计Android应用时，可以使用`drawable` 文件夹及其不同密度子文件夹来存储图像资源，以确保在不同屏幕密度下有最佳的显示效果。以下是这些子文件夹按照递增的屏幕密度顺序的解释：

   1. **`drawable-ldpi` 文件夹:**
      - **含义：** 低密度屏幕资源文件夹，适用于低密度屏幕设备。
      - **使用场景：** 存放适用于低密度屏幕的图像资源，确保在这类设备上显示正常。

   2. **`drawable-mdpi` 文件夹:**
      - **含义：** 中等密度屏幕资源文件夹，适用于中等密度屏幕设备。
      - **使用场景：** 包含为中等密度屏幕设计的图像资源。Android 系统会根据设备的实际密度自动选择正确的资源版本，确保在不同设备上的一致性。

   3. **`drawable-hdpi` 文件夹:**
      - **含义：** 高密度屏幕资源文件夹，适用于高密度屏幕设备。
      - **使用场景：** 包含为高密度屏幕设计的图像资源，确保在这类设备上显示清晰。

   4. **`drawable-xhdpi` 文件夹:**
      - **含义：** 额外高密度屏幕资源文件夹，适用于额外高密度屏幕设备。
      - **使用场景：** 针对更高密度的屏幕，提供更大分辨率的图像资源。

   5. **`drawable-xxhdpi` 文件夹:**
      - **含义：** 额外额外高密度屏幕资源文件夹，适用于额外额外高密度屏幕设备。
      - **使用场景：** 针对更高密度的屏幕，提供更大分辨率的图像资源，通常用于大屏设备。

   6. **`drawable-xxxhdpi` 文件夹:**
      - **含义：** 额外额外额外高密度屏幕资源文件夹，适用于额外额外额外高密度屏幕设备。
      - **使用场景：** 针对最高密度的屏幕，提供最大分辨率的图像资源，以适应超高分辨率的屏幕。

   通过使用这些子文件夹，Android系统能够根据设备的屏幕密度智能地选择适当的图像资源，以提供一致且最佳的用户体验。

## x4.2 SVG路径语法

**定义：**

- **SVG（Scalable Vector Graphics）：** SVG是一种用于描述二维矢量图形的XML标记语言，由W3C制定。它允许开发者创建可缩放的图形，以便在不同分辨率和尺寸的设备上保持清晰度。
- **路径语法：** SVG路径语法用于在SVG文档中定义图形的轮廓。路径由一系列命令和参数组成，用于描述直线、曲线、圆弧、矩形等基本形状，以及它们之间的关系。

**背景与意义：**

- **可缩放性：** SVG路径语法的主要背景是解决图形在不同屏幕分辨率下失真的问题。由于路径是基于矢量的，可以无损地缩放，使得图形在不同设备上展现出色。

- **网页图形标准：** 随着Web的发展，对可交互、可缩放图形的需求增加。SVG路径语法成为Web开发中常用的图形标准，为开发者提供了一种轻量而强大的工具，用于创建各种图形。
- **动态图形和动画：** SVG路径语法不仅定义静态图形，还支持动态图形和动画。通过JavaScript或CSS，可以实现路径的动态修改、图形的变形和动画效果，为用户提供更丰富的视觉体验。
- **文本编辑和可读性：** SVG路径可以直接以文本形式编辑，也可以通过图形编辑工具生成。这种可读性和可编辑性使得开发者可以更容易地理解、修改和维护SVG图形。

总体而言，SVG路径语法在提供可缩放矢量图形的同时，还为开发者提供了灵活性、可交互性和可读性，使其成为Web开发中广泛应用的图形描述方式。

**使用方法：**

SVG路径语法是通过在SVG文档中使用`<path>`元素来创建的。路径元素包含一个`d`属性，该属性的值是一串描述路径的命令和参数。下面是SVG路径语法的一般格式：

```xml
<path d="M x1 y1 L x2 y2 C x3 y3, x4 y4, x5 y5 Z" />
```

其中，`M`表示移动到起始点，`L`表示绘制直线，`C`表示绘制三次贝塞尔曲线，`Z`表示闭合路径。具体的命令和参数会根据所需的图形而变化。以下是一些常见的SVG路径命令和参数：

- **M (Move To)：** 移动到指定的坐标位置。
  - 示例：`M 10 10`

- **L (Line To)：** 从当前点画一条直线到指定的坐标位置。
  - 示例：`L 20 20`

- **H (Horizontal Line To)：** 从当前点水平移动到指定的 x 坐标位置。
  - 示例：`H 30`

- **V (Vertical Line To)：** 从当前点垂直移动到指定的 y 坐标位置。
  - 示例：`V 30`

- **C (Cubic Bezier Curve To)：** 绘制三次贝塞尔曲线。
  - 示例：`C 10 10, 20 20, 30 10`

- **Z (Close Path)：** 封闭路径，连接当前点与起始点。
  - 示例：`Z`

通过组合这些命令和参数，可以创建各种形状，例如直线、曲线、矩形等。以下是一个简单的例子，创建一个由直线和曲线组成的心形：

```xml
<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
  <!-- 
    "M" 表示移动到起始点，
    (50, 10) 是起始点的坐标
  -->
  <path d="
    M 50 10
    <!-- 
      "C" 表示绘制三次贝塞尔曲线，
      (80, 10) 是第一个控制点，
      (80, 40) 是第二个控制点，
      (50, 70) 是终点
    -->
    C 80 10, 80 40, 50 70
    <!-- 
      再次绘制一条三次贝塞尔曲线，
      (20, 40) 是第一个控制点，
      (20, 10) 是第二个控制点，
      (50, 10) 是终点，
      "Z" 表示封闭路径，连接终点和起始点
    -->
    C 20 40, 20 10, 50 10
    Z
  " fill="red" stroke="black" />
</svg>
```

这段SVG路径代码绘制了一个简单的心形。让我们逐步解释这个图形是如何形成的：

1. **M 50 10：** 移动到起始点 (50, 10)。

2. **C 80 10, 80 40, 50 70：** 绘制一条三次贝塞尔曲线，起始点为当前位置 (50, 10)，第一个控制点是 (80, 10)，第二个控制点是 (80, 40)，终点是 (50, 70)。这一段贝塞尔曲线的形状使得心形的上半部分。

3. **C 20 40, 20 10, 50 10：** 绘制另一条三次贝塞尔曲线，起始点为当前位置 (50, 70)，第一个控制点是 (20, 40)，第二个控制点是 (20, 10)，终点是 (50, 10)。这一段贝塞尔曲线的形状使得心形的下半部分。

4. **Z：** 封闭路径，连接当前点 (50, 10) 与起始点 (50, 10)，形成完整的心形。

5. **fill="red"：** 设置填充颜色为红色，使得心形被填充为红色。

6. **stroke="black"：** 设置边框颜色为黑色，为心形添加黑色边框。

总体而言，这段SVG路径代码通过两段三次贝塞尔曲线的组合，绘制了一个简单的心形，填充为红色，同时具有黑色的边框。通过调整坐标和控制点，你可以修改路径以创建不同形状和风格的心形。

该段代码运行结果如下：

![笔记-SVG路径语法示例运行结果.png](https://raw.githubusercontent.com/T-L-T-D/Workspace/main/TyporaWorkspace/img/%E7%AC%94%E8%AE%B0-SVG%E8%B7%AF%E5%BE%84%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

由运行结果可知，这段SVG路径代码通过两段三次贝塞尔曲线的组合，成功绘制了一个简单的心形，填充为红色，同时具有黑色的边框。
